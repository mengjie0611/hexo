<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>简简单单</title>
  
  
  <link href="http://mengjie.com/atom.xml" rel="self"/>
  
  <link href="http://mengjie.com/"/>
  <updated>2022-06-29T08:54:07.363Z</updated>
  <id>http://mengjie.com/</id>
  
  <author>
    <name>Jie Meng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mac生成ssh公匙,配置github SSH公钥连接</title>
    <link href="http://mengjie.com/2022/06/18/mac%E7%94%9F%E6%88%90ssh%E5%85%AC%E5%8C%99/"/>
    <id>http://mengjie.com/2022/06/18/mac%E7%94%9F%E6%88%90ssh%E5%85%AC%E5%8C%99/</id>
    <published>2022-06-18T00:00:00.000Z</published>
    <updated>2022-06-29T08:54:07.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mac生成ssh公匙"><a href="#mac生成ssh公匙" class="headerlink" title="mac生成ssh公匙"></a>mac生成ssh公匙</h2><p>  首先在mac下进入~/.ssh,查看是否已经有公匙。<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">ls</span><br><span class="line"># known_hosts</span><br></pre></td></tr></table></figure><br>  现只有一个known_hosts，那我们就建一个ssh公钥，继续输入以下指令创建ssh公钥：<br>  ssh-keygen<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  .ssh ssh-keygen</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/Users/xxx/.ssh/id_rsa):</span><br></pre></td></tr></table></figure><br>  首先会让你输入公钥存储文件，输入默认的就行（/Users/你的电脑用户名/.ssh/id_rsa）。然后会输入公钥使用密码，输入两次，可以直接回车不设置。（建议直接回车，设置后后面提交代码也很麻烦，每次都要验证输入以下）。 创建完成后，再次输入ls查看目录下是否已经生成了公钥，确认有后，使用命令cat id_rsa.pub查看公钥<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure><br>  从ssh-rsa开始一直到.local都是ssh公钥，复制出来，一会要到github中创建shh连接使用</p><h2 id="github配置生成的ssh公匙"><a href="#github配置生成的ssh公匙" class="headerlink" title="github配置生成的ssh公匙"></a>github配置生成的ssh公匙</h2><p>  进行github ssh连接配置，首先进入github，然后点击个人头像后，选择Settings<br>  然后再点击SSH and GPG，再点击 New SSH key<br>  有两个参数设置，title可以随便写，key就是我们前面复制的SSH公钥（id_rsa.pub文件内容）。<br>  粘贴好后，点击 Add SSH Key即可</p><h2 id="验证测试ssh公钥配置是否成功"><a href="#验证测试ssh公钥配置是否成功" class="headerlink" title="验证测试ssh公钥配置是否成功"></a>验证测试ssh公钥配置是否成功</h2>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>  如果创建ssh时设置了密码，需要先输入密码，然后根据提示输入yes，同意连接，显示结果为下面这样则表示连接成功<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi xxx! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><br>  如果之前仓库关联模式是http则需要变更为ssh，进入本地对应项目，执行以下语句<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin 对应的SSH</span><br></pre></td></tr></table></figure><br>  然后就生成ssh配置github ssh公匙成功了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;mac生成ssh公匙&quot;&gt;&lt;a href=&quot;#mac生成ssh公匙&quot; class=&quot;headerlink&quot; title=&quot;mac生成ssh公匙&quot;&gt;&lt;/a&gt;mac生成ssh公匙&lt;/h2&gt;&lt;p&gt;  首先在mac下进入~/.ssh,查看是否已经有公匙。&lt;br&gt;  &lt;fig</summary>
      
    
    
    
    
    <category term="git" scheme="http://mengjie.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>H5</title>
    <link href="http://mengjie.com/2021/10/13/html5/"/>
    <id>http://mengjie.com/2021/10/13/html5/</id>
    <published>2021-10-13T00:00:00.000Z</published>
    <updated>2022-01-12T07:47:15.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS跳转到app-store内应用下载页面"><a href="#JS跳转到app-store内应用下载页面" class="headerlink" title="JS跳转到app store内应用下载页面"></a>JS跳转到app store内应用下载页面</h1><p>跳转到应用商店:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(https)|(itms-apps)://itunes.apple.com/app/id&#123;appID&#125;</span><br></pre></td></tr></table></figure><p>跳转到撰写评价：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(https)|(itms-apps)://itunes.apple.com/app/id&#123;appID&#125;?action=write-review</span><br></pre></td></tr></table></figure><p>跳转到查看评价：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(https)|(itms-apps)://itunes.apple.com/app/viewContentsUserReviews?id=&#123;appID&#125;</span><br></pre></td></tr></table></figure><p>手机端和pc端均可适用。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.location.href = &#x27;itms-apps://itunes.apple.com/app/id414478124?action=write-review&#x27;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS跳转到app-store内应用下载页面&quot;&gt;&lt;a href=&quot;#JS跳转到app-store内应用下载页面&quot; class=&quot;headerlink&quot; title=&quot;JS跳转到app store内应用下载页面&quot;&gt;&lt;/a&gt;JS跳转到app store内应用下载页面&lt;/</summary>
      
    
    
    
    
    <category term="面试" scheme="http://mengjie.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>JS Object</title>
    <link href="http://mengjie.com/2021/08/05/js/"/>
    <id>http://mengjie.com/2021/08/05/js/</id>
    <published>2021-08-05T06:20:40.000Z</published>
    <updated>2021-08-10T02:28:51.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Object扩展方法"><a href="#Object扩展方法" class="headerlink" title="Object扩展方法"></a>Object扩展方法</h2><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var car = &#123;name:&quot;汽车&quot;，run:function()&#123;console.log(&#x27;跑起来&#x27;)&#125;&#125;</span><br><span class="line">var Passat = Object.create(car,&#123;</span><br><span class="line">brand:&#123;</span><br><span class="line">value:&#x27;帕萨特&#x27;,</span><br><span class="line">writabkle:true, //属性是否可以修改</span><br><span class="line">configurable:true,//属性是否可以删除</span><br><span class="line">enumerable：false // 属性是否可以枚举 &#125;，</span><br><span class="line">price:&#123;</span><br><span class="line">get:function()&#123;&#125;,</span><br><span class="line">set:function()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties()"></a>Object.defineProperties()</h3> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let sanlun = &#123;name : &quot;三轮车&quot;&#125;</span><br><span class="line">Object.defineProperties（sanlun,&#123;</span><br><span class="line">brand: &#123;value:&#x27;zzz&#x27;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Object扩展方法&quot;&gt;&lt;a href=&quot;#Object扩展方法&quot; class=&quot;headerlink&quot; title=&quot;Object扩展方法&quot;&gt;&lt;/a&gt;Object扩展方法&lt;/h2&gt;&lt;h3 id=&quot;Object-create&quot;&gt;&lt;a href=&quot;#Object-c</summary>
      
    
    
    
    
    <category term="JavaScript" scheme="http://mengjie.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>命令行 linux常用命令</title>
    <link href="http://mengjie.com/2021/08/05/%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://mengjie.com/2021/08/05/%E5%B0%8F%E6%8A%80%E5%B7%A7/</id>
    <published>2021-08-05T06:20:40.000Z</published>
    <updated>2021-08-06T03:19:36.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="linux常用命令"><a href="#linux常用命令" class="headerlink" title="linux常用命令"></a>linux常用命令</h2><p> ls 查看当前文件夹下的文件 list单词缩写<br> cd 进入某一个文件夹内 change direct cd ..  cd/f<br> clear 清屏 crtl+l<br> mkdir 创建文件夹 mkdir + 文件名<br> touch 创建文件 touch + 文件名<br> rm 删除文件 rm + 文件名  删库跑路 rm / -rf  删除数据库的命令 drop database project(mysql) db.dropDatabase(moogodb)<br> rm dir -f 删除文件夹 f强制删除文件夹<br> mv 移动文件夹 mv +  文件名 + 移动到的文件夹/ 新的命名<br> cat 查看文件内容 cat + 文件名<br> ctrl + c 取消命令<br> tab 自动补全<br> 上下方向键查看命令行历史记录<br> Vim是一款命令行下的文本编辑器，编辑方式和图形化编辑器不同</p><p> vim + 文件名 编辑此文件（文件不存在则创建）<br> i 进入编辑模式 insert<br> esc + ：wq 保存并提出<br> esc + ：q！ 不保存并退出</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;linux常用命令&quot;&gt;&lt;a href=&quot;#linux常用命令&quot; class=&quot;headerlink&quot; title=&quot;linux常用命令&quot;&gt;&lt;/a&gt;linux常用命令&lt;/h2&gt;&lt;p&gt; ls 查看当前文件夹下的文件 list单词缩写&lt;br&gt; cd 进入某一个文件夹内 </summary>
      
    
    
    
    
    <category term="JavaScript" scheme="http://mengjie.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>butterfly博客主题的详细配置</title>
    <link href="http://mengjie.com/2021/07/19/butterfly/"/>
    <id>http://mengjie.com/2021/07/19/butterfly/</id>
    <published>2021-07-19T03:14:48.355Z</published>
    <updated>2021-07-19T03:22:01.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><h3 id="1-1-安装主题"><a href="#1-1-安装主题" class="headerlink" title="1.1 安装主题"></a>1.1 安装主题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><h3 id="1-2-启用主题"><a href="#1-2-启用主题" class="headerlink" title="1.2 启用主题"></a>1.2 启用主题</h3><p>打开根<code>_config.yml</code>配置文件，找到theme字段，将其值改为butterfly(先确认主题文件夹名称是否为butterfly)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 根 _config.yml</span><br><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure><p>修改后在根目录文件夹下执行以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</span><br></pre></td></tr></table></figure><h3 id="1-4-验证"><a href="#1-4-验证" class="headerlink" title="1.4 验证"></a>1.4 验证</h3><p>首先启动 Hexo 本地站点，并开启调试模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure><p>在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</span><br><span class="line">此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。</span><br></pre></td></tr></table></figure><h3 id="1-5-更新主题"><a href="#1-5-更新主题" class="headerlink" title="1.5 更新主题"></a>1.5 更新主题</h3><p>今后若主题添加了新功能正是您需要的，您可以直接git pull来更新主题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd themes/butterfly</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><h3 id="2-1-设置语言"><a href="#2-1-设置语言" class="headerlink" title="2.1 设置语言"></a>2.1 设置语言</h3><p>该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在根_config.yml配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 根 _config.yml</span><br><span class="line">language: zh-CN</span><br></pre></td></tr></table></figure><h3 id="2-2-设置菜单"><a href="#2-2-设置菜单" class="headerlink" title="2.2 设置菜单"></a>2.2 设置菜单</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 打开主题找到， themes/butterfly/_config.yml</span><br><span class="line">menu:</span><br><span class="line">  - page: home</span><br><span class="line">    directory: .</span><br><span class="line">    icon: fa-home</span><br><span class="line">  - page: archive</span><br><span class="line">    directory: archives/</span><br><span class="line">    icon: fa-archive</span><br><span class="line">  # - page: about</span><br><span class="line">  #   directory: about/</span><br><span class="line">  #   icon: fa-user</span><br><span class="line">  - page: rss</span><br><span class="line">    directory: atom.xml</span><br><span class="line">    icon: fa-rss</span><br></pre></td></tr></table></figure><h4 id="2-2-1-添加about页面"><a href="#2-2-1-添加about页面" class="headerlink" title="2.2.1 添加about页面"></a>2.2.1 添加about页面</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：</span><br><span class="line">hexo new page &#x27;about&#x27;</span><br><span class="line"></span><br><span class="line">// 打开主题找到， themes/butterfly/_config.yml</span><br><span class="line"># About page</span><br><span class="line">about:</span><br><span class="line">  photo_url: ## 头像的链接地址 https://avatars0.githubusercontent.com/u/29102045?s=460&amp;v=4</span><br><span class="line">  items:</span><br><span class="line">  - label: email</span><br><span class="line">    url: ## 个人邮箱</span><br><span class="line">    title: ## 邮箱用户名</span><br><span class="line">  - label: github</span><br><span class="line">    url: ## github主页</span><br><span class="line">    title: ## github用户名</span><br><span class="line">  - label: weibo</span><br><span class="line">    url: ## weibo主页</span><br><span class="line">    title: ## weibo用户名</span><br><span class="line"># - label: twitter</span><br><span class="line">#   url: </span><br><span class="line">#   title:</span><br><span class="line"># - label: facebook</span><br><span class="line">#   url:</span><br><span class="line">#   title:</span><br></pre></td></tr></table></figure><h4 id="2-2-2-安装-RSS-订阅-和-sitemap-网站地图-插件"><a href="#2-2-2-安装-RSS-订阅-和-sitemap-网站地图-插件" class="headerlink" title="2.2.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件"></a>2.2.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件</h4><ul><li><p>在根目录下打开命令行窗口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure></li><li><p>添加主题_config.yml配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//  themes/butterfly/_config.yml </span><br><span class="line"></span><br><span class="line">Plugins:</span><br><span class="line">  hexo-generator-feed</span><br><span class="line">  hexo-generator-sitemap</span><br><span class="line">  hexo-generator-baidu-sitemap</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-添加本地搜索"><a href="#2-3-添加本地搜索" class="headerlink" title="2.3 添加本地搜索"></a>2.3 添加本地搜索</h3><p>安装插件<code>hexo-generator-json-content</code>来创建JSON数据文件：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-json-content@2.2.0 --save</span><br></pre></td></tr></table></figure><p>然后在根_config.yml添加配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 根_config.yml</span><br><span class="line"></span><br><span class="line">jsonContent:</span><br><span class="line">  meta: false</span><br><span class="line">  pages: false</span><br><span class="line">  posts:</span><br><span class="line">    title: true</span><br><span class="line">    date: true</span><br><span class="line">    path: true</span><br><span class="line">    text: true</span><br><span class="line">    raw: false</span><br><span class="line">    content: false</span><br><span class="line">    slug: false</span><br><span class="line">    updated: false</span><br><span class="line">    comments: false</span><br><span class="line">    link: false</span><br><span class="line">    permalink: false</span><br><span class="line">    excerpt: false</span><br><span class="line">    categories: false</span><br><span class="line">    tags: true</span><br></pre></td></tr></table></figure><p>最后在主题themes/butterfly/_config.yml添加配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//  themes/butterfly/_config.yml   </span><br><span class="line">local_search: true</span><br></pre></td></tr></table></figure><h3 id="2-4-其他配置"><a href="#2-4-其他配置" class="headerlink" title="2.4 其他配置"></a>2.4 其他配置</h3><p>主题themes/butterfly/_config.yml添加其他配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//  themes/butterfly/_config.yml  </span><br><span class="line">// show_category_count——是否显示分类下的文章数。</span><br><span class="line">// widgets_on_small_screens——是否在小屏显示侧边栏，若true,则侧边栏挂件将显示在底部。</span><br><span class="line"></span><br><span class="line">show_category_count: true </span><br><span class="line">widgets_on_small_screens: true</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot; class=&quot;headerlink&quot; title=&quot;1. 安装&quot;&gt;&lt;/a&gt;1. 安装&lt;/h2&gt;&lt;h3 id=&quot;1-1-安装主题&quot;&gt;&lt;a href=&quot;#1-1-安装主题&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="Hexo" scheme="http://mengjie.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://mengjie.com/2021/07/13/hello-world/"/>
    <id>http://mengjie.com/2021/07/13/hello-world/</id>
    <published>2021-07-13T06:51:08.365Z</published>
    <updated>2021-07-13T07:51:59.214Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>命运善嫉，总吝啬赋予世人恒久的平静，<br>总猝不及防的把人一下子塞进过山车，<br>任你怎么恐惧挣扎也不肯轻易停下来，<br>非要把圆满的颠簸成支离破碎的，<br>再命你耗尽半生去拼补……<br>From 知乎 / 你一生的最低点是怎样的经历？</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;命运善嫉，总吝啬赋予世人恒久的平静，&lt;br&gt;总猝不及防的把人一下子塞进过山车，&lt;br&gt;任你怎么恐惧挣扎也不肯轻易停下来，&lt;br&gt;非要把圆满的颠簸成支离破碎的，&lt;br&gt;再命你耗尽半生去拼补……&lt;br&gt;From 知乎 / 你一生的最低点是怎样的经历？&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>JavaScript中的异步编程解决方案</title>
    <link href="http://mengjie.com/2021/03/18/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>http://mengjie.com/2021/03/18/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</id>
    <published>2021-03-18T09:05:05.000Z</published>
    <updated>2021-07-19T05:53:56.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h2><p>学习指导：<a href="http://es6.ruanyifeng.com/#docs/generator">阮一峰ES6 – Generator函数</a></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>语法上：Generator 函数是一个状态机，封装了多个内部状态；执行 Generator 函数会返回一个遍历器对象。也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</li><li>形式上：Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号<code>*</code>；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world）</span></span><br><span class="line"><span class="comment">// 即该函数有三个状态：hello，world 和 return 语句（结束执行）。</span></span><br></pre></td></tr></table></figure><ul><li>调用Generator函数，返回一个遍历器对象，代表Generator函数的内部指针。以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value和done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上述函数下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。</span></span><br><span class="line"><span class="comment">// 即每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，</span></span><br><span class="line"><span class="comment">// 直到遇到下一个yield表达式（或return语句）为止。</span></span><br><span class="line"><span class="comment">// 换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解释说明：</span></span><br><span class="line"><span class="comment">上面代码一共调用了四次next方法。</span></span><br><span class="line"><span class="comment">第一次调用，Generator 函数开始执行，直到遇到第一个yield表达式为止。</span></span><br><span class="line"><span class="comment">next方法返回一个对象，它的value属性就是当前yield表达式的值hello，</span></span><br><span class="line"><span class="comment">done属性的值false，表示遍历还没有结束。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。</span></span><br><span class="line"><span class="comment">next方法返回的对象的value属性就是当前yield表达式的值world，</span></span><br><span class="line"><span class="comment">done属性的值false，表示遍历还没有结束。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句</span></span><br><span class="line"><span class="comment">（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，</span></span><br><span class="line"><span class="comment">就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），</span></span><br><span class="line"><span class="comment">done属性的值true，表示遍历已经结束。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第四次调用，此时 Generator 函数已经运行完毕，</span></span><br><span class="line"><span class="comment">next方法返回对象的value属性为undefined，done属性为true。</span></span><br><span class="line"><span class="comment">以后再调用next方法，返回的都是这个值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="yield-表达式说明"><a href="#yield-表达式说明" class="headerlink" title="yield 表达式说明"></a>yield 表达式说明</h3><ul><li>Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。</li><li>遍历器对象的next方法的运行逻辑如下。<ul><li>遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</li><li>下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。</li><li>如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</li><li>如果该函数没有return语句，则返回的对象的 value 属性值为 undefined。</li></ul></li><li>需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">123</span> + <span class="number">456</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值.</span></span><br></pre></td></tr></table></figure><h3 id="yield-表达式语法"><a href="#yield-表达式语法" class="headerlink" title="yield 表达式语法"></a>yield 表达式语法</h3><ul><li>yield表达式只能用在 Generator 函数里面，用在其他地方都会报错</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected number</span></span><br></pre></td></tr></table></figure><ul><li>yield表达式如果用在另一个表达式之中，必须放在圆括号里面</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + <span class="keyword">yield</span>); <span class="comment">// SyntaxError</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + <span class="keyword">yield</span> <span class="number">123</span>); <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + (<span class="keyword">yield</span>)); <span class="comment">// OK</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + (<span class="keyword">yield</span> <span class="number">123</span>)); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo(<span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>, <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>); <span class="comment">// OK</span></span><br><span class="line">  <span class="keyword">let</span> input = <span class="keyword">yield</span>; <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用法实例讲解"><a href="#用法实例讲解" class="headerlink" title="用法实例讲解"></a>用法实例讲解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flat = <span class="function"><span class="keyword">function</span>* (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* flat(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;  <span class="comment">// 错误用法</span></span><br><span class="line"><span class="comment">// forEach方法的参数是一个普通函数，但是在里面使用了yield表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一种修改方法是改用for循环。</span></span><br><span class="line"><span class="keyword">var</span> flat = <span class="function"><span class="keyword">function</span>* (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = a.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = a[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* flat(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> f <span class="keyword">of</span> flat(arr)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5, 6</span></span><br></pre></td></tr></table></figure><h3 id="yield表达式与return语句"><a href="#yield表达式与return语句" class="headerlink" title="yield表达式与return语句"></a>yield表达式与return语句</h3><ul><li>yield 表达式与return 语句既有相似之处，也有区别。  </li><li>相似之处在于，都能返回紧跟在语句后面的那个表达式的值。  </li><li>区别在于每次遇到<code>yield</code>，函数暂停执行，下一次再从该位置继续向后执行，而<code>return</code>语句不具备位置记忆的功能。 </li><li>一个函数里面，<strong>只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式</strong>。  </li><li>正常函数只能返回一个值，因为只能执行一次return；  </li><li>Generator 函数可以返回一系列的值，因为可以有任意多个<code>yield</code>。  </li><li>从另一个角度看，也可以说 Generator 生成了一系列的值。  </li></ul><h3 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a>next 方法的参数</h3><ul><li><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> reset = <span class="keyword">yield</span> i;</span><br><span class="line">    <span class="keyword">if</span>(reset) &#123; i = -<span class="number">1</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f();</span><br><span class="line"></span><br><span class="line">g.next() <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next(<span class="literal">true</span>) <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面代码先定义了一个可以无限运行的 Generator 函数f，</span></span><br><span class="line"><span class="comment">如果next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，</span></span><br><span class="line"><span class="comment">下一轮循环就会从-1开始递增。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。</li><li>通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。  </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = foo(<span class="number">5</span>);</span><br><span class="line">a.next() <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = foo(<span class="number">5</span>);</span><br><span class="line">b.next() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面代码中，第二次运行next方法的时候不带参数，导致 y 的值等于2 * undefined（即NaN），</span></span><br><span class="line"><span class="comment">除以 3 以后还是NaN，因此返回对象的value属性也等于NaN。</span></span><br><span class="line"><span class="comment">第三次运行Next方法的时候不带参数，所以z等于undefined，</span></span><br><span class="line"><span class="comment">返回对象的value属性等于5 + NaN + undefined，即NaN。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果向next方法提供参数，返回结果就完全不一样了。</span></span><br><span class="line"><span class="comment">上面代码第一次调用b的next方法时，返回x+1的值6；</span></span><br><span class="line"><span class="comment">第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；</span></span><br><span class="line"><span class="comment">第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，</span></span><br><span class="line"><span class="comment">这时x等于5，y等于24，所以return语句的值等于42。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。  </li></ul><h3 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h3><ul><li><ol><li>for…of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。  </li></ol></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码使用for...of循环，依次显示 5 个yield表达式的值。</span></span><br><span class="line"><span class="comment">// 这里需要注意，一旦next方法的返回对象的done属性为true，</span></span><br><span class="line"><span class="comment">// for...of循环就会中止，且不包含该返回对象，</span></span><br><span class="line"><span class="comment">// 所以上面代码的return语句返回的6，不包括在for...of循环之中。</span></span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* 2)利用`</span><span class="keyword">for</span>...of<span class="string">`循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用for...of循环，通过 Generator 函数为它加上这个接口，就可以用了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">objectEntries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> propKeys = <span class="built_in">Reflect</span>.ownKeys(obj);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [propKey, obj[propKey]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jane = &#123; <span class="attr">first</span>: <span class="string">&#x27;Jane&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;Doe&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> objectEntries(jane)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first: Jane</span></span><br><span class="line"><span class="comment">// last: Doe</span></span><br></pre></td></tr></table></figure><ul><li>3)加上遍历器接口的另一种写法是，将 Generator 函数加到对象的<code>Symbol.iterator</code>属性上面</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">objectEntries</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> propKeys = <span class="built_in">Object</span>.keys(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [propKey, <span class="built_in">this</span>[propKey]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jane = &#123; <span class="attr">first</span>: <span class="string">&#x27;Jane&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;Doe&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">jane[<span class="built_in">Symbol</span>.iterator] = objectEntries;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> jane) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first: Jane</span></span><br><span class="line"><span class="comment">// last: Doe</span></span><br></pre></td></tr></table></figure><ul><li>4)除了for…of循环以外，<code>扩展运算符（...）</code>、<code>解构赋值</code>和<code>Array.from</code>方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。  </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展运算符</span></span><br><span class="line">[...numbers()] <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from 方法</span></span><br><span class="line"><span class="built_in">Array</span>.from(numbers()) <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [x, y] = numbers();</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> numbers()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="Generator函数的异步操作"><a href="#Generator函数的异步操作" class="headerlink" title="Generator函数的异步操作"></a>Generator函数的异步操作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">asyncJob</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">yield</span> readFile(fileA);</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。<br>也就是说，yield命令是异步两个阶段的分界线。<br>协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p><p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。<br>整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。</p><h3 id="异步任务的封装"><a href="#异步任务的封装" class="headerlink" title="异步任务的封装"></a>异步任务的封装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">&#x27;node-fetch&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">&#x27;https://api.github.com/users/github&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</span><br><span class="line">  <span class="built_in">console</span>.log(result.bio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。</span></span><br><span class="line"><span class="comment">// 就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行上述代码</span></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> result = g.next();</span><br><span class="line"></span><br><span class="line">result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> data.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  g.next(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先执行 Generator 函数，获取遍历器对象，然后使用next方法（第二行），执行异步任务的第一阶段。</span></span><br><span class="line"><span class="comment">// 由于Fetch模块返回的是一个 Promise 对象，因此要用then方法调用下一个next方法。</span></span><br></pre></td></tr></table></figure><p>虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p><h2 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h2><p>学习指导：<a href="http://es6.ruanyifeng.com/#docs/async">阮一峰ES6 – async函数</a></p><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><ul><li>async 函数是什么？一句话，它就是 Generator 函数的语法糖</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generator 函数依次读取两个文件</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async函数，就是下面这样</span></span><br><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</span></span><br></pre></td></tr></table></figure><ul><li>async函数对 Generator 函数的改进，体现在以下四点：<ul><li><strong>内置执行器</strong> —— Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</li><li><strong>更好的语义</strong> —— async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</li><li><strong>更广的适用性</strong> —— co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</li><li><strong>返回值是 Promise</strong> —— async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。<strong>进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</strong>  </li></ul></li></ul><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p><ul><li>引入demo</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* async 表示异步调用 返回一个Promise对象 */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(resolve, ms);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;  <span class="comment">/* 与下边等价*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function timeout(ms) &#123;</span></span><br><span class="line"><span class="comment">//     return new Promise((resolve) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//       setTimeout(resolve, ms);</span></span><br><span class="line"><span class="comment">//     &#125;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> timeout(ms);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">&#x27;hello world&#x27;</span>, <span class="number">3000</span>)  <span class="comment">// 3000毫秒以后，输出hello world</span></span><br></pre></td></tr></table></figure><ul><li>async的表达方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="keyword">async</span> <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;&#125; &#125;;</span><br><span class="line">obj.foo().then(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class 的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cachePromise = caches.open(<span class="string">&#x27;avatars&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">getAvatar</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">await</span> <span class="built_in">this</span>.cachePromise;</span><br><span class="line">    <span class="keyword">return</span> cache.match(<span class="string">`/avatars/<span class="subst">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storage = <span class="keyword">new</span> Storage();</span><br><span class="line">storage.getAvatar(<span class="string">&#x27;jake&#x27;</span>).then(…);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="async-的语法"><a href="#async-的语法" class="headerlink" title="async 的语法"></a>async 的语法</h3><ul><li><p>返回Promise 对象</p><ul><li>async函数返回一个 Promise 对象。</li><li>async函数内部return语句返回的值，会成为then方法回调函数的参数。</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="comment">// 函数 f 内部return命令返回的值，会被then方法回调函数接收到。</span></span><br></pre></td></tr></table></figure></li><li><p>async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(</span><br><span class="line">  <span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v),</span><br><span class="line">  <span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// Error: 出错了</span></span><br></pre></td></tr></table></figure><ul><li><p>Promise 对象的状态变化</p><ul><li>async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。</li><li>也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">  <span class="keyword">let</span> html = <span class="keyword">await</span> response.text();</span><br><span class="line">  <span class="keyword">return</span> html.match(<span class="regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">getTitle(<span class="string">&#x27;https://tc39.github.io/ecma262/&#x27;</span>).then(<span class="built_in">console</span>.log)</span><br><span class="line"><span class="comment">// &quot;ECMAScript 2017 Language Specification&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。</span></span><br><span class="line"><span class="comment">// 只有这三个操作全部完成，才会执行then方法里面的 console.log。</span></span><br></pre></td></tr></table></figure></li><li><p>await 命令</p><ul><li>正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// await命令的参数是数值123，它被转成 Promise 对象，并立即resolve</span></span><br></pre></td></tr></table></figure><ul><li>await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// await 语句前面没有 return，但是 reject 方法的参数依然传入了 catch 方法的回调函数。</span></span><br><span class="line"><span class="comment">// 这里如果在await前面加上return，效果是一样的。</span></span><br></pre></td></tr></table></figure><ul><li>只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以将第一个await放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个await都会执行。</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><ul><li>另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><ul><li>第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在<code>try...catch</code>代码块中。</li><li>第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> getFoo();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> getBar();</span><br><span class="line"><span class="comment">// 上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。</span></span><br><span class="line"><span class="comment">// 这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br><span class="line"><span class="comment">// getFoo和getBar都是同时触发，这样就会缩短程序的执行时间</span></span><br></pre></td></tr></table></figure><ul><li>第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  docs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面代码会报错，因为await用在普通函数之中了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用for循环</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果确实希望多个请求并发执行，可以使用Promise.all方法。</span></span><br><span class="line"><span class="comment">// 当三个请求都会resolved时，下面两种写法效果相同。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.map(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.post(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises);</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用下面的写法</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.map(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.post(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    results.push(<span class="keyword">await</span> promise);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="async函数实现原理"><a href="#async函数实现原理" class="headerlink" title="async函数实现原理"></a>async函数实现原理</h3><ul><li>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。</span></span><br></pre></td></tr></table></figure><h3 id="场景再现"><a href="#场景再现" class="headerlink" title="场景再现"></a>场景再现</h3><ul><li>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">chainAnimationsAsync</span>(<span class="params">elem, animations</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="literal">null</span>;  <span class="comment">// 变量ret用来保存上一个动画的返回值</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">      ret = <span class="keyword">await</span> anim(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>依次远程读取一组 URL，然后按照读取的顺序输出结果。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 远程操作继发.只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">logInOrder</span>(<span class="params">urls</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> url <span class="keyword">of</span> urls) &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> response.text());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发发出远程请求</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">logInOrder</span>(<span class="params">urls</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 并发读取远程URL</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.map(<span class="keyword">async</span> url =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">    <span class="keyword">return</span> response.text();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> textPromise <span class="keyword">of</span> textPromises) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Generator-函数&quot;&gt;&lt;a href=&quot;#Generator-函数&quot; class=&quot;headerlink&quot; title=&quot;Generator 函数&quot;&gt;&lt;/a&gt;Generator 函数&lt;/h2&gt;&lt;p&gt;学习指导：&lt;a href=&quot;http://es6.ruany</summary>
      
    
    
    
    
    <category term="JavaScript | ES6" scheme="http://mengjie.com/tags/JavaScript-ES6/"/>
    
  </entry>
  
  <entry>
    <title>VS Code 使用小技巧</title>
    <link href="http://mengjie.com/2021/03/18/vscode-tips/"/>
    <id>http://mengjie.com/2021/03/18/vscode-tips/</id>
    <published>2021-03-18T07:49:01.000Z</published>
    <updated>2021-07-19T05:52:14.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VS-Code-使用小技巧"><a href="#VS-Code-使用小技巧" class="headerlink" title="VS Code 使用小技巧"></a>VS Code 使用小技巧</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>VSCode是微软推出的一款轻量编辑器，采取了和VS相同的UI界面，搭配合适的插件可以优化前端开发的体验。</p><p>布局：左侧是用于展示所要编辑的所有文件和文件夹的文件管理器，依次是<code>**资源管理器**</code>，<code>**搜索</code>，<code>GIT</code>，<code>调试</code>，<code>插件</code>**，右侧是打开文件的编辑区域，最多可同时打开三个编辑区域到侧边。</p><p>底栏：依次是**<code>Git Branch</code>，<code>error&amp;warning</code>，<code>编码格式</code>**等。</p><span id="more"></span><h3 id="常用插件（待补充）"><a href="#常用插件（待补充）" class="headerlink" title="常用插件（待补充）"></a><strong>常用插件（待补充）</strong></h3><ul><li>HTML Snippets：增强了zen-coding，增加了H5的自动补全，安装后每次打开自动启用(可能与其他插件冲突)。</li><li>Angular 1.x Snippets：增加了AngularJs 1在.html和.js中的代码补全，安装后每次打开自动启用。</li><li>Git Easy：增加了vscode中自带的git操作，安装后按F1调出控制台，输入git easy [options]完成git操作，代替git bash。</li><li>HTML CSS Support: 增加.html中css的代码补全，可以手动增加配置文件来增加外部css中的class补全。详情见插件说明。</li><li>VScode-icons： 美化VSCode的界面，在文件名前面显示小图标，安装后每次打开自动启用。</li><li>Git Blame：可以查看当前光标所在位置的Git Log，最近一次提交的人和时间，显示在左下角，安装后每次打开自动启用。</li><li>HTML CSS Class Completion：扫描项目中的所有css中的class名，在html中自动补全，安装后每次打开自动启用。<strong>注意：如果css过多容易卡死。</strong></li><li>Debugger for Chrome：方便js调试的插件，前端项目在Chrome中运行起来之后，可以直接在VSCode中打断点、查看输出、查看控制台，需要配置launch.json,详情见插件说明。</li><li>background：VSCode美化插件，修改界面背景，详情见插件说明。</li></ul><h3 id="常用快捷键（待补充）"><a href="#常用快捷键（待补充）" class="headerlink" title="常用快捷键（待补充）"></a><strong>常用快捷键（待补充）</strong></h3><h4 id="编辑器与窗口管理"><a href="#编辑器与窗口管理" class="headerlink" title="编辑器与窗口管理"></a><strong>编辑器与窗口管理</strong></h4><p>同时打开多个窗口（查看多个项目）</p><ul><li>打开一个新窗口： Ctrl+Shift+N</li><li>关闭窗口： Ctrl+Shift+W</li></ul><p>同时打开多个编辑器（查看多个文件）</p><ul><li>新建文件 Ctrl+N</li><li>历史打开文件之间切换 Ctrl+Tab，Alt+Left，Alt+Right</li><li>切出一个新的编辑器（最多3个）Ctrl+\，也可以按住Ctrl鼠标点击Explorer里的文件名</li><li>左中右3个编辑器的快捷键Ctrl+1 Ctrl+2 Ctrl+3</li><li><strong>3个编辑器之间循环切换 Ctrl+`</strong></li><li><strong>编辑器换位置，Ctrl+k然后按Left或Right</strong></li></ul><h4 id="代码编辑"><a href="#代码编辑" class="headerlink" title="代码编辑"></a><strong>代码编辑</strong></h4><p><strong>格式调整</strong></p><ul><li>代码行缩进Ctrl+[， Ctrl+]</li><li><strong>折叠打开代码块 Ctrl+Shift+[， Ctrl+Shift+]</strong></li><li>Ctrl+C Ctrl+V如果不选中，默认复制或剪切一整行</li><li>代码格式化：Shift+Alt+F，或Ctrl+Shift+P后输入format code</li><li>修剪空格Ctrl+Shift+X</li><li>上下移动一行： Alt+Up 或 Alt+Down</li><li><strong>向上向下复制一行： Shift+Alt+Up或Shift+Alt+Down</strong></li><li>在当前行下边插入一行Ctrl+Enter</li><li>在当前行上方插入一行Ctrl+Shift+Enter</li></ul><p><strong>光标相关</strong></p><ul><li>移动到行首：Home</li><li>移动到行尾：End</li><li>移动到文件结尾：Ctrl+End</li><li>移动到文件开头：Ctrl+Home</li><li>移动到后半个括号 Ctrl+Shift+]</li><li>选中当前行Ctrl+i（双击）</li><li>选择从光标到行尾Shift+End</li><li>选择从行首到光标处Shift+Home</li><li><strong>删除光标右侧的所有字Ctrl+Delete</strong></li><li>Shrink/expand selection： Shift+Alt+Left和Shift+Alt+Right</li><li>Multi-Cursor：可以连续选择多处，然后一起修改，Alt+Click添加cursor或者Ctrl+Alt+Down 或 Ctrl+Alt+Up</li><li>同时选中所有匹配的Ctrl+Shift+L</li><li>Ctrl+D下一个匹配的也被选中(被我自定义成删除当前行了，见下边Ctrl+Shift+K)</li><li><strong>回退上一个光标操作Ctrl+U</strong></li></ul><p><strong>重构代码</strong></p><ul><li>跳转到定义处：F12</li><li>定义处缩略图：只看一眼而不跳转过去Alt+F12</li><li><strong>列出所有的引用：Shift+F12</strong></li><li>同时修改本文件中所有匹配的：Ctrl+F12</li><li>重命名：比如要修改一个方法名，可以选中后按F2，输入新的名字，回车，会发现所有的文件都修改过了。</li><li>跳转到下一个Error或Warning：当有多个错误时可以按F8逐个跳转</li><li>查看diff 在explorer里选择文件右键 Set file to compare，然后需要对比的文件上右键选择Compare with ‘file_name_you_chose’.</li></ul><p><strong>查找替换</strong></p><ul><li>查找 Ctrl+F</li><li>查找替换 Ctrl+H</li><li>整个文件夹中查找 Ctrl+Shift+F</li></ul><p><strong>显示相关</strong></p><ul><li>全屏：F11</li><li>zoomIn/zoomOut：Ctrl + =/Ctrl + -</li><li>侧边栏显/隐：Ctrl+B</li><li><strong>预览markdown Ctrl+Shift+V</strong></li></ul><p><strong>其他</strong></p><ul><li>自动保存：File -&gt; AutoSave ，或者Ctrl+Shift+P，输入 auto</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;VS-Code-使用小技巧&quot;&gt;&lt;a href=&quot;#VS-Code-使用小技巧&quot; class=&quot;headerlink&quot; title=&quot;VS Code 使用小技巧&quot;&gt;&lt;/a&gt;VS Code 使用小技巧&lt;/h1&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;&lt;strong&gt;简介&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;VSCode是微软推出的一款轻量编辑器，采取了和VS相同的UI界面，搭配合适的插件可以优化前端开发的体验。&lt;/p&gt;
&lt;p&gt;布局：左侧是用于展示所要编辑的所有文件和文件夹的文件管理器，依次是&lt;code&gt;**资源管理器**&lt;/code&gt;，&lt;code&gt;**搜索&lt;/code&gt;，&lt;code&gt;GIT&lt;/code&gt;，&lt;code&gt;调试&lt;/code&gt;，&lt;code&gt;插件&lt;/code&gt;**，右侧是打开文件的编辑区域，最多可同时打开三个编辑区域到侧边。&lt;/p&gt;
&lt;p&gt;底栏：依次是**&lt;code&gt;Git Branch&lt;/code&gt;，&lt;code&gt;error&amp;amp;warning&lt;/code&gt;，&lt;code&gt;编码格式&lt;/code&gt;**等。&lt;/p&gt;</summary>
    
    
    
    
    <category term="VSCode" scheme="http://mengjie.com/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>vscode-sync-setting</title>
    <link href="http://mengjie.com/2021/03/18/vscode-sync-setting/"/>
    <id>http://mengjie.com/2021/03/18/vscode-sync-setting/</id>
    <published>2021-03-18T07:49:01.000Z</published>
    <updated>2021-07-19T05:52:19.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VSCode配置的同步设置，实现不同设备上的统一"><a href="#VSCode配置的同步设置，实现不同设备上的统一" class="headerlink" title="VSCode配置的同步设置，实现不同设备上的统一"></a>VSCode配置的同步设置，实现不同设备上的统一</h2><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ul><li>准备工作：电脑上需安装VSCode，拥有一个github账户。实现同步的功能主要依赖于VSCode插件<code>Settings Sync</code></li><li><strong>Setting Sync 可同步包含的所有扩展和完整的用户文件夹</strong> <ul><li>设置文件</li><li>快捷键设置文件</li><li>VSCode扩展设置</li><li>Launch File</li></ul></li></ul><span id="more"></span><h3 id="同步配置"><a href="#同步配置" class="headerlink" title="同步配置"></a>同步配置</h3><h4 id="安装-同步插件”Settings-Sync”"><a href="#安装-同步插件”Settings-Sync”" class="headerlink" title="安装 同步插件”Settings Sync”"></a>安装 同步插件”Settings Sync”</h4><h4 id="生成token"><a href="#生成token" class="headerlink" title="生成token"></a>生成token</h4><ul><li>登录Github账户设置，头像 —&gt; Settings 在左侧（最后一个） Developer settings —&gt; Personal access tokens；</li></ul><p><img src="https://i.loli.net/2018/05/26/5b096f4978275.png" alt="图片观看"></p><ul><li>点击按钮 Generate new token 新增一个token</li></ul><p><img src="https://i.loli.net/2018/05/26/5b096f6c74ee0.png" alt="流程一"></p><p><img src="https://i.loli.net/2018/05/26/5b096f835206e.png" alt="流程二"></p><p><img src="https://i.loli.net/2018/05/26/5b096f9a9b3de.png" alt="流程三"></p><p><strong>提示</strong>：记住生成的token值，最好找个笔记保存下来 。</p><h4 id="回到VSCode配置将token配置到本地"><a href="#回到VSCode配置将token配置到本地" class="headerlink" title="回到VSCode配置将token配置到本地"></a>回到VSCode配置将token配置到本地</h4><p>(Sync: Update / Uplaod Settings) <code>Shift + Alt + U</code> 在弹窗里输入你的token， 回车后会生成<code>syncSummary.txt</code>文件</p><p><img src="https://i.loli.net/2018/05/26/5b096fb7323ae.png" alt="img"></p><p>syncSummary.txt文件会存储VSCode的设置及所安装的插件列表</p><p>此外可以将自己的token分享到自己的团队里面去，这样团队可以共用一套设置。 </p><h4 id="同步与下载"><a href="#同步与下载" class="headerlink" title="同步与下载"></a>同步与下载</h4><ul><li><p>设置上同步下载设置</p><ul><li><code>Shift + Alt + U</code>，同步本地的配置更新到github；</li><li> <code>Shift + Alt + D</code> ，在弹窗里输入你的gist值，稍后片刻便可同步成功</li></ul></li><li><p>要重置同步设置，变更其它token</p><ul><li><code>Ctrl+P</code> 弹出输入&gt;sync，即可重新配置你的其它token来同步</li></ul></li></ul><h3 id="异端设置"><a href="#异端设置" class="headerlink" title="异端设置"></a>异端设置</h3><p><img src="https://i.loli.net/2018/05/26/5b096fcdb900c.png" alt="VSCode同步方案问题一"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;VSCode配置的同步设置，实现不同设备上的统一&quot;&gt;&lt;a href=&quot;#VSCode配置的同步设置，实现不同设备上的统一&quot; class=&quot;headerlink&quot; title=&quot;VSCode配置的同步设置，实现不同设备上的统一&quot;&gt;&lt;/a&gt;VSCode配置的同步设置，实现不同设备上的统一&lt;/h2&gt;&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;准备工作：电脑上需安装VSCode，拥有一个github账户。实现同步的功能主要依赖于VSCode插件&lt;code&gt;Settings Sync&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Setting Sync 可同步包含的所有扩展和完整的用户文件夹&lt;/strong&gt; &lt;ul&gt;
&lt;li&gt;设置文件&lt;/li&gt;
&lt;li&gt;快捷键设置文件&lt;/li&gt;
&lt;li&gt;VSCode扩展设置&lt;/li&gt;
&lt;li&gt;Launch File&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="VSCode" scheme="http://mengjie.com/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 入门初级指南</title>
    <link href="http://mengjie.com/2021/03/18/hexo%E5%85%A5%E9%97%A8/"/>
    <id>http://mengjie.com/2021/03/18/hexo%E5%85%A5%E9%97%A8/</id>
    <published>2021-03-18T04:07:33.000Z</published>
    <updated>2021-07-19T03:13:28.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><p>使用github pages服务搭建博客的好处有：</p><ol><li>全是静态文件，访问速度快；</li><li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li><li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li></ol><span id="more"></span><ol start="4"><li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li><li>博客内容可以轻松打包、转移、发布到其它平台；</li></ol><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><ul><li>打开命令行，在命令行中输入以下命令:<br><code>npm install -g hexo-cli</code> </li><li>安装Hexo的Git插件（如果不安装这个插件，会导致Hexo博客内容无法发布）<br><code>npm install hexo-deployer-git --save</code></li></ul><h2 id="本地搭建Hexo博客"><a href="#本地搭建Hexo博客" class="headerlink" title="本地搭建Hexo博客"></a>本地搭建Hexo博客</h2><ul><li><p>打开命令行，输入以下命令，用于创建Hexo博客目录。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 指的是用于创建Hexo博客的目录，例如 e:/hexo  hexo init &lt;folder&gt;</span><br><span class="line">hexo init e:/Hexo </span><br></pre></td></tr></table></figure></li><li><p>进入创建的项目，打开命令行，输入如下命令</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></li><li><p>初始化完毕后，可以在命令行中输入以下命令，启动本地Hexo博客程序。 </p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm server</span><br></pre></td></tr></table></figure></li><li><p>命令行出现如下信息，打开浏览器，访问 <a href="http://localhost:4000/">http://localhost:4000</a> 就可以访问本地的Hexo博客程序了。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure></li></ul><h2 id="发布博客到GitHub"><a href="#发布博客到GitHub" class="headerlink" title="发布博客到GitHub"></a><strong>发布博客到GitHub</strong></h2><ul><li>注册GitHub账户</li><li>创建GitHub工程</li><li>配置Hexo程序<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 进入Hexo的安装目录，打开_config.yml配置文件。</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line">title: 网站名称</span><br><span class="line">subtitle: 网站简介</span><br><span class="line">description:</span><br><span class="line">author: 作者</span><br><span class="line">language:</span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="line">url: 网站域名  (例如：https://mengjie0611.github.io/)</span><br><span class="line">root: /</span><br><span class="line">permalink: :category/:title.html</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: http://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: GitHub新建工程的地址（例如 git@github.com:mengjie0611/mengjie0611.github.io.git）</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li></ul><h2 id="发布Hexo到GitHub"><a href="#发布Hexo到GitHub" class="headerlink" title="发布Hexo到GitHub"></a>发布Hexo到GitHub</h2><ul><li>在Hexo的安装目录中，鼠标右键选择”Git Bash Here”选项。</li><li>在Git命令行中，输入以下命令。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 生成hexo本地目录结构</span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line">// 将hexo本地目录上传至GitCafe</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;写在前边&quot;&gt;&lt;a href=&quot;#写在前边&quot; class=&quot;headerlink&quot; title=&quot;写在前边&quot;&gt;&lt;/a&gt;写在前边&lt;/h2&gt;&lt;p&gt;使用github pages服务搭建博客的好处有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全是静态文件，访问速度快；&lt;/li&gt;
&lt;li&gt;免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；&lt;/li&gt;
&lt;li&gt;可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Hexo" scheme="http://mengjie.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Koa2入门小基础</title>
    <link href="http://mengjie.com/2021/03/18/Koa2%E5%85%A5%E9%97%A8%E5%B0%8F%E5%9F%BA%E7%A1%80/"/>
    <id>http://mengjie.com/2021/03/18/Koa2%E5%85%A5%E9%97%A8%E5%B0%8F%E5%9F%BA%E7%A1%80/</id>
    <published>2021-03-18T00:00:00.000Z</published>
    <updated>2021-07-19T05:53:26.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Koa2入门小基础"><a href="#Koa2入门小基础" class="headerlink" title="Koa2入门小基础"></a>Koa2入门小基础</h1><p>学习指导：<a href="http://www.jspang.com/posts/2017/11/13/koa2.html">挑战全栈 Koa2免费视频教程 (共13集)</a></p><p>Koa2是现在最流行的基于Node.js平台的web开发框架，它很小，但扩展性很强。Koa给人一种干净利落的感觉，体积小、编程方式干净。</p><blockquote><p>使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。一个Koa应用就是一个对象，包含了一个middleware数组，这个数组由一组Generator函数组成。这些函数负责对HTTP请求进行各种加工，比如生成缓存、指定代理、请求重定向等等。这些中间件函数基于 request 请求以一个类似于栈的结构组成并依次执行。</p></blockquote><h2 id="第01节：Koa开发环境搭建"><a href="#第01节：Koa开发环境搭建" class="headerlink" title="第01节：Koa开发环境搭建"></a>第01节：Koa开发环境搭建</h2><p>作Koa2的开发，它要求Node.js版本高于V7.6。</p><blockquote><p>::: warning 注意事项<br>请确保你的 Node.js 版本 &gt;= 7.6。<br>:::</p></blockquote><h3 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> code  //进入code文件夹</span><br><span class="line">mkdir koa2-demo //创建koa2-demo文件夹</span><br><span class="line"><span class="built_in">cd</span> koa2-demo  //进入koa2-demo文件夹</span><br><span class="line"></span><br><span class="line">npm init -y // 初始化生产package.json 文件</span><br><span class="line">npm install --save koa // 安装koa</span><br></pre></td></tr></table></figure><h3 id="与君初相识"><a href="#与君初相识" class="headerlink" title="与君初相识"></a>与君初相识</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根目录下创建 index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;Hello Koa2&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;[demo] start-quick is starting at port 3000&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行 node index.js</span></span><br><span class="line"><span class="comment">// 浏览器中输入：http://127.0.0.1:3000 就可以看到结果了</span></span><br></pre></td></tr></table></figure><h2 id="第02节：async-await的使用方法"><a href="#第02节：async-await的使用方法" class="headerlink" title="第02节：async/await的使用方法"></a>第02节：async/await的使用方法</h2><h3 id="什么是async和await"><a href="#什么是async和await" class="headerlink" title="什么是async和await"></a>什么是async和await</h3><p>async是异步的简写，而await可以堪称async wait的简写。</p><p>明白了两个单词，就很好理解了async是声明一个方法是异步的，await是等待异步方法完成。</p><p>注意的是await必须在async方法中才可以使用因为await访问本身就会造成程序停止堵塞，所以必须在异步方法中才可以使用。</p><ul><li><p><strong>async到底起什么作用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async是让方法变成异步，这个很好理解，关键是他的返回值是什么？我们得到后如何处理？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./demo01.js</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello Async&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = testAsync()</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// Promise &#123; &#x27;Hello Async&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出了Promise &#123; ‘Hello Async’ &#125;，这时候会发现它返回的是Promise</span></span><br></pre></td></tr></table></figure></li><li><p><strong>await在等什么？</strong></p><p>await一般在等待async方法执行完毕，但是其实await等待的只是一个表达式，这个表达式在官方文档里说的是Promise对象，可是它也可以接受普通值。</p><p><strong>await必须在async方法中才可以使用</strong></p><p><strong>await接收Promise对象，也可以接收普通值</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./demo02.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSomething</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;something&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Hello Async&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res1 = <span class="keyword">await</span> getSomething()</span><br><span class="line">    <span class="keyword">const</span> res2 = <span class="keyword">await</span> testAsync()</span><br><span class="line">    <span class="built_in">console</span>.log(res1, res2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line">test()  <span class="comment">// something Hello Async</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="async-await同时使用"><a href="#async-await同时使用" class="headerlink" title="async/await同时使用"></a>async/await同时使用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./demo03.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">&#x27;long_time_value&#x27;</span>)</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> takeLongTime()</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待2秒钟， 输出 long_time_value</span></span><br></pre></td></tr></table></figure><h2 id="第03节：Get请求的接收"><a href="#第03节：Get请求的接收" class="headerlink" title="第03节：Get请求的接收"></a>第03节：Get请求的接收</h2><ul><li><p>在koa2中GET请求通过request接收，但是接受的方法有两种：query和querystring。</p><ul><li>query：返回的是格式化好的参数对象。</li><li>querystring：返回的是请求字符串。</li></ul></li><li><p>从 <code>ctx.request</code> 中获取Get请求</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  在koa2中GET请求通过request接收，但是接受的方法有两种：query和querystring。</span></span><br><span class="line"><span class="comment"> *  query：返回的是格式化好的参数对象。</span></span><br><span class="line"><span class="comment"> *  querystring：返回的是请求字符串。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./ get_demo.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 上下文得到url对象</span></span><br><span class="line">    <span class="keyword">let</span> url = ctx.url</span><br><span class="line">    <span class="keyword">let</span> request = ctx.request</span><br><span class="line">    <span class="keyword">let</span> req_query = request.query</span><br><span class="line">    <span class="keyword">let</span> req_querystring = request.querystring</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">        url,</span><br><span class="line">        req_query,</span><br><span class="line">        req_querystring</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动一切正常可在浏览器中使用http://127.0.0.1:3000?user=jspang&amp;age=18来进行访问</span></span><br><span class="line"><span class="comment">// &#123;&quot;url&quot;:&quot;/?user=jspang&amp;age=18&quot;,&quot;req_query&quot;:&#123;&quot;user&quot;:&quot;jspang&quot;,&quot;age&quot;:&quot;18&quot;&#125;,&quot;req_querystring&quot;:&quot;user=jspang&amp;age=18&quot;&#125;</span></span><br><span class="line"><span class="comment">// query是一个对象，而querystring就是一个普通的字符串。</span></span><br></pre></td></tr></table></figure></li><li><p>从<code>ctx</code>中得到GET请求。<code>ctx</code>中也分为query和querystring</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从ctx中得到GET请求。ctx中也分为query和querystring</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    <span class="comment">//从request中获取GET请求</span></span><br><span class="line">    <span class="comment">// 上下文得到url对象</span></span><br><span class="line">    <span class="keyword">let</span> url = ctx.url</span><br><span class="line">    <span class="keyword">let</span> request = ctx.request</span><br><span class="line">    <span class="keyword">let</span> req_query = request.query</span><br><span class="line">    <span class="keyword">let</span> req_querystring = request.querystring</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从上下文中直接获取</span></span><br><span class="line">    <span class="keyword">let</span> ctx_query = ctx.query</span><br><span class="line">    <span class="keyword">let</span> ctx_querystring = ctx.querystring</span><br><span class="line"></span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">        url,</span><br><span class="line">        req_query,</span><br><span class="line">        req_querystring,</span><br><span class="line">        ctx_query,</span><br><span class="line">        ctx_querystring</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> // 20190813114559</span></span><br><span class="line"><span class="comment">// http://127.0.0.1:3000/?user=jspang&amp;age=18</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;url&quot;: &quot;/?user=jspang&amp;age=18&quot;,</span></span><br><span class="line"><span class="comment">  &quot;req_query&quot;: &#123;</span></span><br><span class="line"><span class="comment">    &quot;user&quot;: &quot;jspang&quot;,</span></span><br><span class="line"><span class="comment">    &quot;age&quot;: &quot;18&quot;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  &quot;req_querystring&quot;: &quot;user=jspang&amp;age=18&quot;,</span></span><br><span class="line"><span class="comment">  &quot;ctx_query&quot;: &#123;</span></span><br><span class="line"><span class="comment">    &quot;user&quot;: &quot;jspang&quot;,</span></span><br><span class="line"><span class="comment">    &quot;age&quot;: &quot;18&quot;</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  &quot;ctx_querystring&quot;: &quot;user=jspang&amp;age=18&quot;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure></li><li><p>总结：获得GET请求的方式有两种，一种是从request中获得，一种是一直从上下文中获得。</p></li><li><p>获得的格式也有两种：query和querystring。</p></li></ul><h2 id="第04节：POST请求如何接收（1）"><a href="#第04节：POST请求如何接收（1）" class="headerlink" title="第04节：POST请求如何接收（1）"></a>第04节：POST请求如何接收（1）</h2><ul><li><p>对于POST请求的处理，Koa2没有封装方便的获取参数的方法，需要通过解析上下文context中的原生node.js请求对象req来获取。</p></li><li><p><strong>获取Post请求的步骤：</strong></p></li></ul><ol><li>解析上下文ctx中的原生nodex.js对象req。</li><li>将POST表单数据解析成query string-字符串.(例如:user=jspang&amp;age=18)</li><li>将字符串转换成JSON格式。</li></ol><ul><li><strong>ctx.request和ctx.req的区别</strong></li></ul><ol><li>ctx.request: 是Koa2中context经过封装的请求对象，它用起来更直观和简单。</li><li>ctx.req: 是context提供的node.js原生HTTP请求对象。这个虽然不那么直观，但是可以得到更多的内容，适合我们深度编程。</li></ol><ul><li><p><strong>ctx.method 得到请求类型</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ctx.method 得到请求类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Koa2中提供了ctx.method属性，可以轻松的得到请求的类型，</span></span><br><span class="line"><span class="comment">// 然后根据请求类型编写不同的相应方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./post_demo01.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 当请求是GET请求，显示表单让用户填写</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.url === <span class="string">&#x27;/&#x27;</span> &amp;&amp; ctx.method === <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;h1&gt;Koa2 request post demo&lt;/h1&gt;</span></span><br><span class="line"><span class="string">      &lt;form method=&#x27;POST&#x27; action=&#x27;/&#x27;&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;userName&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;input name=&quot;userName&quot;/&gt; &lt;br/&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;age&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;input name=&quot;age&quot;/&gt; &lt;br/&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;webSite&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;input name=&#x27;webSite&#x27;/&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="string">        &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;/form&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">    ctx.body = html</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctx.url === <span class="string">&#x27;/&#x27;</span> &amp;&amp; ctx.method === <span class="string">&#x27;POST&#x27;</span>) &#123;  <span class="comment">// 当请求时POST请求时</span></span><br><span class="line">    ctx.body = <span class="string">&#x27;接收到请求&#x27;</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 其他请求显示404报错</span></span><br><span class="line">    ctx.body = <span class="string">&#x27;&lt;h1&gt;404 page!&lt;/h1&gt;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">浏览器中输入http://127.0.0.1:3000进行查看，</span></span><br><span class="line"><span class="comment">  第一次进入时给我们展现的是一个表单页面，</span></span><br><span class="line"><span class="comment">  我们点击提交后可以看到服务器接收到了我们的信息，但我们并没有做出任何处理。</span></span><br><span class="line"><span class="comment">  当我们下输入一个地址时，它会提示404错误。</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// **总结：**从理论上讲解了如何获取POST请求参数</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="第05节：POST请求如何接收（2）"><a href="#第05节：POST请求如何接收（2）" class="headerlink" title="第05节：POST请求如何接收（2）"></a>第05节：POST请求如何接收（2）</h2><ul><li><p><strong>解析Node原生POST参数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./post_demo2.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析Node原生POST参数</span></span><br><span class="line"><span class="comment">// 声明一个方法，然后用Promise对象进行解析。这里我们使用了ctx.req.on来接收事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parsePostData</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> postdata = <span class="string">&#x27;&#x27;</span></span><br><span class="line">      ctx.req.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">        postdata += data</span><br><span class="line">      &#125;)</span><br><span class="line">      ctx.req.addListener(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        resolve(postdata)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span>&#123;</span><br><span class="line">      reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改在上节课接收POST请求的处理方法里，修改代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ctx.body = &#x27;接收到POST请求&#x27;</span></span><br><span class="line"><span class="keyword">let</span> postdata = <span class="keyword">await</span> parsePostData(ctx)  <span class="comment">// userName=jspang&amp;age=123&amp;webSite=www.douban.com</span></span><br><span class="line">ctx.body = postdata</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面就输出刚才填的表单  userName=jspang&amp;age=123&amp;webSite=www.douban.com</span></span><br></pre></td></tr></table></figure></li><li><p><strong>POST字符串解析JSON对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./post_demo2.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// POST字符串解析JSON对象</span></span><br><span class="line"><span class="comment">// 字符串封装JSON兑现对象的方法</span></span><br><span class="line"><span class="comment">// userName=jspang&amp;age=123&amp;webSite=www.douban.com</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseQueryStr</span>(<span class="params">queryStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> queryData = &#123;&#125;</span><br><span class="line">  <span class="comment">// split() 方法使用指定的分隔符字符串将一个String对象分割成字符串数组，</span></span><br><span class="line">  <span class="comment">// 以将字符串分隔为子字符串，以确定每个拆分的位置。 </span></span><br><span class="line">  <span class="keyword">let</span> queryStrList = queryStr.split(<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">  <span class="comment">// console.log(queryStrList)</span></span><br><span class="line">  <span class="comment">// entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> [index, queryStrItem] <span class="keyword">of</span> queryStrList.entries()) &#123;</span><br><span class="line">    <span class="keyword">let</span> itemList = queryStrItem.split(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">    <span class="comment">// console.log(itemList)</span></span><br><span class="line">    queryData[itemList[<span class="number">0</span>]] = itemList[<span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> queryData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在上述解析Node原生POST参数中修改</span></span><br><span class="line">ctx.req.addListener(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// resolve(postdata)</span></span><br><span class="line">    <span class="keyword">let</span> parseData = parseQueryStr(postdata)</span><br><span class="line">    resolve(parseData)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">使用for…of 循环</span></span><br><span class="line"><span class="comment">var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];</span></span><br><span class="line"><span class="comment">var iterator = arr.entries();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">for (let e of iterator) &#123;</span></span><br><span class="line"><span class="comment">  console.log(e);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// [0, &quot;a&quot;] </span></span><br><span class="line"><span class="comment">// [1, &quot;b&quot;] </span></span><br><span class="line"><span class="comment">// [2, &quot;c&quot;]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// node运行，浏览器http://127.0.0.1:3000，先填写表单，然后页面就会返回</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;userName&quot;: &quot;jspang&quot;,</span></span><br><span class="line"><span class="comment">  &quot;age&quot;: &quot;123&quot;,</span></span><br><span class="line"><span class="comment">  &quot;webSite&quot;: &quot;www.douban.com&quot;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>完整代码见<code>post_demo2.js</code></p></li></ul><h2 id="扩展-Array-entries方法精讲"><a href="#扩展-Array-entries方法精讲" class="headerlink" title="[扩展]Array/entries方法精讲"></a>[扩展]Array/entries方法精讲</h2><ul><li><p>参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/entries">Array/entries</a></p></li><li><p><code>**entries()**</code> 方法返回一个新的<strong>Array Iterator</strong>对象，该对象包含数组中每个索引的键/值对。</p></li><li><blockquote><p>arr.entries()</p></blockquote><p>返回值是 一个新的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array"><code>Array</code></a> 迭代器对象。<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-createarrayiterator">Array Iterator</a>是对象，它的原型（<strong>proto</strong>:Array Iterator）上有一个<a href="http://www.ecma-international.org/ecma-262/6.0/#sec-%arrayiteratorprototype%.next">next</a>方法，可用用于遍历迭代器取得原数组的[key,value]。</p></li><li><p><code>Array Iterator</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = arr.entries();</span><br><span class="line"><span class="built_in">console</span>.log(iterator);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Array Iterator &#123;&#125;</span></span><br><span class="line"><span class="comment">         __proto__:Array Iterator</span></span><br><span class="line"><span class="comment">         next:ƒ next()</span></span><br><span class="line"><span class="comment">         Symbol(Symbol.toStringTag):&quot;Array Iterator&quot;</span></span><br><span class="line"><span class="comment">         __proto__:Object</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><code>iterator.next()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]; </span><br><span class="line"><span class="keyword">var</span> iterator = arr.entries();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*&#123;value: Array(2), done: false&#125;</span></span><br><span class="line"><span class="comment">          done:false</span></span><br><span class="line"><span class="comment">          value:(2) [0, &quot;a&quot;]</span></span><br><span class="line"><span class="comment">           __proto__: Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// iterator.next()返回一个对象，对于有元素的数组，</span></span><br><span class="line"><span class="comment">// 是next&#123; value: Array(2), done: false &#125;；</span></span><br><span class="line"><span class="comment">// next.done 用于指示迭代器是否完成：在每次迭代时进行更新而且都是false，</span></span><br><span class="line"><span class="comment">// 直到迭代器结束done才是true。</span></span><br><span class="line"><span class="comment">// next.value是一个[&quot;key&quot;,&quot;value&quot;]的数组，是返回的迭代器中的元素值。</span></span><br></pre></td></tr></table></figure></li><li><p><code>iterator.next方法运行</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> iter = arr.entries();</span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// for(var i=0; i&lt; arr.length; i++)&#123;   // 实际使用的是这个 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt; arr.length+<span class="number">1</span>; i++)&#123;    <span class="comment">// 注意，是length+1，比数组的长度大</span></span><br><span class="line">    <span class="keyword">var</span> tem = iter.next();             <span class="comment">// 每次迭代时更新next</span></span><br><span class="line">    <span class="built_in">console</span>.log(tem.done);             <span class="comment">// 这里可以看到更新后的done都是false</span></span><br><span class="line">    <span class="keyword">if</span>(tem.done !== <span class="literal">true</span>)&#123;             <span class="comment">// 遍历迭代器结束done才是true</span></span><br><span class="line">        <span class="built_in">console</span>.log(tem.value);</span><br><span class="line">        a[i]=tem.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);                         <span class="comment">// 遍历完毕，输出next.value的数组</span></span><br></pre></td></tr></table></figure></li><li><p><code>二维数组按行排序</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortArr</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> goNext = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">var</span> entries = arr.entries();</span><br><span class="line">    <span class="keyword">while</span> (goNext) &#123;</span><br><span class="line">        <span class="keyword">var</span> result = entries.next();</span><br><span class="line">        <span class="keyword">if</span> (result.done !== <span class="literal">true</span>) &#123;</span><br><span class="line">            result.value[<span class="number">1</span>].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br><span class="line">            goNext = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            goNext = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [[<span class="number">1</span>,<span class="number">34</span>],[<span class="number">456</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">44</span>,<span class="number">234</span>],[<span class="number">4567</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">34</span>,<span class="number">78</span>,<span class="number">23</span>,<span class="number">1</span>]];</span><br><span class="line">sortArr(arr);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*(4) [Array(2), Array(5), Array(5), Array(4)]</span></span><br><span class="line"><span class="comment">    0:(2) [1, 34]</span></span><br><span class="line"><span class="comment">    1:(5) [2, 3, 44, 234, 456]</span></span><br><span class="line"><span class="comment">    2:(5) [1, 4, 5, 6, 4567]</span></span><br><span class="line"><span class="comment">    3:(4) [1, 23, 34, 78]</span></span><br><span class="line"><span class="comment">    length:4</span></span><br><span class="line"><span class="comment">    __proto__:Array(0)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><code>使用for…of 循环</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = arr.entries();</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> iterator) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [0, &quot;a&quot;]</span></span><br><span class="line"><span class="comment">// [1, &quot;b&quot;]</span></span><br><span class="line"><span class="comment">// [2, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="第06节：koa-bodyparser中间件"><a href="#第06节：koa-bodyparser中间件" class="headerlink" title="第06节：koa-bodyparser中间件"></a>第06节：koa-bodyparser中间件</h2><p>对于POST请求的处理，koa-bodyparser中间件可以把koa2上下文的formData数据解析到ctx.request.body中。</p><ul><li><p><strong>安装中间件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用npm进行安装，需要注意的是我们这里要用–save，因为它在生产环境中需要使用。</span></span><br><span class="line"></span><br><span class="line">npm install --save koa-bodyparser@3</span><br></pre></td></tr></table></figure></li><li><p><strong>引入使用</strong></p><p>安装完成后，需要在代码中引入并使用。我们在代码顶部用require进行引入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>)</span><br></pre></td></tr></table></figure><p>然后进行使用，如果不使用是没办法调用的，使用代码如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(bodyParser())</span><br></pre></td></tr></table></figure><p>在代码中使用后，直接可以用<code>ctx.request.body</code>进行获取POST请求参数，中间件自动给我们作了解析。</p></li><li><p>用例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Post请求解析中间件   koa-bodyparser</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./bodyparser_demo.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;koa-bodyparser&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line">app.use(bodyParser())</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 当请求是GET请求，显示表单让用户填写</span></span><br><span class="line">  <span class="keyword">if</span> (ctx.url === <span class="string">&#x27;/&#x27;</span> &amp;&amp; ctx.method === <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> html = <span class="string">`</span></span><br><span class="line"><span class="string">      &lt;h1&gt;Koa2 request post demo&lt;/h1&gt;</span></span><br><span class="line"><span class="string">      &lt;form method=&#x27;POST&#x27; action=&#x27;/&#x27;&gt;</span></span><br><span class="line"><span class="string">      &lt;p&gt;userName&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;input name=&quot;userName&quot;/&gt; &lt;br/&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;age&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;input name=&quot;age&quot;/&gt; &lt;br/&gt;</span></span><br><span class="line"><span class="string">        &lt;p&gt;webSite&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;input name=&#x27;webSite&#x27;/&gt;&lt;br/&gt;</span></span><br><span class="line"><span class="string">        &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;</span></span><br><span class="line"><span class="string">      &lt;/form&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">    ctx.body = html</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ctx.url === <span class="string">&#x27;/&#x27;</span> &amp;&amp; ctx.method === <span class="string">&#x27;POST&#x27;</span>) &#123;  <span class="comment">// 当请求时POST请求时</span></span><br><span class="line">    <span class="comment">// ctx.body = &#x27;接收到POST请求&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> postData= ctx.request.body</span><br><span class="line">    ctx.body = postData</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 其他请求显示404报错</span></span><br><span class="line">    ctx.body = <span class="string">&#x27;&lt;h1&gt;404 page!&lt;/h1&gt;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="第07节：Koa2原生路由实现"><a href="#第07节：Koa2原生路由实现" class="headerlink" title="第07节：Koa2原生路由实现"></a>第07节：Koa2原生路由实现</h2><ul><li><p><code>ctx.request.url</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ctx.request.url</span></span><br><span class="line"><span class="comment">// 地址栏输入的路径，然后根据路径的不同进行跳转</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line">app.use(<span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> url = ctx.request.url</span><br><span class="line">  ctx.body = url</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问http://127.0.0.1:3000/jspang/18 页面会输出/jspang/18</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Koa2原生路由实现</strong></p><p>原生路由的实现需要引入fs模块来读取文件。然后再根据路由的路径去读取，最后返回给页面，进行渲染。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Koa2原生路由实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ctx.request.url</span></span><br><span class="line"><span class="comment">// 地址栏输入的路径，然后根据路径的不同进行跳转</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">page</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> pageUrl = <span class="string">`./page/<span class="subst">$&#123;page&#125;</span>`</span></span><br><span class="line">    <span class="comment">// 获取文件地址 读取文件</span></span><br><span class="line">    fs.readFile(pageUrl, <span class="string">&quot;binary&quot;</span>, <span class="function">(<span class="params">error, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        reject(error)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> page = <span class="string">&#x27;404.html&#x27;</span></span><br><span class="line">  <span class="keyword">switch</span> (url) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">      page = <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/index&#x27;</span>:</span><br><span class="line">      page = <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/todo&#x27;</span>:</span><br><span class="line">      page = <span class="string">&#x27;todo.html&#x27;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/404&#x27;</span>:</span><br><span class="line">      page = <span class="string">&#x27;404.html&#x27;</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> html = <span class="keyword">await</span> render(page)</span><br><span class="line">  <span class="keyword">return</span> html</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> url = ctx.request.url</span><br><span class="line">  <span class="keyword">let</span> html = <span class="keyword">await</span> route(url)</span><br><span class="line">  ctx.body = html</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="第08节：Koa-router中间件（1）入门"><a href="#第08节：Koa-router中间件（1）入门" class="headerlink" title="第08节：Koa-router中间件（1）入门"></a>第08节：Koa-router中间件（1）入门</h2><p>安装koa-router中间件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装koa-router中间件</span></span><br><span class="line"></span><br><span class="line">npm install --save koa-router</span><br></pre></td></tr></table></figure><p>基础案例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Koa-router</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./koa-router1.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router()</span><br><span class="line"></span><br><span class="line">router</span><br><span class="line">  .get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;Hello Koa-router&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .get(<span class="string">&#x27;/todo&#x27;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;   <span class="comment">// 路由多页面配置</span></span><br><span class="line">    ctx.body = <span class="string">&#x27;Todo page!&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载路由</span></span><br><span class="line">app.use(router.routes())</span><br><span class="line">  .use(router.allowedMethods())</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="第09节：Koa-router中间件（2）层级"><a href="#第09节：Koa-router中间件（2）层级" class="headerlink" title="第09节：Koa-router中间件（2）层级"></a>第09节：Koa-router中间件（2）层级</h2><ul><li><p><strong>设置前缀</strong></p><p>有时候我们想把所有的路径前面都再加入一个级别，比如原来我们访问的路径是<code>http://127.0.0.1:3000/todo</code>，现在我们希望在所有的路径前面都加上一个jspang层级，把路径变成<code>http://127.0.0.1:3000/jspang/todo.</code>这时候就可以使用层级来完成这个功能。路由在创建的时候是可以指定一个前缀的，这个前缀会被至于路由的最顶层，也就是说，这个路由的所有请求都是相对于这个前缀的.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    <span class="attr">prefix</span>:<span class="string">&#x27;/jspang&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>设置层级</p><p>设置前缀一般都是全局的，并不能实现路由的层级，如果你想为单个页面设置层级，也是很简单的。只要在use时使用路径就可以了。</p><p>例如这种写法装载路由层级，这里的router相当于父级：<code>router.use(‘/page’, page.routes(), page.allowedMethods())</code>。</p><p>通过这种写法的好处是并不是全局的，我们可以给不同的路由加层级。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Koa-router 层级</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./koa-router2.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="comment">// const router = new Router(&#123;</span></span><br><span class="line"><span class="comment">//   // prefix: &#x27;/jspang&#x27;  // 设置前缀</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置路由层级</span></span><br><span class="line"><span class="keyword">let</span> home = <span class="keyword">new</span> Router()</span><br><span class="line">home</span><br><span class="line">  .get(<span class="string">&#x27;/jspang&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;Home jspang&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .get(<span class="string">&#x27;/todo&#x27;</span>, <span class="keyword">async</span> (ctx, next) =&gt; &#123;   <span class="comment">// 路由多页面配置</span></span><br><span class="line">    ctx.body = <span class="string">&#x27;Home Todo&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> page = <span class="keyword">new</span> Router()</span><br><span class="line">page</span><br><span class="line">  .get(<span class="string">&#x27;/jspang&#x27;</span>,<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;  <span class="comment">// async 异步不异步都可以</span></span><br><span class="line">    ctx.body = <span class="string">&#x27;Page jspang&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .get(<span class="string">&#x27;/todo&#x27;</span>,<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;   <span class="comment">// 路由多页面配置</span></span><br><span class="line">    ctx.body = <span class="string">&#x27;Page Todo&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装载所有子路由  router.use(‘/page’, page.routes(), page.allowedMethods())</span></span><br><span class="line"><span class="comment">// 设置父路由</span></span><br><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> Router()</span><br><span class="line">router.use(<span class="string">&#x27;/home&#x27;</span>, home.routes(), home.allowedMethods())</span><br><span class="line">router.use(<span class="string">&#x27;/page&#x27;</span>, page.routes(), page.allowedMethods())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载路由中间件</span></span><br><span class="line">app.use(router.routes())</span><br><span class="line">  .use(router.allowedMethods())</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="第10节：Koa-router中间件（3）参数"><a href="#第10节：Koa-router中间件（3）参数" class="headerlink" title="第10节：Koa-router中间件（3）参数"></a>第10节：Koa-router中间件（3）参数</h2><ul><li><p>获取传递参数 <code>ctx.query来进行接收</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Koa-router 参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./koa-router3.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&#x27;koa-router&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router()</span><br><span class="line"></span><br><span class="line">router</span><br><span class="line">  .get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取 get 请求参数</span></span><br><span class="line">    ctx.body = ctx.query</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂载路由中间件</span></span><br><span class="line">app.use(router.routes())</span><br><span class="line">  .use(router.allowedMethods())</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 地址栏输出 http://127.0.0.1:3000/?user=jspang&amp;age=18</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  &quot;user&quot;: &quot;jspang&quot;,</span></span><br><span class="line"><span class="comment">  &quot;age&quot;: &quot;18&quot;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="第11节：Koa2中使用cookie"><a href="#第11节：Koa2中使用cookie" class="headerlink" title="第11节：Koa2中使用cookie"></a>第11节：Koa2中使用cookie</h2><ul><li><p><code>ctx.cookies.get(name,[optins])</code>: 读取上下文请求中的cookie。</p></li><li><p><code>ctx.cookies.set(name,value,[options])</code>：在上下文中写入cookie</p></li><li><p><strong>写入<code>Cookies</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.cookies.set(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jspang&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>Cookie选项</strong></p><ul><li>比如我们要存储用户名，保留用户登录状态时，你可以选择7天内不用登录，也可以选择30天内不用登录。这就需要在写入是配置一些选项：</li><li><code>domain</code>：写入cookie所在的域名</li><li><code>path</code>：写入cookie所在的路径</li><li><code>maxAge</code>：Cookie最大有效时长</li><li><code>expires</code>：cookie失效时间</li><li><code>httpOnly</code>:是否只用http请求中获得</li><li><code>overwirte</code>：是否允许重写</li></ul></li><li><p><strong>读取<code>cookies</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctx.cookies.get(<span class="string">&#x27;name&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="第12节：Koa2的模板初识（ejs）"><a href="#第12节：Koa2的模板初识（ejs）" class="headerlink" title="第12节：Koa2的模板初识（ejs）"></a>第12节：Koa2的模板初识（ejs）</h2><p>开发中不可能把所有的html代码全部卸载JS里，这显然不现实，也没办法完成大型web开发。必须借用模板机制来帮助我们开发，这节课我们就简单了解一下Koa2的模板机制，koa2的目标机制要依靠中间件来完成开发。</p><ul><li><p><strong>安装中间件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装中间件</span></span><br><span class="line"></span><br><span class="line">npm install --save koa-views</span><br></pre></td></tr></table></figure></li><li><p><strong>安装ejs模板引擎</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装ejs模板引擎</span></span><br><span class="line"></span><br><span class="line">npm install --save ejs</span><br></pre></td></tr></table></figure></li><li><p><strong>编写模板</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了模板统一管理，我们新建一个view的文件夹，并在它下面新建index.ejs文件。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ./views/index.ejs</span></span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;%= title%&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;EJS Welcome to &lt;%= title %&gt;&lt;/p&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>编写Koa文件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ejs模板</span></span><br><span class="line"><span class="comment">// ./ejs_demo.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> views = <span class="built_in">require</span>(<span class="string">&#x27;koa-views&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模板引擎</span></span><br><span class="line">app.use(views(path.join(__dirname, <span class="string">&#x27;./views&#x27;</span>), &#123;</span><br><span class="line">  <span class="attr">extension</span>: <span class="string">&#x27;ejs&#x27;</span></span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> title = <span class="string">&#x27;HELLO Koa2&#x27;</span></span><br><span class="line">  <span class="keyword">await</span> ctx.render(<span class="string">&#x27;index&#x27;</span>, &#123;</span><br><span class="line">    title</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="第13节：koa-static静态资源中间件"><a href="#第13节：koa-static静态资源中间件" class="headerlink" title="第13节：koa-static静态资源中间件"></a>第13节：koa-static静态资源中间件</h2><p>在后台开发中不仅有需要代码处理的业务逻辑请求，也会有很多的静态资源请求。比如请求js，css，jpg，png这些静态资源请求。也非常的多，有些时候还会访问静态资源路径。用koa2自己些这些静态资源访问是完全可以的，但是代码会雍长一些。所以这节课我们利用koa-static中间件来实现静态资源的访问。</p><ul><li><p>安装<code>koa-static</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save koa-static</span><br></pre></td></tr></table></figure></li><li><p><strong>新建static文件夹</strong> 然后在static文件中放入图片，css和js文件</p></li><li><p>使用<code>koa-static</code>中间件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&#x27;koa&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> = <span class="built_in">require</span>(<span class="string">&#x27;koa-static&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明静态路径</span></span><br><span class="line"><span class="keyword">const</span> staticPath = <span class="string">&#x27;./static&#x27;</span></span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">static</span>(</span><br><span class="line">    path.join(__dirname, staticPath)</span><br><span class="line">))</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问图片直接 http://127.0.0.1:3000/koa2.jpg</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Koa2入门小基础&quot;&gt;&lt;a href=&quot;#Koa2入门小基础&quot; class=&quot;headerlink&quot; title=&quot;Koa2入门小基础&quot;&gt;&lt;/a&gt;Koa2入门小基础&lt;/h1&gt;&lt;p&gt;学习指导：&lt;a href=&quot;http://www.jspang.com/posts/</summary>
      
    
    
    
    
    <category term="Koa2" scheme="http://mengjie.com/tags/Koa2/"/>
    
  </entry>
  
  <entry>
    <title>mongodb基础入门</title>
    <link href="http://mengjie.com/2021/03/18/MongoDB%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>http://mengjie.com/2021/03/18/MongoDB%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</id>
    <published>2021-03-18T00:00:00.000Z</published>
    <updated>2021-07-19T05:53:29.406Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MongoDB基础入门"><a href="#MongoDB基础入门" class="headerlink" title="MongoDB基础入门"></a>MongoDB基础入门</h1><p>学习指导：<a href="http://www.jspang.com/posts/2017/12/16/mongodb.html">挑战全栈 MongoDB基础视频教程 (共21集)</a></p><p>参考：<a href="https://www.runoob.com/mongodb/mongodb-tutorial.html">MongoDB 教程 | 菜鸟教程</a></p><h2 id="第01节：认识和安装MongoDB"><a href="#第01节：认识和安装MongoDB" class="headerlink" title="第01节：认识和安装MongoDB"></a>第01节：认识和安装MongoDB</h2><ul><li><p><strong>MongoDB是非关系型数据库</strong>，要了解非关系型数据库就必须先了解关系型数据库，关系数据库，是建立在关系模型基础上的数据库。比较有名气的关系型数据库，比如Oracle、DB2、MSSQL、Mysql。</p></li><li><p>非关系数据库和关系型数据库的区别是什么？</p><ul><li>实质：非关系型数据库的实质：非关系型数据库产品是传统关系型数据库的功能阉割版，通过减少用不到或很少用的功能，来大幅度提高产品性能。</li><li>价格：目前的非关系型数据库基本都是免费的，而比较有名气的关系型数据库都是收费的，比如：Oracle、DB2、MSSQL。MySql虽然是免费的，但是处理大型数据还是要提前作很多工作的。</li><li>功能：实际开发中，很多业务需求，其实并不需要完整的关系型数据库功能，非关系型数据库的功能就足够使用了。这种情况下，使用性能更高、成本更低的非关系型数据库当然是更明智的选择。</li></ul></li><li><p>了解关系型数据库和非关系型数据库的区别后，需要有一点的取舍，<strong>比较复杂和大型的项目不建议使用非关系型数据库</strong>，但是如果你想作个博客，CMS系统这类业务逻辑不复杂的程序，MongoDB是完全可以胜任的。</p></li><li><p>MongoDB简介：</p><ul><li>MongoDB是一个基于分布式文件存储的数据库，由C++语言编写。目的是为WEB应用提供扩展的高性能的数据存储解决方案。</li><li>MongoDB是一个介于关系型数据库和非关系型数据库之间的产品，是非关系型数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。</li><li>Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</li></ul></li><li><p>安装忽略</p></li><li><p><strong>运行MongoDB服务端：</strong></p><ul><li>安装好MongoDB数据库后，我们需要启用服务端才能使用。启用服务的命令是：Mongod。</li><li>打开命令行: 先打开运行（快捷键win+R），然后输入cmd后回车，就可以打开命令行工具。</li><li>执行mongod: 在命令中直接输入mongod，但是你会发现服务并没有启动，报了一个exception，服务停止了。</li><li>新建文件夹:出现上边的错误，是因为我们没有简历Mongodb需要的文件夹，<code>一般是安装盘的根目录，建立data/db,这两个文件夹</code>。</li><li>运行mongod：这时候服务就可以开启了，链接默认端口是27017。</li></ul></li><li><p><strong>链接服务：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cmd 输入 mongo</span></span><br><span class="line">mongo</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看存在数据库命令：</span></span><br><span class="line">show dbs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据库版本命令：</span></span><br><span class="line">db.version()</span><br></pre></td></tr></table></figure></li></ul><h2 id="第02节：Mongo基本命令-1"><a href="#第02节：Mongo基本命令-1" class="headerlink" title="第02节：Mongo基本命令-1"></a>第02节：Mongo基本命令-1</h2><ul><li><p><strong>MongoDB的存储结构</strong> 以前我们的关系型数据库的数据结构都是顶层是库，库下面是表，表下面是数据。但是MongoDB有所不同，库下面是集合，集合下面是文件。</p></li><li><p><strong>基础Shell命令：</strong></p><ul><li><code>show dbs</code> :显示已有数据库，如果你刚安装好，会默认有<code>local、admin、config</code>，这是MongoDB的默认数据库，我们在新建库时是不允许起这些名称的。</li><li><code>use admin</code>： 进入数据，也可以理解成为使用数据库。成功会显示：switched to db admin。</li><li><code>show collections</code>: 显示数据库中的集合（关系型中叫表，我们要逐渐熟悉）。</li><li><code>db</code>:显示当前位置，也就是你当前使用的数据库名称，这个命令算是最常用的，因为你在作任何操作的时候都要先查看一下自己所在的库，以免造成操作错误。</li></ul></li></ul><h2 id="第03节：Mongo基本命令-2"><a href="#第03节：Mongo基本命令-2" class="headerlink" title="第03节：Mongo基本命令-2"></a>第03节：Mongo基本命令-2</h2><ul><li><p><strong>数据操作基础命令：</strong></p><ul><li><p><code>use db（建立数据库）</code>：use不仅可以进入一个数据库，如果你敲入的库不存在，它还可以帮你建立一个库。但是在没有集合前，它还是默认为空。</p></li><li><p><code>db.集合.insert( )</code>:新建数据集合和插入文件（数据），当集合没有时，这时候就可以新建一个集合，并向里边插入数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user.insert(&#123;“name”:”jspang”&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>db.集合.find( )</code>:查询所有数据，这条命令会列出集合下的所有数据，可以看到MongoDB是自动给我们加入了索引值的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user.find()</span><br></pre></td></tr></table></figure></li><li><p><code>db.集合.findOne( )</code>:查询第一个文件数据，这里需要注意的，所有MongoDB的组合单词都使用首字母小写的驼峰式写法。</p></li><li><p><code>db.集合.update(&#123;查询&#125;,&#123;修改&#125;)</code>:修改文件数据，第一个是查询条件，第二个是要修改成的值。这里注意的是可以多加文件数据项的，比如下面的例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.jspang.update(&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;jspang&quot;</span>&#125;,&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;jspang&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="string">&quot;32&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>db.集合.remove(条件)</code>：删除文件数据，注意的是要跟一个条件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.user.remove(&#123;“name”:”jspang”&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>db.集合.drop()</code>:删除整个集合，这个在实际工作中一定要谨慎使用，如果是程序，一定要二次确认。</p></li><li><p><code>db.dropDatabase()</code>: 删除整个数据库，在删除库时，一定要先进入数据库，然后再删除。实际工作中这个基本不用，实际工作可定需要保留数据和痕迹的。</p></li></ul></li></ul><h2 id="第04节：用js文件写mongo命令"><a href="#第04节：用js文件写mongo命令" class="headerlink" title="第04节：用js文件写mongo命令"></a>第04节：用js文件写mongo命令</h2><ul><li><p>编写执行代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./mongoShell/goTask.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> userName = <span class="string">&#x27;jspang&#x27;</span>  <span class="comment">// 声明一个登录名  </span></span><br><span class="line"><span class="keyword">var</span> timeStamp = <span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>()) <span class="comment">// 声明登录时的时间戳  </span></span><br><span class="line"><span class="keyword">var</span> jsonDdatabase = &#123;  <span class="comment">// 组成JSON字符串</span></span><br><span class="line">  <span class="string">&quot;loginUnser&quot;</span>: userName,</span><br><span class="line">  <span class="string">&quot;loginTime&quot;</span>: timeStamp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> db = connect(<span class="string">&#x27;log&#x27;</span>)  <span class="comment">//链接数据库</span></span><br><span class="line">db.login.insert(jsonDdatabase) <span class="comment">//插入数据</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;[demo]log  print success&#x27;</span>)  <span class="comment">//没有错误显示成功</span></span><br></pre></td></tr></table></figure></li><li><p>执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 链接数据库(cmd)</span></span><br><span class="line">mongo</span><br><span class="line"></span><br><span class="line">mongo goTask.js</span><br><span class="line"></span><br><span class="line">show dbs</span><br><span class="line">use <span class="built_in">log</span></span><br><span class="line">show collections</span><br><span class="line">db.login.find()</span><br></pre></td></tr></table></figure></li></ul><h2 id="第05节：批量插入的正确方法"><a href="#第05节：批量插入的正确方法" class="headerlink" title="第05节：批量插入的正确方法"></a>第05节：批量插入的正确方法</h2><ul><li><p>在操作数据库时要注意两个能力：</p><ul><li>第一个是快速存储能力。</li><li>第二个是方便迅速查询能力。</li></ul></li><li><p><strong>批量插入</strong></p><ul><li><p>批量数据插入是以数组的方式进行的（如果写错，可以3个回车可以切出来）</p></li><li><p>插入数据测试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">db.test.insert([</span><br><span class="line">    &#123;<span class="string">&quot;_id&quot;</span>:1&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;_id&quot;</span>:2&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;_id&quot;</span>:3&#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.2版本以前的用法</span></span><br><span class="line">db.test.batchInsert([</span><br><span class="line">    &#123;<span class="string">&quot;_id&quot;</span>:1&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;_id&quot;</span>:2&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;_id&quot;</span>:3&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure></li><li><p>注意一次插入不要超过48M，向.zip和大图片什么的尽量用静态存储，MongoDB存储静态路径就好。</p></li></ul></li><li><p><strong>批量插入性能测试</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个个插入  执行insertTest1.js  耗时622ms</span></span><br><span class="line">mongo insertTest1.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量插入  执行insertTest2.js  耗时15ms</span></span><br><span class="line">mongo insertTest2.js</span><br></pre></td></tr></table></figure></li><li><p>总结：在工作中一定要照顾数据库性能，这也是你水平的提现，一个技术会了很简单，但是要作精通不那么简单。学完这节，记得在工作中如果在循环插入和批量插入举起不定，那就选批量插入吧，它会给我们更优的性能体验。</p></li><li><p>范式流程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = connect(<span class="string">&#x27;company&#x27;</span>)  <span class="comment">// 连接数据库</span></span><br><span class="line"><span class="keyword">var</span> workmateArray = [workmate1, workmate2, workmate3]</span><br><span class="line">db.workmate.insert(workmateArray)  <span class="comment">// 数据库插入集合</span></span><br><span class="line">print(<span class="string">&#x27;[SUCCESS]: The data was inserted successfully.&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="第06节：修改：Update常见错误"><a href="#第06节：修改：Update常见错误" class="headerlink" title="第06节：修改：Update常见错误"></a>第06节：修改：Update常见错误</h2><p>了解常见的错误操作</p><h2 id="第07节：修改：初识update修改器"><a href="#第07节：修改：初识update修改器" class="headerlink" title="第07节：修改：初识update修改器"></a>第07节：修改：初识update修改器</h2><ul><li><p><strong><code>$set</code>修改器</strong></p><p>用来修改一个指定的键值(key)，这时候我们要修改上节课的sex和age就非常方便了，只要一句话就可以搞定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.workmate.update(&#123; <span class="string">&quot;name&quot;</span>:<span class="string">&quot;MinJie&quot;</span> &#125;, &#123; <span class="string">&quot;$set&quot;</span>: &#123;<span class="attr">sex</span>:<span class="number">2</span>,<span class="attr">age</span>:<span class="number">21</span>&#125; &#125;)</span><br></pre></td></tr></table></figure><p>修改好后，我们可以用db.workmate.find()来进行查看</p></li><li><p><strong>修改嵌套内容(内嵌文档)</strong></p><p>skill数据是内嵌的，这时候我们可以属性的形式进行修改，skill.skillThree</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.workmate.update(&#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;MinJie&quot;</span> &#125;, &#123; <span class="attr">$set</span>: &#123; <span class="string">&quot;skill.skillThree&quot;</span>: <span class="string">&#x27;word&#x27;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong><code>$unset</code>用于将key删除</strong></p><p>作用其实就是删除一个key值和键</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.workmate.update(&#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;MinJie&quot;</span> &#125;, &#123; <span class="attr">$unset</span>: &#123; <span class="string">&quot;age&quot;</span>: <span class="string">&#x27;&#x27;</span> &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接用set进行添加</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>$inc</code>对数字进行计算</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.workmate.update(&#123; <span class="string">&quot;name&quot;</span>: <span class="string">&quot;MinJie&quot;</span> &#125;, &#123; <span class="attr">$inc</span>: &#123; <span class="string">&quot;age&quot;</span>: -<span class="number">2</span> &#125; &#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong><code>multi</code>选项</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.workmate.update(&#123;&#125;, &#123; <span class="attr">$set</span>: &#123; <span class="attr">interset</span>: [<span class="string">&#x27;basketball&#x27;</span>] &#125; &#125;, &#123; <span class="attr">multi</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个数据都发生了改变，multi是有ture和false两个值，true代表全部修改，false代表只修改一个（默认值）</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>upsert</code>选项</strong></p><p>upsert是在找不到值的情况下，直接插入这条数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.workmate.update(&#123; <span class="attr">name</span>: <span class="string">&#x27;xiaoWang&#x27;</span> &#125;, &#123; <span class="attr">$set</span>: &#123; <span class="attr">age</span>: <span class="number">20</span> &#125; &#125;, &#123; <span class="attr">upsert</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// upsert也有两个值：true代表没有就添加，false代表没有不添加(默认值)</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="第08节：修改：update数组修改器"><a href="#第08节：修改：update数组修改器" class="headerlink" title="#第08节：修改：update数组修改器"></a><a href="http://www.jspang.com/posts/2017/12/16/mongodb.html#%E7%AC%AC08%E8%8A%82%EF%BC%9A%E4%BF%AE%E6%94%B9%EF%BC%9Aupdate%E6%95%B0%E7%BB%84%E4%BF%AE%E6%94%B9%E5%99%A8">#</a>第08节：修改：update数组修改器</h2><ul><li><p><strong><code>$push</code>追加数组/内嵌文档值</strong></p><p><code>$push</code>的功能是追加数组中的值，但我们也经常用它操作内嵌稳文档，就是{}对象型的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// $push追加数组/内嵌文档值</span></span><br><span class="line">db.workmate.update(&#123; <span class="attr">name</span>: <span class="string">&#x27;xiaoWang&#x27;</span> &#125;, &#123; <span class="attr">$push</span>: &#123; <span class="attr">interest</span>: <span class="string">&#x27;draw&#x27;</span> &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// $push修饰符还可以为内嵌文档增加值</span></span><br><span class="line">db.workmate.update(&#123; <span class="attr">name</span>: <span class="string">&#x27;MinJie&#x27;</span> &#125;, &#123; <span class="attr">$push</span>: &#123; <span class="string">&quot;skill.skillFour&quot;</span>: <span class="string">&#x27;draw&#x27;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure><p><strong><code>$push</code>修饰符还可以为内嵌文档增加值</strong></p></li><li><p><strong><code>$ne</code>查找是否存在</strong></p><p><strong>检查一个值是否存在，如果不存在再执行操作，存在就不执行</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.workmate.update(&#123; <span class="attr">name</span>: <span class="string">&#x27;xiaoWang&#x27;</span>, <span class="string">&quot;interest&quot;</span>: &#123; <span class="attr">$ne</span>: <span class="string">&#x27;playGame&#x27;</span> &#125; &#125;, &#123; <span class="attr">$push</span>: &#123; <span class="attr">interest</span>: <span class="string">&#x27;playGame&#x27;</span> &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总结：没有则修改，有则不修改。</span></span><br></pre></td></tr></table></figure></li><li><p><strong><code>$addToSet</code> 升级版的<code>$ne</code></strong></p><p><code>$ne</code>的升级版本（查找是否存在，不存在就push上去），操作起来更直观和方便，所以再工作中这个要比<code>$en</code>用的多。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看小王(xiaoWang)兴趣(interest)中有没有阅读（readBook）这项，没有则加入读书(readBook)的兴趣.</span></span><br><span class="line"></span><br><span class="line">db.workmate.update(&#123; <span class="attr">name</span>: <span class="string">&quot;xiaoWang&quot;</span> &#125;, &#123; <span class="attr">$addToSet</span>: &#123; <span class="attr">interest</span>: <span class="string">&quot;readBook&quot;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong><code>$each</code>批量追加</strong></p><p>可以传入一个数组，一次增加多个值进去，相当于批量操作，性能同样比循环操作要好很多，这个是需要我们注意的，工作中也要先组合成数组，然后用批量的形式进行操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给xiaoWang,一次加入三个爱好，唱歌（Sing），跳舞（Dance），编码（Code）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newInterset = [<span class="string">&quot;Sing&quot;</span>, <span class="string">&quot;Dance&quot;</span>, <span class="string">&quot;Code&quot;</span>]</span><br><span class="line">db.workmate.update(&#123; <span class="attr">name</span>: <span class="string">&quot;xiaoWang&quot;</span> &#125;, &#123; <span class="attr">$addToSet</span>: &#123; <span class="attr">interest</span>: &#123; <span class="attr">$each</span>: newInterset &#125; &#125; &#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong><code>$pop</code> 删除数组值</strong></p><p><code>$pop</code>只删除一次，并不是删除所有数组中的值。而且它有两个选项，一个是1和-1。</p><p>  1：从数组末端进行删除；  -1：从数组开端进行删除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.workmate.update(&#123; <span class="attr">name</span>: <span class="string">&#x27;xiaoWang&#x27;</span> &#125;, &#123; <span class="attr">$pop</span>: &#123; <span class="attr">interest</span>: <span class="number">1</span> &#125; &#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong><code>interest.int</code> 数组定位修改</strong></p><p>修改数组的第几位，但并不知道是什么，这时候我们可以使用<code>interest.int</code> 的形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改xiaoWang的第三个兴趣为编码（Code），注意这里的计数是从0开始的</span></span><br><span class="line"></span><br><span class="line">db.workmate.update(&#123; <span class="attr">name</span>: <span class="string">&#x27;xiaoWang&#x27;</span> &#125;, &#123; <span class="attr">$set</span>: &#123; <span class="string">&quot;interest.2&quot;</span>: <span class="string">&quot;Code&quot;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="第09节：修改：状态返回与安全"><a href="#第09节：修改：状态返回与安全" class="headerlink" title="第09节：修改：状态返回与安全"></a>第09节：修改：状态返回与安全</h2><p>在修改时我们都会用<code>findAndModify</code>，它可以给我们返回来一些必要的参数，让我们对修改多了很多控制力，控制力的加强也就是对安全的强化能力加强。</p><ul><li><p><strong>应答式写入</strong></p><p>在之前的操作都是非应答式写入，就是在操作完数据库后，它并没有给我们任何的回应和返回值，而是我们自己安慰自己写了一句话 <code>print(‘[update]:The data was updated successfully’)</code>。这在工作中是不允许的，因为根本不能提现我们修改的结果。应答式写入就会给我们直接返回结果（报表），结果里边的包含项会很多，这样我们就可以很好的进行程序的控制和安全机制的处理。有点像前端调用后端接口，无论作什么，后端都要给我一些状态字一样。</p></li><li><p><strong><code>db.runCommand( )</code></strong></p><p>它是数据库运行命令的执行器，执行命令首选就要使用它，因为它在Shell和驱动程序间提供了一致的接口。（几乎操作数据库的所有操作，都可以使用<code>runCommand来执行</code>）现在我们试着用<code>runCommand</code>来修改数据库，看看结果和直接用<code>db.collections.update</code>有什么不同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改了所有男士的数据，每个人增加了1000元钱(money)，然后用db.runCommand()执行</span></span><br><span class="line">db.workmate.update(&#123; <span class="attr">sex</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">$set</span>: &#123; <span class="attr">money</span>: <span class="number">1000</span> &#125; &#125;, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">var</span> resultMessage = db.runCommand(&#123; <span class="attr">getLastError</span>: <span class="number">1</span> &#125;)</span><br><span class="line">printjson(resultMessage)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">false：第一句末尾的false是upsert的简写，代表没有此条数据时不增加;</span></span><br><span class="line"><span class="comment">true：true是multi的简写，代表修改所有，这两个我们在前边课程已经学过。</span></span><br><span class="line"><span class="comment">getLastError:1 :表示返回功能错误，这里的参数很多，如果有兴趣请自行查找学习，</span></span><br><span class="line"><span class="comment">printjson：表示以json对象的格式输出到控制台。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行返回结果</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;connectionId&quot;</span> : <span class="number">9</span>,</span><br><span class="line">  <span class="string">&quot;updatedExisting&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;n&quot;</span> : <span class="number">3</span>,</span><br><span class="line">  <span class="string">&quot;syncMillis&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;writtenTo&quot;</span> : <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;err&quot;</span> : <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;ok&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>查看是否和数据库链接成功</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.runCommand(&#123; <span class="attr">ping</span>: <span class="number">1</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回ok：1就代表链接正常</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">connecting to: mongodb://127.0.0.1:27017/company</span></span><br><span class="line"><span class="comment">Implicit session: session &#123; &quot;id&quot; : UUID(&quot;f8e213c6-c27b-4282-be47-df5a76eb72ae&quot;) &#125;</span></span><br><span class="line"><span class="comment">MongoDB server version: 4.0.10</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p><strong>findAndModify</strong></p><ul><li><p><code>findAndModify</code>是查找并修改的意思。配置它可以在修改后给我们返回修改的结果</p></li><li><p><strong><code>findAndModify</code>属性值：</strong></p><ul><li><code>query</code>：需要查询的条件/文档</li><li><code>sort</code>: 进行排序</li><li><code>remove：[boolean]</code>是否删除查找到的文档，值填写true，可以删除。</li><li><code>new:[boolean]</code>返回更新前的文档还是更新后的文档。</li><li><code>fields</code>：需要返回的字段</li><li><code>upsert</code>：没有这个值是否增加。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// findAndModify是查找并修改的意思。配置它可以在修改后给我们返回修改的结果</span></span><br><span class="line"><span class="keyword">var</span> myModify = &#123;</span><br><span class="line">  <span class="attr">findAndModify</span>: <span class="string">&quot;workmate&quot;</span>,</span><br><span class="line">  <span class="attr">query</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;JSPang&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">update</span>: &#123; <span class="attr">$set</span>: &#123; <span class="attr">age</span>: <span class="number">18</span> &#125; &#125;,</span><br><span class="line">  <span class="attr">new</span>: <span class="literal">true</span>    <span class="comment">// 更新完成，需要查看结果，如果为false不进行查看结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ResultMessage = db.runCommand(myModify)</span><br><span class="line">printjson(ResultMessage)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回结果  是最新的JSPang 数据</span></span><br></pre></td></tr></table></figure></li><li><p><code>findAndModify</code>的性能是没有直接使用<code>db.collections.update</code>的性能好，但是在实际工作中都是使用它，毕竟要商用的程序安全性还是比较重要的。</p></li></ul></li></ul><h2 id="第10节：查询：find的不等修饰符"><a href="#第10节：查询：find的不等修饰符" class="headerlink" title="第10节：查询：find的不等修饰符"></a>第10节：查询：find的不等修饰符</h2><ul><li><p>基础查找</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单查找</span></span><br><span class="line">db.workmate.find(&#123; <span class="string">&quot;skill.skillOne&quot;</span>: <span class="string">&quot;HTML + CSS&quot;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 筛选字段</span></span><br><span class="line">db.workmate.find(</span><br><span class="line">  &#123; <span class="string">&quot;skill.skillOne&quot;</span>: <span class="string">&quot;HTML+CSS&quot;</span> &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;skill.skillOne&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">_id</span>: <span class="literal">false</span>  <span class="comment">// 不显示_id</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><strong>不等修饰符</strong></p><ul><li><code>小于($lt)</code> : 英文全称less-than</li><li><code>小于等于($lte)</code> ： 英文全称less-than-equal</li><li><code>大于($gt)</code> : 英文全称greater-than</li><li><code>大于等于($gte)</code>: 英文全称greater-than-equal</li><li><code>不等于($ne)</code>: 英文全称not-equal</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不等查找  年龄小于30大于25岁的人</span></span><br><span class="line">db.workmate.find(</span><br><span class="line">  &#123; <span class="attr">age</span>: &#123; <span class="attr">$lte</span>: <span class="number">30</span>, <span class="attr">$gte</span>: <span class="number">25</span> &#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="literal">true</span>, <span class="attr">age</span>: <span class="literal">true</span>, <span class="string">&quot;skill.skillOne&quot;</span>: <span class="literal">true</span>, <span class="attr">_id</span>: <span class="literal">false</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><strong>日期查找</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> startDate = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;01/01/2018&#x27;</span>)</span><br><span class="line"></span><br><span class="line">db.workmate.find(</span><br><span class="line">  &#123; <span class="attr">regeditTime</span>: &#123; <span class="attr">$gt</span>: startDate &#125; &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="literal">true</span>, <span class="attr">age</span>: <span class="literal">true</span>, <span class="string">&quot;skill.skillOne&quot;</span>: <span class="literal">true</span>, <span class="attr">_id</span>: <span class="literal">false</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>vscode清屏 <code>cls</code></p></li></ul><h2 id="第11节：查询：find的多条件查询"><a href="#第11节：查询：find的多条件查询" class="headerlink" title="第11节：查询：find的多条件查询"></a>第11节：查询：find的多条件查询</h2><ul><li><p><strong><code>$in</code>修饰符</strong> ：in修饰符可以轻松解决一键多值的查询情况</p></li><li><p><strong><code>$in</code>相对的修饰符是<code>$nin</code>修饰符</strong></p></li><li><p><strong><code>$or</code>修饰符</strong>：用来查询多个键值的情况</p></li><li><p><strong><code>$nor</code>修饰符</strong></p></li><li><p><strong><code>$and</code>修饰符</strong>：用来查找几个key值都满足的情况  </p></li><li><p><strong><code>$not</code>修饰符</strong>： 用来查询除条件之外的值</p></li><li><p>查询演示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> db = connect(<span class="string">&#x27;company&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// $in 修饰符</span></span><br><span class="line">db.workmate.find(&#123;</span><br><span class="line">  <span class="attr">age</span>: &#123;</span><br><span class="line">    <span class="attr">$in</span>: [<span class="number">25</span>, <span class="number">33</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;skill.skillOne&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">_id</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// $or修饰符  查出年龄大于30岁的，或者会做PHP的信息</span></span><br><span class="line">db.workmate.find(&#123;</span><br><span class="line">  <span class="attr">$or</span>: [</span><br><span class="line">    &#123; <span class="attr">age</span>: &#123; <span class="attr">$gt3</span>: <span class="number">30</span> &#125; &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;skill.skillThree&quot;</span>: <span class="string">&#x27;PHP&#x27;</span> &#125;</span><br><span class="line">]&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;skill.skillThree&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">_id</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// $and用来查找几个key值都满足 查询同事中大于30岁并且会做PHP的信息</span></span><br><span class="line">db.workmate.find(&#123;</span><br><span class="line">  <span class="attr">$and</span>: [</span><br><span class="line">    &#123; <span class="attr">age</span>: &#123; <span class="attr">$gte</span>: <span class="number">30</span> &#125; &#125;,</span><br><span class="line">    &#123; <span class="string">&quot;skill.skillThree&quot;</span>: <span class="string">&#x27;PHP&#x27;</span> &#125;</span><br><span class="line">]&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;skill.skillThree&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">_id</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// $not修饰符  用来查询除条件之外的值，比如我们现在要查找除年龄大于20岁，小于30岁的人员信息</span></span><br><span class="line">db.workmate.find(&#123;</span><br><span class="line">  <span class="attr">age</span>: &#123;</span><br><span class="line">    <span class="attr">$not</span>: &#123;</span><br><span class="line">      <span class="attr">$lte</span>: <span class="number">30</span>,</span><br><span class="line">      <span class="attr">$gte</span>: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&quot;skill.skillOne&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">_id</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul><h2 id="第12节：查询：find的数组查询"><a href="#第12节：查询：find的数组查询" class="headerlink" title="第12节：查询：find的数组查询"></a>第12节：查询：find的数组查询</h2><ul><li><p><strong>基本数组查询</strong></p></li><li><p><strong><code>$all</code>数组多项查询</strong> ： 对数组中的对象进行查询，是需要满足所有条件的</p></li><li><p><strong><code>$in</code>数组的或者查询</strong> ： 满足数组中的一项就可以被查出来</p></li><li><p><strong><code>$size</code>数组个数查询</strong> : 根据数组的数量查询出结果</p></li><li><p><strong><code>$slice</code>显示选项</strong>: 并不需要显示出数组中的所有值，而是只显示前两项</p></li><li><p>查询演示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本数组查询</span></span><br><span class="line"><span class="comment">// 查询一个人的爱好是’画画’,’聚会’,’看电影’</span></span><br><span class="line">db.workmate.find(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">interest</span>: [<span class="string">&#x27;画画&#x27;</span>, <span class="string">&#x27;聚会&#x27;</span>, <span class="string">&#x27;看电影&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">interest</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">_id</span>: <span class="number">0</span></span><br><span class="line">  &#125; </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查出看兴趣中有看电影的员工信息</span></span><br><span class="line">db.workmate.find(&#123;</span><br><span class="line">  <span class="attr">interest</span>: <span class="string">&#x27;看电影&#x27;</span></span><br><span class="line">&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">interest</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">_id</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// $all-数组多项查询  查询出喜欢看电影和看书的人员信息</span></span><br><span class="line">db.workmate.find(&#123;</span><br><span class="line">  <span class="attr">interest</span>: &#123;</span><br><span class="line">    <span class="attr">$all</span>: [<span class="string">&#x27;看电影&#x27;</span>, <span class="string">&#x27;看书&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">interest</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">_id</span>: <span class="number">0</span></span><br><span class="line">  &#125; </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// $in-数组的或者查询</span></span><br><span class="line"><span class="comment">// 用$all修饰符，是需要满足所有条件的，</span></span><br><span class="line"><span class="comment">// $in主要满足数组中的一项就可以被查出来（有时候会跟$or弄混）</span></span><br><span class="line"><span class="comment">// 查询爱好中有看电影的或者看书的员工信息</span></span><br><span class="line">db.workmate.find(&#123;</span><br><span class="line">  <span class="attr">interest</span>: &#123;</span><br><span class="line">    <span class="attr">$in</span>: [<span class="string">&#x27;看电影&#x27;</span>, <span class="string">&#x27;看书&#x27;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">interest</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">_id</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// $size-数组个数查询</span></span><br><span class="line"><span class="comment">// $size修饰符可以根据数组的数量查询出结果。</span></span><br><span class="line"><span class="comment">// 查找兴趣的数量是5个人员信息</span></span><br><span class="line">db.workmate.find(&#123;</span><br><span class="line">  <span class="attr">interest</span>: &#123;</span><br><span class="line">    <span class="attr">$size</span>: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">interest</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">_id</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// $slice-显示选项</span></span><br><span class="line"><span class="comment">// 有时候我并不需要显示出数组中的所有值，而是只显示前两项，</span></span><br><span class="line"><span class="comment">// 比如我们现在想显示每个人兴趣的前两项，而不是把每个人所有的兴趣都显示出来</span></span><br><span class="line">db.workmate.find(&#123;</span><br><span class="line">  <span class="comment">// interest: &#123;</span></span><br><span class="line">  <span class="comment">//   $size: 5</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">interest</span>: &#123;<span class="attr">$slice</span>: <span class="number">2</span>&#125;,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">_id</span>: <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 想显示兴趣的最后一项，可以直接使用slice:-1，来进行查询</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="第13节：查询：find的参数使用方法"><a href="#第13节：查询：find的参数使用方法" class="headerlink" title="第13节：查询：find的参数使用方法"></a>第13节：查询：find的参数使用方法</h2><p><strong>在操作<code>find方法</code>的<code>第一个参数（query）</code>和<code>第二个参数（fields）</code>。<code>find</code>还有几个常用的参数，这些参数多用在分页和排序上</strong></p><ul><li><p><code>find</code>参数：</p><ul><li><code>query</code>：这个就是查询条件，MongoDB默认的第一个参数。</li><li><code>fields</code>：（返回内容）查询出来后显示的结果样式，可以用true和false控制是否显示。</li><li><code>limit</code>：返回的数量，后边跟数字，控制每次查询返回的结果数量。</li><li><code>skip</code>: 跳过多少个显示，和limit结合可以实现分页。</li><li><code>sort</code>：排序方式，从小到大排序使用1，从大到小排序使用-1</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分页展示</span></span><br><span class="line">db.workmate.find(</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">_id</span>: <span class="literal">false</span></span><br><span class="line">    &#125;).limit(<span class="number">0</span>).skip(<span class="number">2</span>).sort(&#123; <span class="attr">age</span>: <span class="number">1</span> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p><strong><code>$where</code>修饰符</strong></p><p>它是一个非常强大的修饰符，但强大的背后也意味着有风险存在。它可以让我们在条件里使用javascript的方法来进行复杂查询。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询年龄大于30岁的人员</span></span><br><span class="line">db.workmate.find(</span><br><span class="line">    &#123; <span class="attr">$where</span>: <span class="string">&quot;this.age&gt;30&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="literal">true</span>, <span class="attr">age</span>: <span class="literal">true</span>, <span class="attr">_id</span>: <span class="literal">false</span> &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// this指向的是workmate（查询集合）本身。</span></span><br><span class="line"><span class="comment">// 这样我们就可以在程序中随意调用。</span></span><br><span class="line"><span class="comment">// 虽然强大和灵活，但是这种查询对于数据库的压力和安全性都会变重，</span></span><br><span class="line"><span class="comment">// 所以在工作中尽量减少$where修饰符的使用。</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="第14节：查询：find如何在js文本中使用"><a href="#第14节：查询：find如何在js文本中使用" class="headerlink" title="第14节：查询：find如何在js文本中使用"></a>第14节：查询：find如何在js文本中使用</h2><ul><li><p><code>find</code>查询如何才终端中<code>load()</code>执行</p></li><li><p><strong>hasNext循环结果</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hasNext循环结果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db = connect(<span class="string">&quot;company&quot;</span>)  <span class="comment">// 进行链接对应的集合collections</span></span><br><span class="line"><span class="keyword">var</span> result = db.workmate.find() <span class="comment">// 声明变量result，并把查询结果赋值给result</span></span><br><span class="line"><span class="comment">// 利用游标的hasNext()进行循环输出结果。</span></span><br><span class="line"><span class="keyword">while</span> (result.hasNext()) &#123;</span><br><span class="line">  printjson(result.next())  <span class="comment">//用json格式打印结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>forEach</code>循环</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forEach循环</span></span><br><span class="line"><span class="comment">// 利用hasNext循环结果，需要借助while的帮助，</span></span><br><span class="line"><span class="comment">// MongoDB也为我们提供了forEach循环，现在修改上边的代码，使用forEach循环来输出结果。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db = connect(<span class="string">&quot;company&quot;</span>)  <span class="comment">// 进行链接对应的集合collections</span></span><br><span class="line"><span class="keyword">var</span> result = db.workmate.find() <span class="comment">// 声明变量result，并把查询结果赋值给result</span></span><br><span class="line"><span class="comment">// 利用forEach循环</span></span><br><span class="line">result.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  printjson(result)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>forEach</code>循环更为优雅。这两种方法都是非常不错的,凭借自己爱好进行选择吧</p></li></ul><h2 id="第15节：索引-构造百万级数据"><a href="#第15节：索引-构造百万级数据" class="headerlink" title="第15节：索引:构造百万级数据"></a>第15节：索引:构造百万级数据</h2><ul><li><p>构造百万级的数据集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造百万级的数据集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetRandomNum</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> range = max - min  <span class="comment">//得到随机数区间</span></span><br><span class="line">  <span class="keyword">let</span> rand = <span class="built_in">Math</span>.random() <span class="comment">//得到随机值</span></span><br><span class="line">  <span class="keyword">return</span> (min + <span class="built_in">Math</span>.round(rand * range)) <span class="comment">//最小值+随机数取整 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// console.log(GetRandomNum(10000, 99999))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机用户名</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetRadomUserName</span>(<span class="params">min, max</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> tempStringArray = <span class="string">&quot;123456789qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&quot;</span>.split(<span class="string">&quot;&quot;</span>) <span class="comment">//构造生成时的字母库数组</span></span><br><span class="line">  <span class="keyword">let</span> outPuttext = <span class="string">&quot;&quot;</span> <span class="comment">// 最后输出的变量</span></span><br><span class="line">  <span class="comment">// 进行循环，随机生产用户名的长度，这里需要生成随机数方法的配合</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; GetRandomNum(min, max); i++)&#123;</span><br><span class="line">    <span class="comment">// 随机抽取字母，拼装成需要的用户名</span></span><br><span class="line">    outPuttext = outPuttext + tempStringArray[GetRandomNum(<span class="number">0</span>, tempStringArray.length)]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> outPuttext</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// console.log(GetRadomUserName(7, 16))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入200万数据</span></span><br><span class="line"><span class="keyword">var</span> startTime = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db = connect(<span class="string">&#x27;company&#x27;</span>)</span><br><span class="line">db.randomInfo.drop()</span><br><span class="line"><span class="keyword">var</span> tempInfo = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2000000</span>; i++)&#123;</span><br><span class="line">  tempInfo.push(&#123;</span><br><span class="line">    <span class="attr">username</span>: GetRadomUserName(<span class="number">7</span>, <span class="number">16</span>),</span><br><span class="line">    <span class="attr">regeditTime</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span><br><span class="line">    <span class="attr">randNum0</span>: GetRandomNum(<span class="number">100000</span>, <span class="number">999999</span>),</span><br><span class="line">    <span class="attr">randNum1</span>: GetRandomNum(<span class="number">100000</span>, <span class="number">999999</span>),</span><br><span class="line">    <span class="attr">randNum2</span>: GetRandomNum(<span class="number">100000</span>, <span class="number">999999</span>),</span><br><span class="line">    <span class="attr">randNum3</span>: GetRandomNum(<span class="number">100000</span>, <span class="number">999999</span>),</span><br><span class="line">    <span class="attr">randNum4</span>: GetRandomNum(<span class="number">100000</span>, <span class="number">999999</span>),</span><br><span class="line">    <span class="attr">randNum5</span>: GetRandomNum(<span class="number">100000</span>, <span class="number">999999</span>),</span><br><span class="line">    <span class="attr">randNum6</span>: GetRandomNum(<span class="number">100000</span>, <span class="number">999999</span>),</span><br><span class="line">    <span class="attr">randNum7</span>: GetRandomNum(<span class="number">100000</span>, <span class="number">999999</span>),</span><br><span class="line">    <span class="attr">randNum8</span>: GetRandomNum(<span class="number">100000</span>, <span class="number">999999</span>),</span><br><span class="line">    <span class="attr">randNum8</span>: GetRandomNum(<span class="number">100000</span>, <span class="number">999999</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.randomInfo.insert(tempInfo)</span><br><span class="line"><span class="keyword">var</span> endTime = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;[demo]:------&quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>db.randomInfo.stats()</code>这个命令查看数据中的数据条数</p></li></ul><h2 id="第16节：索引：索引入门"><a href="#第16节：索引：索引入门" class="headerlink" title="第16节：索引：索引入门"></a>第16节：索引：索引入门</h2><ul><li><p><strong>索引查询</strong> — 普通查询性能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引查询 --- 普通查询性能</span></span><br><span class="line"><span class="keyword">var</span> startTime = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> db = connect(<span class="string">&#x27;company&#x27;</span>)</span><br><span class="line"><span class="comment">// 跳过 5000 查询  db.randomInfo.find().skip(50000)</span></span><br><span class="line"><span class="keyword">var</span> result = db.randomInfo.find(&#123;</span><br><span class="line">  <span class="attr">username</span>:<span class="string">&quot;undefined4pi4n&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">result.forEach(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  printjson(result)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> endTime = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;[SUCCESS]:THIS RUN TIME IS:&quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询时间 875ms左右</span></span><br></pre></td></tr></table></figure></li><li><p><strong>建立索引</strong> <code>createIndex()</code></p><blockquote><p><em>注意在 3.0.0 版本前创建索引方法为 db.collection.ensureIndex()，之后的版本使用了 db.collection.createIndex() 方法，ensureIndex() 还能用，但只是 createIndex() 的别名。</em></p></blockquote><ul><li><p>语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.collection.createIndex(keys, options)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法中 Key 值为你要创建的索引字段，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。</span></span><br></pre></td></tr></table></figure></li><li><p>用法实例：</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立索引  --- 试着为用户名（username）建立索引</span></span><br><span class="line">db.randomInfo.createIndex(&#123; <span class="attr">username</span>: <span class="number">1</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line">db.randomInfo.ensureIndex(&#123; <span class="attr">username</span>: <span class="number">1</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复合索引</span></span><br><span class="line">db.col.createIndex(&#123;<span class="string">&quot;title&quot;</span>:<span class="number">1</span>,<span class="string">&quot;description&quot;</span>:-<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>查看现有索引</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看现有索引</span></span><br><span class="line"></span><br><span class="line">db.randomInfo.getIndexes()</span><br></pre></td></tr></table></figure></li><li><p>建立索引后再次执行查询 <code>load(&#39;./index_demo2.js&#39;)</code>，时间下降到 7ms了，随机波动，不超过20ms</p></li><li><p>无论是在关系型数据库还是文档数据库，建立索引都是非常重要的。索引这东西是要消耗硬盘和内存资源的，所以还是要根据程序需要进行建立了。<strong>MongoDB也给我们进行了限制，只允许我们建立64个索引值</strong>。</p></li></ul><h2 id="第17节：索引：复合索引"><a href="#第17节：索引：复合索引" class="headerlink" title="第17节：索引：复合索引"></a>第17节：索引：复合索引</h2><ul><li><p><strong>索引中的小坑</strong></p><ul><li><p>通过实际开发和性能对比，总结了几条不用索引的情况（不一定对，但是自己的经验之谈）。</p></li><li><p>数据不超万条时，不需要使用索引。性能的提升并不明显，而大大增加了内存和硬盘的消耗。</p></li><li><p>查询数据超过表数据量30%时，不要使用索引字段查询。实际证明会比不使用索引更慢，因为它大量检索了索引表和我们原表。（如查询员工的性别）</p></li><li><p>数字索引，要比字符串索引快的多，在百万级甚至千万级数据量面前，使用数字索引是个明确的选择。</p></li><li><p>把你经常查询的数据做成一个内嵌数据（对象型的数据），然后集体进行索引。</p></li></ul></li><li><p><strong>复合索引</strong> : 复合索引就是两条以上的索引</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// db.randomInfo.ensureIndex(&#123; username: 1 &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加建立randNum0 的索引</span></span><br><span class="line">db.randomInfo.ensureIndex(&#123;<span class="attr">randNum0</span>:<span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment">// 查看现有索引</span></span><br><span class="line">db.randomInfo.getIndexes()</span><br></pre></td></tr></table></figure></li><li><p><strong>两个索引同时查询</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> startTime = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line"><span class="keyword">var</span> db = connect(<span class="string">&#x27;company&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = db.randomInfo.find(&#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&quot;undefined4pi4n&quot;</span>,</span><br><span class="line">  <span class="attr">randNum0</span>: <span class="number">565509</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">result.forEach(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  printjson(result)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> endTime = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()</span><br><span class="line">print(<span class="string">&quot;[SUCCESS]:THIS RUN TIME IS:&quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询时间 8ms</span></span><br><span class="line"><span class="comment">// 从性能上看并没有什么特殊的变化，查询时间还是在8ms左右。</span></span><br><span class="line"><span class="comment">// MongoDB的复合查询是按照我们的索引顺序进行查询的</span></span><br></pre></td></tr></table></figure></li><li><p>执行查询 <code>load(&#39;./index_demo3.js&#39;)</code></p></li><li><p><strong>指定索引查询（<code>hint</code>）</strong></p><p>数字的索引要比字符串的索引快，这就需要一个方法来打破索引表的查询顺序，用我们自己指定的索引优先查询，这个方法就是<code>hint()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打破索引表的查询顺序</span></span><br><span class="line"><span class="keyword">var</span> result = db.randomInfo.find(&#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&quot;undefined4pi4n&quot;</span>,</span><br><span class="line">  <span class="attr">randNum0</span>: <span class="number">565509</span></span><br><span class="line">&#125;).hint(&#123; <span class="attr">randNum0</span>: <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>删除索引</strong></p><p>当索引性能不佳或起不到作用时，我们需要删除索引，删除索引的命令是<code>dropIndex()</code>. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.randomInfo.dropIndex(<span class="string">&#x27;randNum0_1&#x27;</span>) <span class="comment">//索引的唯一ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除时填写的值，并不是我们的字段名称（key），而是我们索引查询表中的name值</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="第18节：索引：全文索引"><a href="#第18节：索引：全文索引" class="headerlink" title="第18节：索引：全文索引"></a>第18节：索引：全文索引</h2><ul><li><p>准备数据</p></li><li><p><strong>建立全文索引</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立全文索引</span></span><br><span class="line">db.info.ensureIndex(&#123; <span class="attr">contextInfo</span>: <span class="string">&#x27;text&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意的是这里使用text关键词来代表全文索引，我们在这里就不建立数据模型了</span></span><br></pre></td></tr></table></figure></li><li><p><strong>全文索引查找</strong></p><ul><li><p>建立好了全文索引就可以查找了，查找时需要两个关键修饰符:</p></li><li><p><code>$text</code>: 表示要在全文索引中查东西。</p></li><li><p><code>$search</code>:后边跟查找的内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.info.find(&#123;<span class="attr">$text</span>:&#123;<span class="attr">$search</span>:<span class="string">&quot;programmer&quot;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>查找多个词</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全文索引是支持多个次查找的，</span></span><br><span class="line"><span class="comment">// 查找数据中有programmer，family，diary，drink的数据（这是或的关系），所以两条数据都会出现</span></span><br><span class="line">db.info.find(&#123; <span class="attr">$text</span>: &#123; <span class="attr">$search</span>: <span class="string">&quot;programmer family diary drink&quot;</span> &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希望不查找出来有drink这个单词的记录，我们可以使用“-”减号来取消。</span></span><br><span class="line">db.info.find(&#123; <span class="attr">$text</span>: &#123; <span class="attr">$search</span>: <span class="string">&quot;programmer family diary -drink&quot;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>转义符：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全文搜索中是支持转义符的，比如我们想搜索的是两个词（love PlayGame和drink），这时候需要使用\斜杠来转意。</span></span><br><span class="line"></span><br><span class="line">db.info.find(&#123; <span class="attr">$text</span>: &#123; <span class="attr">$search</span>: <span class="string">&quot;\&quot;love PlayGame\&quot; drink&quot;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="第19节：管理-用户的创建、删除与修改"><a href="#第19节：管理-用户的创建、删除与修改" class="headerlink" title="第19节：管理:用户的创建、删除与修改"></a>第19节：管理:用户的创建、删除与修改</h2><ul><li><p><strong>创建用户：</strong></p><p>首先要进入我们的<code>admin</code>库中，进入方法是直接使用<code>use admin </code>就可以。进入后可以使用<code>show collections</code>来查看数据库中的集合。默认是只有一个集合的<code>（system.version）</code>。</p><ul><li>语法： <code>db.createUser()</code></li><li>展示代码：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建用户权限</span></span><br><span class="line">db.createUser(&#123;  </span><br><span class="line">  <span class="attr">user</span>: <span class="string">&quot;marlon&quot;</span>,  </span><br><span class="line">  <span class="attr">pwd</span>: <span class="string">&quot;123456&quot;</span>,  </span><br><span class="line">  <span class="attr">customData</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;marlon&#x27;</span>,</span><br><span class="line">    <span class="attr">email</span>: <span class="string">&#x27;marlon@126.com&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">roles</span>: [<span class="string">&#x27;read&#x27;</span>]  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="comment">// 单独配置一个数据库的权限，比如我们现在要配置compay数据库的权限为读写</span></span><br><span class="line">db.createUser(&#123;  </span><br><span class="line">  <span class="attr">user</span>: <span class="string">&quot;jspang&quot;</span>,  </span><br><span class="line">  <span class="attr">pwd</span>: <span class="string">&quot;123456&quot;</span>,  </span><br><span class="line">  <span class="attr">customData</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;技术胖&#x27;</span>,</span><br><span class="line">    <span class="attr">email</span>: <span class="string">&#x27;web0432@126.com&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">roles</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">role</span>: <span class="string">&quot;readWrite&quot;</span>,</span><br><span class="line">      <span class="attr">db</span>: <span class="string">&quot;company&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;read&#x27;</span></span><br><span class="line">  ]  </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">内置角色：</span></span><br><span class="line"><span class="comment">  数据库用户角色：read、readWrite；</span></span><br><span class="line"><span class="comment">  数据库管理角色：dbAdmin、dbOwner、userAdmin;</span></span><br><span class="line"><span class="comment">  集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManage；</span></span><br><span class="line"><span class="comment">  备份恢复角色：backup、restore；</span></span><br><span class="line"><span class="comment">  所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase</span></span><br><span class="line"><span class="comment">  超级用户角色：root</span></span><br><span class="line"><span class="comment">  内部角色：__system</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>数据库内置角色配置说明：<ol><li>数据库用户角色：read、readWrite；</li><li>数据库管理角色：dbAdmin、dbOwner、userAdmin;</li><li>集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManage；</li><li>备份恢复角色：backup、restore；</li><li>所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase</li><li>超级用户角色：root</li><li>内部角色：__system</li></ol></li></ul></li><li><p><strong>查找用户信息</strong> <code>db.system.users.find()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找用户信息</span></span><br><span class="line">db.system.users.find()</span><br></pre></td></tr></table></figure></li><li><p><strong>删除用户</strong> <code>db.system.users.remove(&#123; user: &quot;marlon&quot; &#125;)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除用户</span></span><br><span class="line">db.system.users.remove(&#123; <span class="attr">user</span>: <span class="string">&quot;marlon&quot;</span> &#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>鉴权</strong> <code>db.auth(name, pwd)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证用户的用户名密码是否正确，就需要用到MongoDB提供的鉴权操作。也算是一种登录操作</span></span><br><span class="line"></span><br><span class="line">db.auth(<span class="string">&quot;jspang&quot;</span>, <span class="string">&quot;123456&quot;</span>)</span><br><span class="line"><span class="comment">// 正确返回1，如果错误返回0。（Error：Authentication failed。）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>启动建权</strong> <code>mongod --auth</code></p><p>重启MongoDB服务器，然后设置必须使用鉴权登录。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cmd 重新启动</span></span><br><span class="line"></span><br><span class="line">mongod --auth</span><br></pre></td></tr></table></figure></li><li><p><strong>登录</strong> <code>mongo  -u jspang -p 123456 127.0.0.1:27017/admin</code></p><p>如果在配置用户之后，用户想登录，可以使用mongo的形式，不过需要配置用户名密码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo  -u jspang -p <span class="number">123456</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">27017</span>/admin</span><br></pre></td></tr></table></figure></li></ul><h2 id="第20节：管理：备份和还原"><a href="#第20节：管理：备份和还原" class="headerlink" title="第20节：管理：备份和还原"></a>第20节：管理：备份和还原</h2><ul><li><p>对数据库的备份和还原: <code>mongodump</code>和<code>mongorestore</code>两个命令</p></li><li><p><strong>备份<code>mongodump</code></strong></p><ul><li><p>mongodump备份的基本格式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mongodump</span><br><span class="line">    --host <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    --port <span class="number">27017</span></span><br><span class="line">    --out D:<span class="regexp">/databack/</span>backup   <span class="comment">// 备份地址</span></span><br><span class="line">    --collection myCollections</span><br><span class="line">    --db test</span><br><span class="line">    --username username</span><br><span class="line">    --password password</span><br></pre></td></tr></table></figure></li><li><p>备份演示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodump --host <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> --port <span class="number">27017</span> --out D:<span class="regexp">/databack/</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>数据恢复<code>mongorestore</code></strong></p><ul><li><p>mongorestore恢复基本格式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mongorestore</span><br><span class="line">    --host <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    --port <span class="number">27017</span></span><br><span class="line">    --username username</span><br><span class="line">    --password password</span><br><span class="line">    &lt;path to the backup&gt;</span><br></pre></td></tr></table></figure></li><li><p>恢复演示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongorestore --host <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> --port <span class="number">27017</span> D:<span class="regexp">/databack/</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>两个命令很简单，甚至你可以写成脚本和定时任务，让他每天自己执行。但是如果你真的使用了MongoDB数据库，这是一个最基本的操作。</p></li></ul><h2 id="第21节：管理：图形界面管理（完结）"><a href="#第21节：管理：图形界面管理（完结）" class="headerlink" title="第21节：管理：图形界面管理（完结）"></a>第21节：管理：图形界面管理（完结）</h2><ul><li><code>NoSQL Manager for MongoDB</code></li><li><code>Studio 3T</code></li><li><code>MongoDB Compass</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MongoDB基础入门&quot;&gt;&lt;a href=&quot;#MongoDB基础入门&quot; class=&quot;headerlink&quot; title=&quot;MongoDB基础入门&quot;&gt;&lt;/a&gt;MongoDB基础入门&lt;/h1&gt;&lt;p&gt;学习指导：&lt;a href=&quot;http://www.jspang.co</summary>
      
    
    
    
    
    <category term="Mongodb | Mongodb" scheme="http://mengjie.com/tags/Mongodb-Mongodb/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题积累</title>
    <link href="http://mengjie.com/2021/03/18/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%A7%AF%E7%B4%AF/"/>
    <id>http://mengjie.com/2021/03/18/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%A7%AF%E7%B4%AF/</id>
    <published>2021-03-18T00:00:00.000Z</published>
    <updated>2021-07-19T05:53:09.722Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端面试题积累"><a href="#前端面试题积累" class="headerlink" title="前端面试题积累"></a>前端面试题积累</h1><p>标签（空格分隔）： Summarize Interview</p><hr><h2 id="vue构造器以及实例属性"><a href="#vue构造器以及实例属性" class="headerlink" title="vue构造器以及实例属性"></a>vue构造器以及实例属性</h2><ul><li><p>构造器</p><ul><li>Vue.js是一个构造函数，编程中称之为构造器。</li><li>每一个new Vue() 都是一个Vue构造函数的实例，这个过程叫做实例化。  </li><li>构造函数需要将其实例化后才会启用。  </li><li>Vue构造器要求实例化时需要传入一个选项对象。    </li><li>选项对象包括数据(data)，模板(tamplate)，挂载元素(el)，方法(methods)，生命周期钩子等选项。</li><li>每个 Vue.js应用都是通过构造函数Vue创建一个 Vue 的根实例启动的。在文档中经常会使用 vm (ViewModel 的简称)这个变量名表示 Vue 实例。</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//vue的实例化</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  // 选项</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>可以扩展构造器Vue，从而用预定义选项创建可复用的组件构造器，所有组件都是被扩展的Vue的实例，使用 <code>Vue.extend(&#123;&#125;)</code>来扩展；</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var MyComponent = Vue.extend(&#123;</span><br><span class="line">// 扩展选项</span><br><span class="line">&#125;)</span><br><span class="line">// 所有的MyComponent实例都将以预定义的扩展选项被创建</span><br><span class="line">// 相当于MyComponent继承Vue并且加上扩展的选项</span><br><span class="line"></span><br><span class="line">// MyComponent()相当于扩展后的vue，而myComponentInstance 就是扩展后vue的实例。</span><br><span class="line">var myComponentInstance = new MyComponent();</span><br></pre></td></tr></table></figure></li><li><p>属性与方法</p><ul><li>每个Vue的实例都会代理其data对象里的所有属性，被代理的属性是响应的；  </li><li>如果实例创建之后添加新的属性到实例上，不会触发视图更新；</li><li>不要在实例属性或者回调函数中使用箭头函数（如 <code>vm.$watch(&#39;a&#39;, newVal =&gt; this.myMethod())</code>）。因为箭头函数绑定父上下文，所以 this 不会像预想的一样是 Vue 实例，而是<code>this.myMethod</code>未被定义。</li><li>Vue实例暴露了一些有用的实例属性和方法，带有前缀 <code>$</code>，便于与代理的data区分<ul><li><code>vm.$el</code>：类型（HTMLElement）挂载元素，Vue实例的DOM根元素；</li><li><code>vm.$data</code>：类型（Object），Vue实例观察的数据对象；</li><li><code>vm.$props</code>：类型（Object）。</li></ul></li></ul></li></ul><h2 id="手写实现-throttle-（节流）函数"><a href="#手写实现-throttle-（节流）函数" class="headerlink" title="手写实现 throttle （节流）函数"></a>手写实现 <code>throttle</code> （节流）函数</h2><h3 id="什么是throttle"><a href="#什么是throttle" class="headerlink" title="什么是throttle"></a>什么是throttle</h3><ul><li><p>定义：如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。</p></li><li><p>接口定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 频率控制 返回函数连续调用时，action 执行频率限定为 次 / delay</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>delay  &#123;number&#125;    延迟时间，单位毫秒</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>action &#123;function&#125;  请求关联函数，实际应用需要调用的函数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;function&#125;</span>    </span>返回客户调用函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">throttle(delay,action)</span><br></pre></td></tr></table></figure></li></ul><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">delay, action</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> last = 0<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> curr = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="keyword">if</span> (curr - last &gt; delay)&#123;</span><br><span class="line">      action.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      last = curr </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展延伸"><a href="#拓展延伸" class="headerlink" title="拓展延伸"></a>拓展延伸</h3><p><a href="https://www.cnblogs.com/fsjohnhuang/p/4147810.html">函数节流（throttle）与函数去抖（debounce）</a></p><h2 id="css实现自适应的正方形"><a href="#css实现自适应的正方形" class="headerlink" title="css实现自适应的正方形"></a>css实现自适应的正方形</h2><ul><li><p>padding-bottom实现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;square-shape&quot;</span>&gt;</span>这是一个可以自适应的正方形，此法很好用，有内容也是正方形。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.square-shape &#123;</span><br><span class="line">  width: 30%;</span><br><span class="line">  height: 0;</span><br><span class="line">  padding-bottom: 30%;</span><br><span class="line">  border: 1px solid #f00;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>伪元素的padding-bottom，内嵌absolute元素</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;square-shape&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>这是一个可以自适应的正方形<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.square-shape &#123;</span><br><span class="line">  width: 50%;</span><br><span class="line">  border: 1px solid #f00;</span><br><span class="line">&#125;</span><br><span class="line">.square-shape:after &#123;</span><br><span class="line">  content: &#x27;&#x27;;</span><br><span class="line">  display: block;</span><br><span class="line">  padding-bottom: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.content &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手写实现以下事件委托函数"><a href="#手写实现以下事件委托函数" class="headerlink" title="手写实现以下事件委托函数"></a>手写实现以下事件委托函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写实现以下事件委托函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delegate</span>(<span class="params">parent, selector, handle</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>事件委托，通俗来说就是将元素的事件委托给它的父级或者更外级元素处理。</p></li><li><p>需要注意的地方：</p><ul><li>保证兼容性，包括：事件绑定、元素选择器 Element.matches 、事件 event 对象</li><li>回调函数 this 指向</li><li>当目标元素下还有子元素时，子元素不能触发事件。<br>解决办法是在触发过程中对元素进行判断，如果当前触发的元素不是目标元素，就继续往该元素的 parentNode 查找，否则循环结束。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/ *</span><br><span class="line">  * [delegateEvent description]</span><br><span class="line">  * @param  &#123;[type]&#125;   parentSelector 父元素</span><br><span class="line">  * @param  &#123;[type]&#125;   targetSelector 目标元素</span><br><span class="line">  * @param  &#123;[type]&#125;   events         事件</span><br><span class="line">  * @param  &#123;<span class="built_in">Function</span>&#125; fn             回调函数</span><br><span class="line">  * @<span class="keyword">return</span> &#123;[type]&#125;                  <span class="literal">null</span></span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delegateEvent</span>(<span class="params">parentSelector, targetSelector, events, fn</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 事件绑定浏览器兼容性处理</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">ele, type, handle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ele.addEventListener) &#123;</span><br><span class="line">      ele.addEventListener(type, handle, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ele.attachEvent)&#123;</span><br><span class="line">      ele.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, handle);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ele[<span class="string">&#x27;on&#x27;</span> + type] = handle;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果元素被指定的选择器字符串选择， Element.matches() 方法返回 true; 否则返回 false。</span></span><br><span class="line">  <span class="comment">// 对于不支持 Element.matches() 或 Element.matchesSelector()，但支持 document.querySelectorAll() 方法的浏览器，存在以下替代方案</span></span><br><span class="line">  <span class="keyword">if</span> (!Element.prototype.matches) &#123;</span><br><span class="line">    Element.prototype.matches =</span><br><span class="line">    Element.prototype.matchesSelector ||</span><br><span class="line">    Element.prototype.mozMatchesSelector ||</span><br><span class="line">    Element.prototype.msMatchesSelector ||</span><br><span class="line">    Element.prototype.oMatchesSelector ||</span><br><span class="line">    Element.prototype.webkitMatchesSelector ||</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> matches = (<span class="built_in">this</span>.document || <span class="built_in">this</span>.ownerDocument).querySelectorAll(s),</span><br><span class="line">          i = matches.length;</span><br><span class="line">      <span class="keyword">while</span> (--i &gt;= <span class="number">0</span> &amp;&amp; matches.item(i) !== <span class="built_in">this</span>) &#123;&#125;</span><br><span class="line">      <span class="keyword">return</span> i &gt; -<span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事件处理逻辑</span></span><br><span class="line">  addEvent(parentSelector, events, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 兼容性处理</span></span><br><span class="line">    <span class="keyword">var</span> e = e || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">var</span> t = e.target || e.srcElement;</span><br><span class="line">    <span class="comment">// currentTarget === parentSelector</span></span><br><span class="line">    <span class="keyword">var</span> currentTarget = e.currentTarget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历并判断是否为目标元素，如果不是，则往元素的 parentNode 继续查找</span></span><br><span class="line">    <span class="keyword">while</span>(!t.matches(targetSelector)) &#123;</span><br><span class="line">      <span class="comment">// 如果是目标元素则跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(t === currentTarget) &#123;</span><br><span class="line">        t = <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t = t.parentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t) &#123;</span><br><span class="line">    <span class="comment">// 将回调函数的 this 指向目标元素</span></span><br><span class="line">    fn.call(t, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>实例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myLink&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;link&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;link&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;link&quot;</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> myLink = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#myLink&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  delegateEvent(myLink, <span class="string">&#x27;li.link&#x27;</span>, <span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">this</span>, <span class="built_in">this</span>.id + <span class="string">&#x27;：&#x27;</span> + <span class="built_in">this</span>.innerText);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><p>创建时间  2017-11-18 By MarlonChiu </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前端面试题积累&quot;&gt;&lt;a href=&quot;#前端面试题积累&quot; class=&quot;headerlink&quot; title=&quot;前端面试题积累&quot;&gt;&lt;/a&gt;前端面试题积累&lt;/h1&gt;&lt;p&gt;标签（空格分隔）： Summarize Interview&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;vue</summary>
      
    
    
    
    
    <category term="面试" scheme="http://mengjie.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>常用前端面试参考总结</title>
    <link href="http://mengjie.com/2021/03/18/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93/"/>
    <id>http://mengjie.com/2021/03/18/%E5%B8%B8%E7%94%A8%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%8F%82%E8%80%83%E6%80%BB%E7%BB%93/</id>
    <published>2021-03-18T00:00:00.000Z</published>
    <updated>2021-07-19T05:52:56.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用前端面试参考总结"><a href="#常用前端面试参考总结" class="headerlink" title="常用前端面试参考总结"></a>常用前端面试参考总结</h1><p>标签（空格分隔）： Summarize Interview</p><hr><h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul><li>函数的prototype属性(图)<ul><li>每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)</li><li>原型对象中有一个属性constructor, 它指向函数对象</li></ul></li><li>给原型对象添加属性(一般都是方法)<ul><li>作用: 函数的所有实例对象自动拥有原型中的属性(方法)</li><li>原型对象上的方法一般给其实例对象调用</li></ul></li></ul><h3 id="显式原型与隐式原型"><a href="#显式原型与隐式原型" class="headerlink" title="显式原型与隐式原型"></a>显式原型与隐式原型</h3><ul><li>每个函数对象function都有一个prototype，即显式原型</li><li>每个实例对象都有一个 <code>__proto__</code> ，可称为隐式原型</li><li>对象的隐式原型的值为其对应构造函数的显式原型的值 ===&gt; 都指向函数对象</li><li>内存结构(图)</li><li>总结:<ul><li>函数的prototype属性： 在定义函数时自动添加的，默认值是一个空Object对象</li><li>对象的<code>__proto__</code>属性：创建对象时自动添加的，默认值为构造函数的prototype属性值</li><li>程序员能直接操作显式原型，但不能直接操作隐式原型(ES6之前)</li></ul></li><li>举个例子</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// Fn()</span><br><span class="line">var Fn = function () &#123;&#125;  // 执行这条函数定义语句, 函数体并没有执行</span><br><span class="line"></span><br><span class="line">// 每个函数function都有一个prototype，即显式原型(属性)</span><br><span class="line">console.log(Fn.prototype)</span><br><span class="line"></span><br><span class="line">// 每个实例对象都有一个__proto__，可称为隐式原型(属性)</span><br><span class="line">var fn = new Fn()</span><br><span class="line">console.log(fn.__proto__)</span><br><span class="line"></span><br><span class="line">// 对象的隐式原型的值为其对应构造函数的显式原型的值</span><br><span class="line">console.log(fn.__proto__ === Fn.prototype)  // true</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 1. prototype属性: 函数对象</span><br><span class="line">    什么时候添加? 函数被定义时(创建函数对象时自动添加)</span><br><span class="line">    值是多少?  空的object实例对象: this.prototype = &#123;&#125;  this.prototype.constructor = this</span><br><span class="line"></span><br><span class="line">2. __proto__属性: 实例对象</span><br><span class="line">    什么时候添加? 创建实例对象时自动添加</span><br><span class="line">    值是多少?   构造函数的prototype属性值: this.__proto__ = Fn.prototype</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    执行函数: 执行函数体中的所有语句</span><br><span class="line">    执行函数定义: 本质是创建函数对象</span><br><span class="line">*/</span><br><span class="line">console.log(Object.prototype.__proto__);  // null</span><br></pre></td></tr></table></figure><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ul><li>原型链(图解)</li><li>访问一个对象的属性时，<ul><li>先在自身属性中查找，找到返回</li><li>如果没有,再沿着<code>__proto__</code>这条链向上查找, 找到返回</li><li>如果最终没找到,返回undefined</li></ul></li><li>别名：隐式原型链</li><li>作用：<strong>查找对象的属性(方法)</strong></li><li>构造函数/原型/实体对象的关系(图解)</li><li>构造函数/原型/实体对象的关系2(图解)</li><li>举个例子<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">console.log(Function.prototype===Function.__proto__)  // true</span><br><span class="line">console.log(Object.prototype.__proto__)  // null</span><br><span class="line">console.log(Object.prototype)</span><br><span class="line">function Fn() &#123;</span><br><span class="line">    this.test1 = function () &#123;</span><br><span class="line">        console.log(&#x27;test1()&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Fn.prototype.test2 = function () &#123;</span><br><span class="line">    console.log(&#x27;test2()&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">var fn = new Fn()</span><br><span class="line"></span><br><span class="line">fn.test1()</span><br><span class="line">fn.test2()</span><br><span class="line">console.log(fn.toString())</span><br><span class="line">console.log(fn.test3)  // undefined</span><br><span class="line">fn.test3()</span><br><span class="line"></span><br><span class="line">// 详情请看githubMarkdownPhotos分析图</span><br></pre></td></tr></table></figure></li><li><strong>原型链总结</strong><ul><li>查找对象的属性沿着原型链查找，查找变量沿着作用域链查找</li><li>函数对象既有<code>prototype</code>属性，也有<code>__proto__</code>属性（函数的本质是被new出来的）</li><li>所有函数对象的<code>__proto__</code>属性值都相等，都等于大写的Function的 <code>prototype</code></li><li>所有函数都是Function的实例，包括它自己。<br><code>Function.prototype === Function.__proto__ // true</code></li><li>非函数对象（实例对象）肯定是其对应构造函数的实例</li></ul></li></ul><h3 id="原型链的属性问题"><a href="#原型链的属性问题" class="headerlink" title="原型链的属性问题"></a>原型链的属性问题</h3><ul><li>读取对象的属性值时: 会自动到原型链中查找</li><li>设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值</li><li>即：<strong>当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作</strong></li><li>方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上</li><li>举个例子</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = function (name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sex = &#x27;男&#x27;;</span><br><span class="line"></span><br><span class="line">var p1 = new Person(&#x27;Tom&#x27;, 12)</span><br><span class="line">p1.setName(&#x27;Jack&#x27;)</span><br><span class="line">console.log(p1.name, p1.age, p1.sex) // Jack 12 &#x27;男&#x27;</span><br><span class="line"></span><br><span class="line">p1.sex = &#x27;女&#x27;  // 设置属性值时, 不会查看原型链</span><br><span class="line">console.log(p1.name, p1.age, p1.sex) //Jack 12 &#x27;女&#x27;</span><br><span class="line"></span><br><span class="line">var p2 = new Person(&#x27;Bob&#x27;, 23)</span><br><span class="line">console.log(p2.name, p2.age, p2.sex) //&#x27;Bob&#x27; 23 &#x27;男&#x27;</span><br></pre></td></tr></table></figure><h3 id="探索instanceof"><a href="#探索instanceof" class="headerlink" title="探索instanceof"></a>探索instanceof</h3><ul><li>instanceof是如何判断的?<ul><li>表达式: A instanceof B</li><li>如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false</li><li>A可以寻找多步，B只能找一步到自己的显式原型上</li></ul></li><li>Function是通过new自己产生的实例。即所有函数都是Function的实例包括它自身。</li><li>几点总结<ul><li><code>Object created by Function</code></li><li><code>Object 是 Function 的实例</code></li><li><code>Object 是 Object 的实例</code></li></ul></li><li>理解实例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object instanceof Function) // true</span><br><span class="line">console.log(Object instanceof Object) // true</span><br><span class="line">console.log(Function instanceof Object) // true</span><br><span class="line">console.log(Function instanceof Function) // true</span><br><span class="line">console.log(Object instanceof Foo); // false</span><br><span class="line"></span><br><span class="line">console.log(Function.prototype) // 不是Object的实例  ƒ () &#123; [native code] &#125;</span><br><span class="line">console.log(Function.prototype.__proto__===Object.prototype) // true</span><br></pre></td></tr></table></figure><ul><li>原型与原型链分析详图<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Foo () &#123;&#125;</span><br><span class="line">var f1 = new Foo()</span><br><span class="line">var f2 = new Foo()</span><br><span class="line">var o1 = &#123;&#125;</span><br><span class="line">var o2 = &#123;&#125;</span><br></pre></td></tr></table></figure><img src="https://i.imgur.com/Q3nxgq6.png" alt="原型与原型链分析"></li></ul><h3 id="面试题及总结"><a href="#面试题及总结" class="headerlink" title="面试题及总结"></a>面试题及总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 测试题 1</span><br><span class="line">var A = function() &#123;&#125;</span><br><span class="line">A.prototype.n = 1</span><br><span class="line">var b = new A()</span><br><span class="line"></span><br><span class="line">A.prototype = &#123;</span><br><span class="line">    n: 2,</span><br><span class="line">    m: 3</span><br><span class="line">&#125;</span><br><span class="line">var c = new A()</span><br><span class="line">console.log(b.n, b.m, c.n, c.m) //  1 undefined  2  3</span><br><span class="line"></span><br><span class="line">// 测试题2</span><br><span class="line">var F = function()&#123;&#125;;</span><br><span class="line">Object.prototype.a = function()&#123;</span><br><span class="line">    console.log(&#x27;a()&#x27;)</span><br><span class="line">&#125;;</span><br><span class="line">Function.prototype.b = function()&#123;</span><br><span class="line">    console.log(&#x27;b()&#x27;)</span><br><span class="line">&#125;;</span><br><span class="line">var f = new F();</span><br><span class="line">f.a()     // a()</span><br><span class="line">f.b()     // f.b is not a function</span><br><span class="line">F.a()     // a()</span><br><span class="line">F.b()     // b()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">原型链（隐式原型链）：作用查找对象的属性</span><br><span class="line">    访问一个对象的属性时，先在自身属性中查找，找到返回；</span><br><span class="line">    如果没有再沿着 __proto__ 这条链向上查找，找到返回，如果最终没有找到，则返回undefined</span><br><span class="line"></span><br><span class="line">A instanceof B  的判断</span><br><span class="line">    如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false</span><br><span class="line"></span><br><span class="line">prototype 与 __proto__ 在创建的时候相关联，在执行的时候没有关联</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><h2 id="webpack及构建工具的理解"><a href="#webpack及构建工具的理解" class="headerlink" title="webpack及构建工具的理解"></a>webpack及构建工具的理解</h2><h3 id="构建工具的功能"><a href="#构建工具的功能" class="headerlink" title="构建工具的功能"></a>构建工具的功能</h3><ul><li><strong>代码转换</strong>：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。（开发写的代码有些浏览器无法识别，如ES6语法）</li><li><strong>文件优化</strong>：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。（压缩代码）</li><li><strong>模块合并</strong>：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。</li><li><strong>代码分割</strong>：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li><li><strong>自动刷新</strong>：监听本地源代码的变化，自动重新构建、刷新浏览器。 live reload 自动刷新 / hot reload 热模替换（HMR）（开发环境下修改代码后可以自动刷新浏览器看到最新的效果，可以监视源码的变化）</li><li><strong>代码校验</strong>：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</li></ul><h3 id="模块化打包和非模块化打包思想差异"><a href="#模块化打包和非模块化打包思想差异" class="headerlink" title="模块化打包和非模块化打包思想差异"></a>模块化打包和非模块化打包思想差异</h3><ul><li>非模块化打包：先对文件进行分类（如js/img/css等），然后分别打包</li><li>模块化打包：将所有资源看成模块，而所有的模块之间都是有关系的，项目中的资源是相互关联的节点通过入口js形成一个网(图)的结构。<ul><li>从入口开始递归的查找所有相关联的模块</li><li>找到一个模块(如css)后会找对应的loader，模块文件会进行正则匹配的</li><li>四个核心概念：entry | output | module(loader) | plugins</li><li>loader模块加载器，将非js模块打包成webpack能理解的js模块</li><li>图片处理推荐使用 <code>url-loader</code>，配置选项可以对图片进行限制，小于此限制的会会通过base64处理的</li></ul></li></ul><h3 id="webpack的核心概念"><a href="#webpack的核心概念" class="headerlink" title="webpack的核心概念"></a>webpack的核心概念</h3><ul><li><strong>Entry</strong>：入口，Webpack进行打包的起始点(文件)</li><li><strong>Output</strong>：出口，webpack编译打包生成的bundle(文件)</li><li><strong>Loader</strong>：模块加载(转换)器，将非js模块包装成webpack能理解的js模块<ul><li>（举例：如处理css要用到style-loader/css-loader;处理img使用file-loader/url-loader）</li></ul></li><li><strong>Plugin</strong>：插件，在Webpack构建流程中的特定时机插入具有特定功能的代码<ul><li>（举例：CleanPlugin一开始就会清除指定的文件/夹；</li><li>ExtractTextPlugin用于样式的抽取，用来从js中分离出css并单独打包；</li><li>CopyPlugin复制静态资源；</li><li>webpack.HashedModuleIdsPlugin根据代码内容生成hash作为模块的id(默认是下标)；</li><li>webpack.optimize.CommonsChunkPlugin将第三方模块单独打包</li><li>……） </li></ul></li><li>Module：模块，在 Webpack眼里一切皆模块，默认只识别js文件，如果是其它类型文件利用对应的loader转换为js模块</li><li>Chunk：代码块，一个 Chunk 由多个模块组合而成，最终浏览器执行的是webpack打包生成的chunk文件(bundle同理)</li></ul><h3 id="webpack的其他概念"><a href="#webpack的其他概念" class="headerlink" title="webpack的其他概念"></a>webpack的其他概念</h3><ul><li><img src="http://static.zybuluo.com/MarlonChiu/12qcvudloms3ft00fsxugjtt/webpack%E5%85%B6%E5%AE%83%E6%A6%82%E5%BF%B5_1.png" alt="webpack其它概念_1.png-39.4kB"></li><li><img src="http://static.zybuluo.com/MarlonChiu/sxodezube6trrxitofbx3drp/webpack%E5%85%B6%E5%AE%83%E6%A6%82%E5%BF%B5_2.png" alt="webpack其它概念_2.png-27.8kB"></li></ul><h3 id="webpack-和-gulp-的区别"><a href="#webpack-和-gulp-的区别" class="headerlink" title="webpack 和 gulp 的区别"></a>webpack 和 gulp 的区别</h3><ul><li>webpack 是一种模块化打包工具，主要用于模块化方案，预编译模块的方案；</li><li>gulp 是工具链、构建工具，可以配合各种插件做 js 压缩，css压缩，less 编译替代手工实现自动化工作。</li><li>Grunt/Gulp 更多的是一种工作流；提供集成所有服务的一站式平台； gulp可以用来优化前端工作流程。</li></ul><h2 id="客户端两种存储"><a href="#客户端两种存储" class="headerlink" title="客户端两种存储"></a>客户端两种存储</h2><h3 id="Cookie存储"><a href="#Cookie存储" class="headerlink" title="Cookie存储"></a>Cookie存储</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie是一项很老的技术的，就是因为它老，所以兼容性还是不错的。</span><br><span class="line">使用Cookie作为本地存储优点：兼容性好，缺点：操作繁琐，只能存简单的数据，还会过期，站点设置httponly的话，JS就不无法操作Cookie了。</span><br></pre></td></tr></table></figure><h3 id="Web-Storage存储"><a href="#Web-Storage存储" class="headerlink" title="Web Storage存储"></a>Web Storage存储</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebStorage是HTML5中为WebApplication提供一种存储的API，目前主流的新版本的浏览器都支持，当然IE789你就没有办法了。WebStorage主要分成localStorage和sessionStorage两种。</span><br></pre></td></tr></table></figure><h4 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage是个全局对象，它维护着在页面会话(page session)期间有效的存储空间。只要浏览器开着，页面会话周期就会一直持续。当页面重新载入(reload)或者被恢复(restores)时，页面会话也是一直存在的。每在新标签或者新窗口中打开一个新页面，都会初始化一个新的会话。</span><br></pre></td></tr></table></figure><h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage也是一个全局变量，它的生命周期比sessionStorage长。localStorage和sessionStorage都继承自Storage因此它们的用法相同。</span><br></pre></td></tr></table></figure><h4 id="WebStorage的优点"><a href="#WebStorage的优点" class="headerlink" title="WebStorage的优点"></a>WebStorage的优点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用简单方便，缺点：IE有些版本不支持，不能存复杂的对象，必须先转化成JSON字符串，没有索引搜索效率不高，只能同步读写操作，当写入的数据比较大时可能造成JS引擎堵塞。</span><br></pre></td></tr></table></figure><h4 id="sessionStorage用法和localStorage区别"><a href="#sessionStorage用法和localStorage区别" class="headerlink" title="sessionStorage用法和localStorage区别"></a>sessionStorage用法和localStorage区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">完全一致，差别只在有效期：</span><br><span class="line">sessionStorage在用户结束会话（即关闭浏览器或退出账户时失效）；</span><br><span class="line">localStorage无失效期，用户在清理浏览器缓存的时候会被清除。</span><br></pre></td></tr></table></figure><h3 id="Cookie存储和Web-Storage存储区别"><a href="#Cookie存储和Web-Storage存储区别" class="headerlink" title="Cookie存储和Web Storage存储区别"></a>Cookie存储和Web Storage存储区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">localStorage与sessionStorage作为新时代的产物，相比旧时代的cookie有其巨大的优越性。优越性有三:</span><br><span class="line">    其一在能存储的数据量，cookie最大能存储4kb的数据，而localStorage与sessionStorage最大能存储5Mb，目前各大浏览器支持的标准都是如此；</span><br><span class="line">    </span><br><span class="line">    其二在功能上，cookie只能存储String类型的数据，以往要将用户数据存储在本地，需要将数据拼接成字符串，再存进cookie,取数据的时候同样麻烦，先将整个cookie对象拿到（String对象），再按拼接的规则拆分，再拿需要的数据，存取都很麻烦！</span><br><span class="line">    localStorage与sessionStorage不仅支持传统的String类型，还可以将json对象存储进去,存取数据都方便不少，json的优越性就不赘述，localStorage与sessionStorage无疑更现代化；</span><br><span class="line">    </span><br><span class="line">    其三是cookie是不可或缺的，cookie的作用是与服务器进行交互，作为http规范的一部分而存在；而web storage仅仅是为了在本地‘存储’而生；</span><br><span class="line">    其四在语义层面上，localStorage与sessionStorage语法更优雅、简便。</span><br></pre></td></tr></table></figure><h3 id="存储方式的操作对比演示"><a href="#存储方式的操作对比演示" class="headerlink" title="存储方式的操作对比演示"></a>存储方式的操作对比演示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// cookie的操作</span><br><span class="line">设置cookie: document.cookie = &#x27;key=value&#x27;;</span><br><span class="line">获取cookie: document.cookie;</span><br><span class="line">删除cookie: document.cookie = &quot;key=value;max-age=0&quot;;</span><br><span class="line">设置max-age存储期限: document.cookie = &quot;key=value;max-age=1000&quot;; // 1000秒</span><br><span class="line"></span><br><span class="line">// web storage操作</span><br><span class="line">保存数据 setItem(key,value)</span><br><span class="line">读取数据 getItem(key)</span><br><span class="line">删除单个数据 removeItem(key)</span><br><span class="line">清空全部数据 clearItem()</span><br><span class="line">获取数据索引 key(index)</span><br></pre></td></tr></table></figure><h3 id="cookie-storage-session-关系"><a href="#cookie-storage-session-关系" class="headerlink" title="cookie / storage / session 关系"></a>cookie / storage / session 关系</h3><ul><li>cookie<ul><li>优点：可以解决http无状态问题 </li><li>缺点：<ol><li>与服务器交互的时候有数量和长度限制 每个域名最多20条，长度不能超过4KB  </li><li>安全性问题 容易被人拦截 </li><li>浪费宽带，每次请求新页面，cookie都会被发过去 </li><li>不可以跨域  </li></ol></li></ul></li></ul><ul><li>cookie 和session区别<ul><li>cookie是把数据放在客户的浏览器上，只能存储sting类型</li><li>session数据是放在服务器上，能存储json 类型、sting类型</li><li>session会在一定的时间内保留数据存在服务器上，当访问增多，<br>会比较占你服务器的性能 ，减轻服务器的性能 应当使用cookie</li><li>sessionStorage是当前对话的缓存，浏览器窗口关闭即消失，会话级别的存储</li><li>localStorage持久存在，除非清除浏览器缓存。</li></ul></li></ul><h2 id="数组的一些方法"><a href="#数组的一些方法" class="headerlink" title="数组的一些方法"></a>数组的一些方法</h2><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.先将原数组进行排序</span></span><br><span class="line"><span class="comment">2.检查原数组中的第i个元素 与 结果数组中的最后一个元素是否相同，因为已经排序，所以重复元素会在相邻位置</span></span><br><span class="line"><span class="comment">3.如果不相同，则将该元素存入结果数组中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.sort(); <span class="comment">//先排序</span></span><br><span class="line">    <span class="keyword">var</span> res = [<span class="built_in">this</span>[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">this</span>.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>[i] !== res[res.length - <span class="number">1</span>])&#123;</span><br><span class="line">        res.push(<span class="built_in">this</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.创建一个新的数组存放结果</span></span><br><span class="line"><span class="comment">2.创建一个空对象</span></span><br><span class="line"><span class="comment">3.for循环时，每次取出一个元素与对象进行对比，如果这个元素不重复，</span></span><br><span class="line"><span class="comment">  则把它存放到结果数组中，同时把这个元素的内容作为对象的一个属性，</span></span><br><span class="line"><span class="comment">  并赋值为1，存入到第2步建立的对象中。</span></span><br><span class="line"><span class="comment">说明：至于如何对比，就是每次从原数组中取出一个元素，然后到对象中去访问这个属性，如果能访问到值，则说明重复。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    <span class="keyword">var</span> json = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!json[<span class="built_in">this</span>[i]])&#123;</span><br><span class="line">            res.push(<span class="built_in">this</span>[i]);</span><br><span class="line">            json[<span class="built_in">this</span>[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">112</span>,<span class="number">112</span>,<span class="number">34</span>,<span class="string">&#x27;你好&#x27;</span>,<span class="number">112</span>,<span class="number">112</span>,<span class="number">34</span>,<span class="string">&#x27;你好&#x27;</span>,<span class="string">&#x27;str&#x27;</span>,<span class="string">&#x27;str1&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 方法零</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));  <span class="comment">// Set(7) &#123;1, 7, 3, 4, 11, 2, 0&#125;</span></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.unique1()); <span class="comment">// (7) [0, 1, 11, 2, 3, 4, 7]  按照Unicode排列了</span></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.unique2()); <span class="comment">// (7) [0, 1, 11, 2, 3, 4, 7]</span></span><br></pre></td></tr></table></figure><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(arr) &#123;</span><br><span class="line">  if(arr.length &lt;= 1)&#123;</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line">  // 基准索引（理论上可以任意选取）</span><br><span class="line">  var pivotIndex = parseInt(arr.length/2),</span><br><span class="line">    // 基准值</span><br><span class="line">    pivot = arr.splice(pivotIndex,1)[0],</span><br><span class="line">    leftArr = [],</span><br><span class="line">    rightArr = [],</span><br><span class="line">    length = arr.length;</span><br><span class="line">  // 遍历序列，根据基准拆分为两个子序列</span><br><span class="line">  for (var i = 0; i &lt; length; i++) &#123;</span><br><span class="line">    if(arr[i] &lt; pivot)&#123;</span><br><span class="line">      leftArr.push(arr[i]);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">      rightArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  console.log(pivot); // 输出了三次 3 1 7</span><br><span class="line">  </span><br><span class="line">  // 连接左序列、基准、右序列</span><br><span class="line">  return quickSort(leftArr).concat(pivot, quickSort(rightArr))</span><br><span class="line">&#125;</span><br><span class="line">var demoArr = [8,4,7,2,0,3,1]</span><br><span class="line"></span><br><span class="line">// 方法一</span><br><span class="line">console.log(demoArr.sort()); // (7) [0, 1, 2, 3, 4, 7, 8]</span><br><span class="line">// 方法二</span><br><span class="line">console.log(quickSort(demoArr)) // (7) [0, 1, 2, 3, 4, 7, 8]</span><br></pre></td></tr></table></figure><h2 id="前端WEB-H5性能优化"><a href="#前端WEB-H5性能优化" class="headerlink" title="前端WEB/H5性能优化"></a>前端WEB/H5性能优化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 参考CSDN博客</span><br><span class="line">http://blog.csdn.net/lpf1215/article/details/74315797?locationNum=8&amp;fps=1</span><br></pre></td></tr></table></figure><ul><li>减少http请求，合理设置 HTTP缓存</li><li>使用浏览器缓存</li><li>启用压缩</li><li>CSS Sprites</li><li>LazyLoad Images</li><li>CSS放在页面最上部，javascript放在页面最下面</li><li>异步请求Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容）</li><li>减少cookie传输</li><li>Javascript代码优化</li><li>CSS选择符优化</li><li>CDN加速</li><li>反向代理</li></ul><h2 id="px-em-rem-区别"><a href="#px-em-rem-区别" class="headerlink" title="px em rem 区别"></a>px em rem 区别</h2><ul><li>px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的</li><li>em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸</li><li>rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素</li></ul><h2 id="实现一个jsonp请求"><a href="#实现一个jsonp请求" class="headerlink" title="实现一个jsonp请求"></a>实现一个jsonp请求</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function jsonpCallback(result) &#123;</span><br><span class="line">    // alert(result);  </span><br><span class="line">    for(var i in result) &#123;</span><br><span class="line">        alert(i+&quot;:&quot;+result[i]);// 循环输出a:1,b:2,etc.  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var JSONP = document.createElement(&quot;script&quot;);</span><br><span class="line">JSONP.type = &quot;text/javascript&quot;;</span><br><span class="line">JSONP.src = &quot;http://crossdomain.com/services.php?callback=jsonpCallback&quot;;</span><br><span class="line">document.getElementsByTagName(&quot;head&quot;)[0].appendChild(JSONP);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="原型与原型链分析图例"><a href="#原型与原型链分析图例" class="headerlink" title="原型与原型链分析图例"></a>原型与原型链分析图例</h2><ul><li><p>图例一<br><img src="http://static.zybuluo.com/MarlonChiu/v5fxgw1c326yrmvru8gt4qxa/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90%E5%9B%BE%E4%BE%8B_01.png" alt="原型链分析图例_01.png-35.1kB"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 图例分析说明</span><br></pre></td></tr></table></figure></li><li><p>图例二<br><img src="http://static.zybuluo.com/MarlonChiu/qj4jj2hpkqymby58zjazwl7x/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90%E5%9B%BE%E4%BE%8B_02.png" alt="原型链分析图例_02.png-46.7kB"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 图例分析说明</span><br><span class="line">两个空间：栈和堆。在代码未执行之前，JS引擎就会先加载执行一些内置的代码就。在开始之前就先执行了Object定义（function Object(value)&#123;&#125;），栈空间会有一个Object引用变量，传的是地址值0x123，开辟出一块空间，该空间就是Object函数对象，函数对象上有一个prototype属性，该属性也是引用类型，传递地址值0x234，开辟出一块新的空间，该空间指向Object原型对象，该Object原型对象的原型上包含hasOwnProperty、toString......等一些属性，也就说在代码执行之前第一列的关系已经存在了。</span><br><span class="line"></span><br><span class="line">代码执行function Fn()&#123;&#125;，Fn指向的堆空间中一块区域，地址值为0x345，即Fn函数对象，Fn函数对象有一个prototype属性，该属性也是指向一块地址值0x456，指向Fn原型对象，该对象是一个空对象即&#123;&#125;。这个实例对象的__proto__又会指向Object的函数对象的prototype属性（实例对象的隐式原型等于函数对象的显示原型），地址值也是0x234，也会指向Object原型对象。</span><br><span class="line">代码执行Fn.prototype.test2 则在Fn原型对象上添加test2()方法</span><br><span class="line"></span><br><span class="line">代码执行var fn = new Fn()，fn的地址值为0x567，在堆内存中开辟空间指向Fn实例对象，该对象有隐式原型__proto__，其值是0x456，箭头指向Fn原型对象。Fn实例对象上有个方法test1()。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(Function.prototype === Function.__proto__)  // true</span><br><span class="line">console.log(Object.prototype.__proto__)  // null</span><br><span class="line">console.log(Object.prototype.toString)  // ƒ toString() &#123; [native code] &#125;  Object原型上有toString方法</span><br></pre></td></tr></table></figure></li><li><p>图例三<br><img src="http://static.zybuluo.com/MarlonChiu/2o4q7d8zguhokxee7b4avun1/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90%E5%9B%BE%E4%BE%8B_03.png" alt="原型与原型链分析图例_03.png-129.8kB"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">&#125;</span><br><span class="line">var f1 = new Foo()</span><br><span class="line">var f2 = new Foo()</span><br><span class="line">var o1 = &#123;&#125;</span><br><span class="line">var o2 = &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>图例四<br><img src="http://static.zybuluo.com/MarlonChiu/4shqfy3qe573pw8t7fi70jpz/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%88%86%E6%9E%90.png" alt="函数对象的原型分析.png-60.3kB"></p></li></ul><h2 id="实现类的继承"><a href="#实现类的继承" class="headerlink" title="实现类的继承"></a>实现类的继承</h2><h3 id="原型链的方法"><a href="#原型链的方法" class="headerlink" title="原型链的方法"></a>原型链的方法</h3><ul><li>套路<ol><li>定义父类型构造函数</li><li>给父类型的原型添加方法</li><li>定义子类型的构造函数</li><li>创建父类型的对象赋值给子类型的原型</li><li>将子类型原型的构造属性设置为子类型</li><li>给子类型原型添加方法</li><li>创建子类型的对象: 可以调用父类型的方法</li></ol></li><li>关键<ol><li>子类型的原型为父类型的一个实例对象<br>Child.prototype = new Parent()</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function Parent() &#123;</span><br><span class="line">    this.pProp = &#x27;this Parent prop&#x27;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.showPProp = function () &#123;</span><br><span class="line">    console.log(&#x27;showPProp()&#x27;, this.pProp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child() &#123;</span><br><span class="line">    this.cProp = &#x27;this Child prop&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 让子类原型指向父类型实例</span><br><span class="line">Child.prototype = new Parent()</span><br><span class="line">// 让子类原型对象构造器属性指向子类</span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line"></span><br><span class="line">Child.prototype.showCProp = function () &#123;</span><br><span class="line">    console.log(&#x27;showCProp()&#x27;, this.cProp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var child = new Child()</span><br><span class="line">child.showPProp()</span><br><span class="line">console.log(child.constructor) // ƒ Child() &#123; this.cProp = &#x27;this Child prop&#x27;&#125;</span><br><span class="line">console.log(child)   // Child &#123;cProp: &quot;this Child prop&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="class-类的方式"><a href="#class-类的方式" class="headerlink" title="class 类的方式"></a>class 类的方式</h3><ul><li>通过class定义类/实现类的继承</li><li>在类中通过constructor定义构造方法</li><li>通过new来创建类的实例</li><li>通过extends来实现类的继承</li><li>通过super调用父类的构造方法</li><li>重写从父类中继承的一般方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 用class定义一个Person类</span><br><span class="line">class Person&#123;</span><br><span class="line">    constructor (name, age)&#123;   // 类的构造方法</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    showName ()&#123;   // 类的一般方法</span><br><span class="line">        console.log(this.name, this.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p1 = new Person(&quot;TOM&quot;, 18);</span><br><span class="line">console.log(p1.name);</span><br><span class="line">p1.showName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 定义一个Student 继承Person</span><br><span class="line">class Student extends Person &#123;  // 定义的Student类继承自Person类</span><br><span class="line">    constructor (name, age, salary)&#123;</span><br><span class="line">        super(name,age);  // 通过super调用父类的构造方法</span><br><span class="line">        this.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    showName (name, age, salary)&#123;</span><br><span class="line">        console.log(this.name, this.age, this.salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let s1 = new Student(&quot;MARLON&quot;, 26, 17000);</span><br><span class="line">console.log(s1.name);</span><br><span class="line">s1.showName();</span><br></pre></td></tr></table></figure><h3 id="Object-create-方法"><a href="#Object-create-方法" class="headerlink" title="Object.create()方法"></a>Object.create()方法</h3><ul><li><code>Object.create(prototype, [descriptors])</code><ul><li>作用: 以指定对象为原型创建新的对象</li><li>为新的对象指定新的属性, 并对属性进行描述<br>value : 指定值<br>writable : 标识当前属性值是否是可修改的, 默认为 false</li></ul></li><li>用法演示<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//  Object.create(prototype, [descriptors])</span><br><span class="line">var obj = &#123;n:11&#125;;</span><br><span class="line">var obj2 = Object.create(obj);</span><br><span class="line">console.log(obj2, obj2.n);   // &#123;&#125; 11</span><br><span class="line">var obj3 = Object.create(obj,&#123;</span><br><span class="line">    m: &#123;</span><br><span class="line">        value: &quot;asd&quot;,</span><br><span class="line">        writable: false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">obj3.m = 456;</span><br><span class="line">console.log(obj3.m);  // asd</span><br></pre></td></tr></table></figure></li></ul><h3 id="原型链-借用构造函数的组合继承"><a href="#原型链-借用构造函数的组合继承" class="headerlink" title="原型链 + 借用构造函数的组合继承"></a>原型链 + 借用构造函数的组合继承</h3><ul><li>利用原型链实现对父类型对象的方法继承</li><li>利用call()借用父类型构建函数初始化相同属性</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = function (name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line">function Student(name, age, price) &#123; // 身价</span><br><span class="line">    Person.call(this, name, age)  // 相当于: this.Person(name, age)</span><br><span class="line">    this.price = price</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = new Person()</span><br><span class="line">Student.prototype.constructor = Student</span><br><span class="line"></span><br><span class="line">Student.prototype.setPrice = function (price) &#123;</span><br><span class="line">    this.price = price</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var s = new Student(&#x27;Jack&#x27;, 21, 13000)</span><br><span class="line">s.setName(&#x27;Bob&#x27;)</span><br><span class="line">s.setPrice(14000)</span><br><span class="line">console.log(s.name, s.age, s.price)</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用前端面试参考总结&quot;&gt;&lt;a href=&quot;#常用前端面试参考总结&quot; class=&quot;headerlink&quot; title=&quot;常用前端面试参考总结&quot;&gt;&lt;/a&gt;常用前端面试参考总结&lt;/h1&gt;&lt;p&gt;标签（空格分隔）： Summarize Interview&lt;/p&gt;
&lt;hr&gt;</summary>
      
    
    
    
    
    <category term="面试" scheme="http://mengjie.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>没有仪式感的人生，永远都是灰头土脸</title>
    <link href="http://mengjie.com/2020/03/18/sense-of-ritual/"/>
    <id>http://mengjie.com/2020/03/18/sense-of-ritual/</id>
    <published>2020-03-17T16:18:11.000Z</published>
    <updated>2021-07-19T03:07:36.489Z</updated>
    
    <content type="html"><![CDATA[<p>　　村上春树说：仪式是一件很重要的事情。</p>  <span id="more"></span><p>　　喝牛奶时，你特意替我擦掉嘴边的白泡沫，是仪式。<br>　　出门时，你特意把我的领带给调整好，是仪式。<br>　　走路时，你特意蹲下来帮我系好鞋带，是仪式。<br>　　逛街时，你特意记得我喜欢的衣服买来送给我，是仪式。<br>　　别人生日你切蛋糕下去的第一刀是仪式，拆掉新书的塑料包装也是仪式。<br>　　其实仪式就是把本来单调普通的事情，变得不一样。<br>　　仪式是让我们对所在意的事情，怀有敬畏。</p><p>　　01. 婚姻里的仪式感。</p><p>　　普华永道的老总唐徽，她曾说结婚十几年了，她雷打不动的规定就是每周五和先生约会。她老公是一个喜欢吃意大利餐的美国男人，所以他们每周五晚餐都会坐在高档的意大利餐厅享受美食。<br>　　她说仪式感是婚姻中不可或缺的元素，因为它会时时刻刻提醒夫妻俩人，必须认真、敬畏得去经营婚姻。<br>　　朋友A是一个婚姻心理咨询师，他和说曾说过一个案例。丈夫和妻子结婚8年多了，每次遇到重要的节日时，丈夫提议出去庆祝一下，而妻子每次都说要花多少多少钱，要节省钱就不去了，结婚8年竟然难忘的日子没有几个。<br>　　后来他们离婚了，丈夫遇到节日都会欢欢喜喜和新的伴侣出去庆祝，在新的婚姻里如鱼得水。可是这时，前妻却无法释怀了，生活一直过得不好，常常跑心理咨询室解决心理问题。<br>　　仪式感是获得安全感的源泉之一。<br>　　很多女孩子描述恋爱细节都会这样说：我记得那天我生日，他特地来看我，陪我在哪里做了什么，送了我什么礼物，对我说了什么话，他对我很用心，我觉得很幸福。<br>　　从感性的角度，在某事某刻特别用心做某事，带有仪式感，让人刻骨铭心。<br>　　女孩子都向往一场浪漫的婚礼，很多细节都会有特别的要求，在那个仪式上彼此说着爱的誓言，一生中记忆最深的莫过于此吧。<br>　　因为有仪式感，你才记得那天的阳光和白云，还有他身旁的微风和眼中的光芒。</p><p>　　02. 生活里的仪式感。</p><p>　　记得一个牛津大学毕业的著名学者说过他上学的事情：在他上高中的时候，父亲每次接他、送他的前一天，都会认真去洗一次车，而且要洗得非常干净。<br>　　父亲的洗车让他觉得上学有了仪式感，也特别用心。<br>　　在我家里有一个不成文的规定，就是：一家人吃饭必须围着桌子一起吃饭，不能看电视，不能一个个东奔西跑。<br>　　母亲常说：民以食为天，对于食物我们应该怀有敬畏心理，人家老外吃饭前还要祷告咧，家的意思不就是一家人常常在一起吃饭么！<br>　　家里不管是哪个人过生日，父母必将准备丰盛的菜肴，一家人都要穿上最好的衣服，来庆祝这个特别的节日，像是参加一个重大的仪式。<br>　　母亲还有一个歪理：连吃饭都不能好好聚在一起的家庭，走不远。<br>　　于是我开始观察了几个街坊邻居，居然还真的是母亲说的那样。就拿我家的邻居来说吧，妇女做完饭就会端着饭跑到外面去和别人聊天，子女端着饭边看电视看吃，丈夫端着饭坐在门口台阶上。<br>　　果然，没几日妇女就和别的男人跑了，过了一段时间又回来了。于是野男人和家里的男人引发了战争，女儿写信给母亲要断绝母女关系。<br>　　从此这个家庭一地鸡毛，狼狈不堪，争吵的响声常常传到我家里。<br>　　一家人一起认真吃饭，这是我们家里的仪式感，每当我想家的时候，出现最多的画面就是一家人开开心心吃饭的场景。<br>　　第三季《唐顿庄园》中有一次因为炉子坏了，唐顿第一次放弃了繁文缛节。他和别人谈论此事时，显得对生活中的仪式感非常着迷。<br>　　他说：“你厌倦了生活中的格调，就是厌倦了生活。”</p><p>　　我们成长、我们毕业、我们离开，我们需要一个个的仪式来对过去的自己告别，然后重新开始新的生活。<br>　　王阳明名言：你未看此花时，此花与汝心同归于寂。你来看此花时，则此花颜色一时明白起来。<br>　　一切繁杂里才能照见简单，一切世俗中才能照见脱俗，一切喧闹中才能照见宁静。在如今缺乏仪式感的国度里，我们会失去很多觉察的机会。<br>　　不敬天地，不敬鬼神，觉察自然也会离我们越来越远。<br>　　仪式感之所以重要，是通过不断暗示自己，强化精神，能够让我们继续坚持枯燥的生活，在遇到变故或者彷徨无助的时候，带来希望。</p><p>   文/肖卓</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;　　村上春树说：仪式是一件很重要的事情。&lt;/p&gt;</summary>
    
    
    
    
    <category term="人生" scheme="http://mengjie.com/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
</feed>
