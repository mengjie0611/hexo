<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>简简单单</title>
  
  <subtitle>写代码</subtitle>
  <link href="https://mengjie0611.github.io/atom.xml" rel="self"/>
  
  <link href="https://mengjie0611.github.io/"/>
  <updated>2022-07-26T02:18:39.141Z</updated>
  <id>https://mengjie0611.github.io/</id>
  
  <author>
    <name>Jie Meng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端面试题总结</title>
    <link href="https://mengjie0611.github.io/posts/6427d5c7.html"/>
    <id>https://mengjie0611.github.io/posts/6427d5c7.html</id>
    <published>2022-07-26T00:00:00.000Z</published>
    <updated>2022-07-26T02:18:39.141Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端面试题总结"><a href="#前端面试题总结" class="headerlink" title="前端面试题总结"></a>前端面试题总结</h1><p>标签（空格分隔）： Summarize Interview</p><hr><h2 id="Vue-的响应式原理中-Object-defineProperty-有什么缺陷？为什么在-Vue3-0-采用了-Proxy，抛弃了-Object-defineProperty？"><a href="#Vue-的响应式原理中-Object-defineProperty-有什么缺陷？为什么在-Vue3-0-采用了-Proxy，抛弃了-Object-defineProperty？" class="headerlink" title="Vue 的响应式原理中 Object.defineProperty 有什么缺陷？为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？"></a>Vue 的响应式原理中 Object.defineProperty 有什么缺陷？为什么在 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty？</h2><ul><li>object.defineProperty<ul><li>数组的位置不固定，数量多变，一般对象的key映射的value是固定的，但如果数据删除了某个元素或者新增了某个元素就会导致整体的index和value错位，会触发多次set</li><li>数组的元素可能非常多，每个元素劫持有一定的浪费</li><li>vue将数组的7个方法进行了重写</li><li>object.definedProperty必须要预先劫持属性，后添加的属性也必须要手动再次劫持</li></ul></li><li>Proxy<ul><li>Proxy代理了整个对象，不需要预先劫持属性，在获取或者修改的时候会通过get和set通知，新增属性总是能被捕获到</li></ul></li></ul><h2 id="函数节流防抖"><a href="#函数节流防抖" class="headerlink" title="函数节流防抖"></a>函数节流防抖</h2><ul><li>节流throttle<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> throttle = <span class="function">(<span class="params">fn,delay</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> latstime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">if</span>(now - latstime &gt;= delay) &#123;</span><br><span class="line">         fn.apply(<span class="built_in">this</span>,<span class="built_in">arguments</span>)</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>防抖 debounce<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> debounce = <span class="function">(<span class="params">fn,delay</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">            <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        &#125;;</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(fn,delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="css盒子模型"><a href="#css盒子模型" class="headerlink" title="css盒子模型"></a>css盒子模型</h2>盒模型是有两种标准一种是标准模型，一种是ie模型</li><li>ie盒模型（怪异盒子）<br>width/height = content + border + padding;</li><li>标准盒模型<br>width/height = content;</li></ul><p>无论是标准盒子模型还是IE盒子模型，总宽度都是一样的<br>标准盒子模型 总宽度= margin + padding + border + width<br>IE盒子模型 总宽度 = margin + width（ width = content + padding + border）<br>区别是IE盒子模型的width包含了padding和border</p><h2 id="vue响应式原理"><a href="#vue响应式原理" class="headerlink" title="vue响应式原理"></a>vue响应式原理</h2><ul><li>双向绑定是哪双向？分别是怎么做的？<br>双向指的是视图层view和数据层model，数据层model发生改变对应的视图层更新，视图层view发生变化，数据城model也会更新数据<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> updataView = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;updataView&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> defineReactive = <span class="function">(<span class="params">target,key,value</span>) =&gt;</span> &#123;</span><br><span class="line">  observe(value);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;get&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span> &#123;</span><br><span class="line">      observe(value);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;set&#x27;</span>, newValue);</span><br><span class="line">      <span class="keyword">if</span>(value !== newValue) &#123;</span><br><span class="line">      value = newValue;</span><br><span class="line">      updataView();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> observe = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ( <span class="keyword">typeof</span> data === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">    defineReactive(data,key,data[key]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;111&#x27;</span>,</span><br><span class="line"><span class="attr">age</span>: <span class="number">17</span>,</span><br><span class="line"><span class="attr">hobby</span>: &#123;</span><br><span class="line"><span class="attr">one</span>: <span class="string">&#x27;羽毛球&#x27;</span>,</span><br><span class="line"><span class="attr">two</span>: <span class="string">&#x27;游泳&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">observe(data);</span><br><span class="line">data.hobby.one = <span class="string">&quot;篮球&quot;</span></span><br><span class="line">data.name = &#123;</span><br><span class="line"><span class="attr">cn</span>:<span class="string">&#x27;111&#x27;</span>,</span><br><span class="line"><span class="attr">en</span>:<span class="string">&#x27;222&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">data.age = &#123;<span class="attr">num</span>:<span class="number">18</span>&#125;</span><br><span class="line">data.age.num = <span class="number">20</span></span><br></pre></td></tr></table></figure></li><li>发布订阅模式是什么样的？实现原理？</li><li>数据劫持是怎么劫持的？object.dedefineProperty代理对象有什么问题？能代理数组嘛？数组是怎么劫持的?getset里都做了什么？</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前端面试题总结&quot;&gt;&lt;a href=&quot;#前端面试题总结&quot; class=&quot;headerlink&quot; title=&quot;前端面试题总结&quot;&gt;&lt;/a&gt;前端面试题总结&lt;/h1&gt;&lt;p&gt;标签（空格分隔）： Summarize Interview&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Vue</summary>
      
    
    
    
    
    <category term="面试" scheme="https://mengjie0611.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>mac生成ssh公匙,配置github SSH公钥连接</title>
    <link href="https://mengjie0611.github.io/posts/undefined.html"/>
    <id>https://mengjie0611.github.io/posts/undefined.html</id>
    <published>2022-06-18T00:00:00.000Z</published>
    <updated>2022-06-29T08:54:07.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mac生成ssh公匙"><a href="#mac生成ssh公匙" class="headerlink" title="mac生成ssh公匙"></a>mac生成ssh公匙</h2><p>  首先在mac下进入~/.ssh,查看是否已经有公匙。<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">ls</span><br><span class="line"># known_hosts</span><br></pre></td></tr></table></figure><br>  现只有一个known_hosts，那我们就建一个ssh公钥，继续输入以下指令创建ssh公钥：<br>  ssh-keygen<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  .ssh ssh-keygen</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/Users/xxx/.ssh/id_rsa):</span><br></pre></td></tr></table></figure><br>  首先会让你输入公钥存储文件，输入默认的就行（/Users/你的电脑用户名/.ssh/id_rsa）。然后会输入公钥使用密码，输入两次，可以直接回车不设置。（建议直接回车，设置后后面提交代码也很麻烦，每次都要验证输入以下）。 创建完成后，再次输入ls查看目录下是否已经生成了公钥，确认有后，使用命令cat id_rsa.pub查看公钥<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure><br>  从ssh-rsa开始一直到.local都是ssh公钥，复制出来，一会要到github中创建shh连接使用</p><h2 id="github配置生成的ssh公匙"><a href="#github配置生成的ssh公匙" class="headerlink" title="github配置生成的ssh公匙"></a>github配置生成的ssh公匙</h2><p>  进行github ssh连接配置，首先进入github，然后点击个人头像后，选择Settings<br>  然后再点击SSH and GPG，再点击 New SSH key<br>  有两个参数设置，title可以随便写，key就是我们前面复制的SSH公钥（id_rsa.pub文件内容）。<br>  粘贴好后，点击 Add SSH Key即可</p><h2 id="验证测试ssh公钥配置是否成功"><a href="#验证测试ssh公钥配置是否成功" class="headerlink" title="验证测试ssh公钥配置是否成功"></a>验证测试ssh公钥配置是否成功</h2>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>  如果创建ssh时设置了密码，需要先输入密码，然后根据提示输入yes，同意连接，显示结果为下面这样则表示连接成功<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi xxx! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><br>  如果之前仓库关联模式是http则需要变更为ssh，进入本地对应项目，执行以下语句<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin 对应的SSH</span><br></pre></td></tr></table></figure><br>  然后就生成ssh配置github ssh公匙成功了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;mac生成ssh公匙&quot;&gt;&lt;a href=&quot;#mac生成ssh公匙&quot; class=&quot;headerlink&quot; title=&quot;mac生成ssh公匙&quot;&gt;&lt;/a&gt;mac生成ssh公匙&lt;/h2&gt;&lt;p&gt;  首先在mac下进入~/.ssh,查看是否已经有公匙。&lt;br&gt;  &lt;fig</summary>
      
    
    
    
    
    <category term="git" scheme="https://mengjie0611.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>H5</title>
    <link href="https://mengjie0611.github.io/posts/undefined.html"/>
    <id>https://mengjie0611.github.io/posts/undefined.html</id>
    <published>2021-10-13T00:00:00.000Z</published>
    <updated>2022-01-12T07:47:15.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS跳转到app-store内应用下载页面"><a href="#JS跳转到app-store内应用下载页面" class="headerlink" title="JS跳转到app store内应用下载页面"></a>JS跳转到app store内应用下载页面</h1><p>跳转到应用商店:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(https)|(itms-apps)://itunes.apple.com/app/id&#123;appID&#125;</span><br></pre></td></tr></table></figure><p>跳转到撰写评价：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(https)|(itms-apps)://itunes.apple.com/app/id&#123;appID&#125;?action=write-review</span><br></pre></td></tr></table></figure><p>跳转到查看评价：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(https)|(itms-apps)://itunes.apple.com/app/viewContentsUserReviews?id=&#123;appID&#125;</span><br></pre></td></tr></table></figure><p>手机端和pc端均可适用。</p><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.location.href = &#x27;itms-apps://itunes.apple.com/app/id414478124?action=write-review&#x27;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JS跳转到app-store内应用下载页面&quot;&gt;&lt;a href=&quot;#JS跳转到app-store内应用下载页面&quot; class=&quot;headerlink&quot; title=&quot;JS跳转到app store内应用下载页面&quot;&gt;&lt;/a&gt;JS跳转到app store内应用下载页面&lt;/</summary>
      
    
    
    
    
    <category term="面试" scheme="https://mengjie0611.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>butterfly博客主题的详细配置</title>
    <link href="https://mengjie0611.github.io/posts/undefined.html"/>
    <id>https://mengjie0611.github.io/posts/undefined.html</id>
    <published>2021-07-19T03:14:48.355Z</published>
    <updated>2021-07-19T03:22:01.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><h3 id="1-1-安装主题"><a href="#1-1-安装主题" class="headerlink" title="1.1 安装主题"></a>1.1 安装主题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><h3 id="1-2-启用主题"><a href="#1-2-启用主题" class="headerlink" title="1.2 启用主题"></a>1.2 启用主题</h3><p>打开根<code>_config.yml</code>配置文件，找到theme字段，将其值改为butterfly(先确认主题文件夹名称是否为butterfly)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 根 _config.yml</span><br><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure><p>修改后在根目录文件夹下执行以下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</span><br></pre></td></tr></table></figure><h3 id="1-4-验证"><a href="#1-4-验证" class="headerlink" title="1.4 验证"></a>1.4 验证</h3><p>首先启动 Hexo 本地站点，并开启调试模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s --debug</span><br></pre></td></tr></table></figure><p>在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</span><br><span class="line">此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。</span><br></pre></td></tr></table></figure><h3 id="1-5-更新主题"><a href="#1-5-更新主题" class="headerlink" title="1.5 更新主题"></a>1.5 更新主题</h3><p>今后若主题添加了新功能正是您需要的，您可以直接git pull来更新主题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd themes/butterfly</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><h3 id="2-1-设置语言"><a href="#2-1-设置语言" class="headerlink" title="2.1 设置语言"></a>2.1 设置语言</h3><p>该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在根_config.yml配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 根 _config.yml</span><br><span class="line">language: zh-CN</span><br></pre></td></tr></table></figure><h3 id="2-2-设置菜单"><a href="#2-2-设置菜单" class="headerlink" title="2.2 设置菜单"></a>2.2 设置菜单</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 打开主题找到， themes/butterfly/_config.yml</span><br><span class="line">menu:</span><br><span class="line">  - page: home</span><br><span class="line">    directory: .</span><br><span class="line">    icon: fa-home</span><br><span class="line">  - page: archive</span><br><span class="line">    directory: archives/</span><br><span class="line">    icon: fa-archive</span><br><span class="line">  # - page: about</span><br><span class="line">  #   directory: about/</span><br><span class="line">  #   icon: fa-user</span><br><span class="line">  - page: rss</span><br><span class="line">    directory: atom.xml</span><br><span class="line">    icon: fa-rss</span><br></pre></td></tr></table></figure><h4 id="2-2-1-添加about页面"><a href="#2-2-1-添加about页面" class="headerlink" title="2.2.1 添加about页面"></a>2.2.1 添加about页面</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：</span><br><span class="line">hexo new page &#x27;about&#x27;</span><br><span class="line"></span><br><span class="line">// 打开主题找到， themes/butterfly/_config.yml</span><br><span class="line"># About page</span><br><span class="line">about:</span><br><span class="line">  photo_url: ## 头像的链接地址 https://avatars0.githubusercontent.com/u/29102045?s=460&amp;v=4</span><br><span class="line">  items:</span><br><span class="line">  - label: email</span><br><span class="line">    url: ## 个人邮箱</span><br><span class="line">    title: ## 邮箱用户名</span><br><span class="line">  - label: github</span><br><span class="line">    url: ## github主页</span><br><span class="line">    title: ## github用户名</span><br><span class="line">  - label: weibo</span><br><span class="line">    url: ## weibo主页</span><br><span class="line">    title: ## weibo用户名</span><br><span class="line"># - label: twitter</span><br><span class="line">#   url: </span><br><span class="line">#   title:</span><br><span class="line"># - label: facebook</span><br><span class="line">#   url:</span><br><span class="line">#   title:</span><br></pre></td></tr></table></figure><h4 id="2-2-2-安装-RSS-订阅-和-sitemap-网站地图-插件"><a href="#2-2-2-安装-RSS-订阅-和-sitemap-网站地图-插件" class="headerlink" title="2.2.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件"></a>2.2.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件</h4><ul><li><p>在根目录下打开命令行窗口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure></li><li><p>添加主题_config.yml配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//  themes/butterfly/_config.yml </span><br><span class="line"></span><br><span class="line">Plugins:</span><br><span class="line">  hexo-generator-feed</span><br><span class="line">  hexo-generator-sitemap</span><br><span class="line">  hexo-generator-baidu-sitemap</span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-3-添加本地搜索"><a href="#2-3-添加本地搜索" class="headerlink" title="2.3 添加本地搜索"></a>2.3 添加本地搜索</h3><p>安装插件<code>hexo-generator-json-content</code>来创建JSON数据文件：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-json-content@2.2.0 --save</span><br></pre></td></tr></table></figure><p>然后在根_config.yml添加配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 根_config.yml</span><br><span class="line"></span><br><span class="line">jsonContent:</span><br><span class="line">  meta: false</span><br><span class="line">  pages: false</span><br><span class="line">  posts:</span><br><span class="line">    title: true</span><br><span class="line">    date: true</span><br><span class="line">    path: true</span><br><span class="line">    text: true</span><br><span class="line">    raw: false</span><br><span class="line">    content: false</span><br><span class="line">    slug: false</span><br><span class="line">    updated: false</span><br><span class="line">    comments: false</span><br><span class="line">    link: false</span><br><span class="line">    permalink: false</span><br><span class="line">    excerpt: false</span><br><span class="line">    categories: false</span><br><span class="line">    tags: true</span><br></pre></td></tr></table></figure><p>最后在主题themes/butterfly/_config.yml添加配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//  themes/butterfly/_config.yml   </span><br><span class="line">local_search: true</span><br></pre></td></tr></table></figure><h3 id="2-4-其他配置"><a href="#2-4-其他配置" class="headerlink" title="2.4 其他配置"></a>2.4 其他配置</h3><p>主题themes/butterfly/_config.yml添加其他配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//  themes/butterfly/_config.yml  </span><br><span class="line">// show_category_count——是否显示分类下的文章数。</span><br><span class="line">// widgets_on_small_screens——是否在小屏显示侧边栏，若true,则侧边栏挂件将显示在底部。</span><br><span class="line"></span><br><span class="line">show_category_count: true </span><br><span class="line">widgets_on_small_screens: true</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-安装&quot;&gt;&lt;a href=&quot;#1-安装&quot; class=&quot;headerlink&quot; title=&quot;1. 安装&quot;&gt;&lt;/a&gt;1. 安装&lt;/h2&gt;&lt;h3 id=&quot;1-1-安装主题&quot;&gt;&lt;a href=&quot;#1-1-安装主题&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="Hexo" scheme="https://mengjie0611.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的异步编程解决方案</title>
    <link href="https://mengjie0611.github.io/posts/undefined.html"/>
    <id>https://mengjie0611.github.io/posts/undefined.html</id>
    <published>2021-03-18T09:05:05.000Z</published>
    <updated>2021-07-19T05:53:56.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Generator-函数"><a href="#Generator-函数" class="headerlink" title="Generator 函数"></a>Generator 函数</h2><p>学习指导：<a href="http://es6.ruanyifeng.com/#docs/generator">阮一峰ES6 – Generator函数</a></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>语法上：Generator 函数是一个状态机，封装了多个内部状态；执行 Generator 函数会返回一个遍历器对象。也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</li><li>形式上：Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号<code>*</code>；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&#x27;world&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;ending&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world）</span></span><br><span class="line"><span class="comment">// 即该函数有三个状态：hello，world 和 return 语句（结束执行）。</span></span><br></pre></td></tr></table></figure><ul><li>调用Generator函数，返回一个遍历器对象，代表Generator函数的内部指针。以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value和done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上述函数下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。</span></span><br><span class="line"><span class="comment">// 即每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，</span></span><br><span class="line"><span class="comment">// 直到遇到下一个yield表达式（或return语句）为止。</span></span><br><span class="line"><span class="comment">// 换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解释说明：</span></span><br><span class="line"><span class="comment">上面代码一共调用了四次next方法。</span></span><br><span class="line"><span class="comment">第一次调用，Generator 函数开始执行，直到遇到第一个yield表达式为止。</span></span><br><span class="line"><span class="comment">next方法返回一个对象，它的value属性就是当前yield表达式的值hello，</span></span><br><span class="line"><span class="comment">done属性的值false，表示遍历还没有结束。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。</span></span><br><span class="line"><span class="comment">next方法返回的对象的value属性就是当前yield表达式的值world，</span></span><br><span class="line"><span class="comment">done属性的值false，表示遍历还没有结束。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句</span></span><br><span class="line"><span class="comment">（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，</span></span><br><span class="line"><span class="comment">就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），</span></span><br><span class="line"><span class="comment">done属性的值true，表示遍历已经结束。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第四次调用，此时 Generator 函数已经运行完毕，</span></span><br><span class="line"><span class="comment">next方法返回对象的value属性为undefined，done属性为true。</span></span><br><span class="line"><span class="comment">以后再调用next方法，返回的都是这个值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="yield-表达式说明"><a href="#yield-表达式说明" class="headerlink" title="yield 表达式说明"></a>yield 表达式说明</h3><ul><li>Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。</li><li>遍历器对象的next方法的运行逻辑如下。<ul><li>遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</li><li>下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。</li><li>如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</li><li>如果该函数没有return语句，则返回的对象的 value 属性值为 undefined。</li></ul></li><li>需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">123</span> + <span class="number">456</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值.</span></span><br></pre></td></tr></table></figure><h3 id="yield-表达式语法"><a href="#yield-表达式语法" class="headerlink" title="yield 表达式语法"></a>yield 表达式语法</h3><ul><li>yield表达式只能用在 Generator 函数里面，用在其他地方都会报错</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected number</span></span><br></pre></td></tr></table></figure><ul><li>yield表达式如果用在另一个表达式之中，必须放在圆括号里面</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + <span class="keyword">yield</span>); <span class="comment">// SyntaxError</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + <span class="keyword">yield</span> <span class="number">123</span>); <span class="comment">// SyntaxError</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + (<span class="keyword">yield</span>)); <span class="comment">// OK</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello&#x27;</span> + (<span class="keyword">yield</span> <span class="number">123</span>)); <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  foo(<span class="keyword">yield</span> <span class="string">&#x27;a&#x27;</span>, <span class="keyword">yield</span> <span class="string">&#x27;b&#x27;</span>); <span class="comment">// OK</span></span><br><span class="line">  <span class="keyword">let</span> input = <span class="keyword">yield</span>; <span class="comment">// OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用法实例讲解"><a href="#用法实例讲解" class="headerlink" title="用法实例讲解"></a>用法实例讲解</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flat = <span class="function"><span class="keyword">function</span>* (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* flat(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;  <span class="comment">// 错误用法</span></span><br><span class="line"><span class="comment">// forEach方法的参数是一个普通函数，但是在里面使用了yield表达式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一种修改方法是改用for循环。</span></span><br><span class="line"><span class="keyword">var</span> flat = <span class="function"><span class="keyword">function</span>* (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = a.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> item = a[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* flat(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> f <span class="keyword">of</span> flat(arr)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5, 6</span></span><br></pre></td></tr></table></figure><h3 id="yield表达式与return语句"><a href="#yield表达式与return语句" class="headerlink" title="yield表达式与return语句"></a>yield表达式与return语句</h3><ul><li>yield 表达式与return 语句既有相似之处，也有区别。  </li><li>相似之处在于，都能返回紧跟在语句后面的那个表达式的值。  </li><li>区别在于每次遇到<code>yield</code>，函数暂停执行，下一次再从该位置继续向后执行，而<code>return</code>语句不具备位置记忆的功能。 </li><li>一个函数里面，<strong>只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式</strong>。  </li><li>正常函数只能返回一个值，因为只能执行一次return；  </li><li>Generator 函数可以返回一系列的值，因为可以有任意多个<code>yield</code>。  </li><li>从另一个角度看，也可以说 Generator 生成了一系列的值。  </li></ul><h3 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a>next 方法的参数</h3><ul><li><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> reset = <span class="keyword">yield</span> i;</span><br><span class="line">    <span class="keyword">if</span>(reset) &#123; i = -<span class="number">1</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f();</span><br><span class="line"></span><br><span class="line">g.next() <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next(<span class="literal">true</span>) <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面代码先定义了一个可以无限运行的 Generator 函数f，</span></span><br><span class="line"><span class="comment">如果next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，</span></span><br><span class="line"><span class="comment">下一轮循环就会从-1开始递增。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。</li><li>通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。  </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">var</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> (x + y + z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = foo(<span class="number">5</span>);</span><br><span class="line">a.next() <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line">a.next() <span class="comment">// Object&#123;value:NaN, done:true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = foo(<span class="number">5</span>);</span><br><span class="line">b.next() <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">12</span>) <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line">b.next(<span class="number">13</span>) <span class="comment">// &#123; value:42, done:true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面代码中，第二次运行next方法的时候不带参数，导致 y 的值等于2 * undefined（即NaN），</span></span><br><span class="line"><span class="comment">除以 3 以后还是NaN，因此返回对象的value属性也等于NaN。</span></span><br><span class="line"><span class="comment">第三次运行Next方法的时候不带参数，所以z等于undefined，</span></span><br><span class="line"><span class="comment">返回对象的value属性等于5 + NaN + undefined，即NaN。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果向next方法提供参数，返回结果就完全不一样了。</span></span><br><span class="line"><span class="comment">上面代码第一次调用b的next方法时，返回x+1的值6；</span></span><br><span class="line"><span class="comment">第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；</span></span><br><span class="line"><span class="comment">第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，</span></span><br><span class="line"><span class="comment">这时x等于5，y等于24，所以return语句的值等于42。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。  </li></ul><h3 id="for…of-循环"><a href="#for…of-循环" class="headerlink" title="for…of 循环"></a>for…of 循环</h3><ul><li><ol><li>for…of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。  </li></ol></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面代码使用for...of循环，依次显示 5 个yield表达式的值。</span></span><br><span class="line"><span class="comment">// 这里需要注意，一旦next方法的返回对象的done属性为true，</span></span><br><span class="line"><span class="comment">// for...of循环就会中止，且不包含该返回对象，</span></span><br><span class="line"><span class="comment">// 所以上面代码的return语句返回的6，不包括在for...of循环之中。</span></span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">* 2)利用`</span><span class="keyword">for</span>...of<span class="string">`循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用for...of循环，通过 Generator 函数为它加上这个接口，就可以用了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">objectEntries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> propKeys = <span class="built_in">Reflect</span>.ownKeys(obj);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [propKey, obj[propKey]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jane = &#123; <span class="attr">first</span>: <span class="string">&#x27;Jane&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;Doe&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> objectEntries(jane)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first: Jane</span></span><br><span class="line"><span class="comment">// last: Doe</span></span><br></pre></td></tr></table></figure><ul><li>3)加上遍历器接口的另一种写法是，将 Generator 函数加到对象的<code>Symbol.iterator</code>属性上面</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">objectEntries</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> propKeys = <span class="built_in">Object</span>.keys(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> propKey <span class="keyword">of</span> propKeys) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [propKey, <span class="built_in">this</span>[propKey]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> jane = &#123; <span class="attr">first</span>: <span class="string">&#x27;Jane&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;Doe&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">jane[<span class="built_in">Symbol</span>.iterator] = objectEntries;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> jane) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first: Jane</span></span><br><span class="line"><span class="comment">// last: Doe</span></span><br></pre></td></tr></table></figure><ul><li>4)除了for…of循环以外，<code>扩展运算符（...）</code>、<code>解构赋值</code>和<code>Array.from</code>方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。  </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展运算符</span></span><br><span class="line">[...numbers()] <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from 方法</span></span><br><span class="line"><span class="built_in">Array</span>.from(numbers()) <span class="comment">// [1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [x, y] = numbers();</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> numbers()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="Generator函数的异步操作"><a href="#Generator函数的异步操作" class="headerlink" title="Generator函数的异步操作"></a>Generator函数的异步操作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">asyncJob</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">yield</span> readFile(fileA);</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。<br>也就是说，yield命令是异步两个阶段的分界线。<br>协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p><p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。<br>整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。</p><h3 id="异步任务的封装"><a href="#异步任务的封装" class="headerlink" title="异步任务的封装"></a>异步任务的封装</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = <span class="built_in">require</span>(<span class="string">&#x27;node-fetch&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url = <span class="string">&#x27;https://api.github.com/users/github&#x27;</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="keyword">yield</span> fetch(url);</span><br><span class="line">  <span class="built_in">console</span>.log(result.bio);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。</span></span><br><span class="line"><span class="comment">// 就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行上述代码</span></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> result = g.next();</span><br><span class="line"></span><br><span class="line">result.value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> data.json();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  g.next(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先执行 Generator 函数，获取遍历器对象，然后使用next方法（第二行），执行异步任务的第一阶段。</span></span><br><span class="line"><span class="comment">// 由于Fetch模块返回的是一个 Promise 对象，因此要用then方法调用下一个next方法。</span></span><br></pre></td></tr></table></figure><p>虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p><h2 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h2><p>学习指导：<a href="http://es6.ruanyifeng.com/#docs/async">阮一峰ES6 – async函数</a></p><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><ul><li>async 函数是什么？一句话，它就是 Generator 函数的语法糖</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generator 函数依次读取两个文件</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) <span class="keyword">return</span> reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async函数，就是下面这样</span></span><br><span class="line"><span class="keyword">const</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">await</span> readFile(<span class="string">&#x27;/etc/fstab&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">await</span> readFile(<span class="string">&#x27;/etc/shells&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</span></span><br></pre></td></tr></table></figure><ul><li>async函数对 Generator 函数的改进，体现在以下四点：<ul><li><strong>内置执行器</strong> —— Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</li><li><strong>更好的语义</strong> —— async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</li><li><strong>更广的适用性</strong> —— co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</li><li><strong>返回值是 Promise</strong> —— async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。<strong>进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</strong>  </li></ul></li></ul><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p><ul><li>引入demo</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* async 表示异步调用 返回一个Promise对象 */</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(resolve, ms);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;  <span class="comment">/* 与下边等价*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function timeout(ms) &#123;</span></span><br><span class="line"><span class="comment">//     return new Promise((resolve) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//       setTimeout(resolve, ms);</span></span><br><span class="line"><span class="comment">//     &#125;);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> timeout(ms);</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">&#x27;hello world&#x27;</span>, <span class="number">3000</span>)  <span class="comment">// 3000毫秒以后，输出hello world</span></span><br></pre></td></tr></table></figure><ul><li>async的表达方式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="keyword">async</span> <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;&#125; &#125;;</span><br><span class="line">obj.foo().then(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class 的方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cachePromise = caches.open(<span class="string">&#x27;avatars&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">getAvatar</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cache = <span class="keyword">await</span> <span class="built_in">this</span>.cachePromise;</span><br><span class="line">    <span class="keyword">return</span> cache.match(<span class="string">`/avatars/<span class="subst">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storage = <span class="keyword">new</span> Storage();</span><br><span class="line">storage.getAvatar(<span class="string">&#x27;jake&#x27;</span>).then(…);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="async-的语法"><a href="#async-的语法" class="headerlink" title="async 的语法"></a>async 的语法</h3><ul><li><p>返回Promise 对象</p><ul><li>async函数返回一个 Promise 对象。</li><li>async函数内部return语句返回的值，会成为then方法回调函数的参数。</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="comment">// 函数 f 内部return命令返回的值，会被then方法回调函数接收到。</span></span><br></pre></td></tr></table></figure></li><li><p>async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(</span><br><span class="line">  <span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v),</span><br><span class="line">  <span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// Error: 出错了</span></span><br></pre></td></tr></table></figure><ul><li><p>Promise 对象的状态变化</p><ul><li>async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。</li><li>也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getTitle</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">  <span class="keyword">let</span> html = <span class="keyword">await</span> response.text();</span><br><span class="line">  <span class="keyword">return</span> html.match(<span class="regexp">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">getTitle(<span class="string">&#x27;https://tc39.github.io/ecma262/&#x27;</span>).then(<span class="built_in">console</span>.log)</span><br><span class="line"><span class="comment">// &quot;ECMAScript 2017 Language Specification&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。</span></span><br><span class="line"><span class="comment">// 只有这三个操作全部完成，才会执行then方法里面的 console.log。</span></span><br></pre></td></tr></table></figure></li><li><p>await 命令</p><ul><li>正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// await命令的参数是数值123，它被转成 Promise 对象，并立即resolve</span></span><br></pre></td></tr></table></figure><ul><li>await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// await 语句前面没有 return，但是 reject 方法的参数依然传入了 catch 方法的回调函数。</span></span><br><span class="line"><span class="comment">// 这里如果在await前面加上return，效果是一样的。</span></span><br></pre></td></tr></table></figure><ul><li>只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以将第一个await放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个await都会执行。</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure><ul><li>另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误</li></ul>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><ul><li>第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在<code>try...catch</code>代码块中。</li><li>第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> getFoo();</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> getBar();</span><br><span class="line"><span class="comment">// 上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。</span></span><br><span class="line"><span class="comment">// 这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> [foo, bar] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getFoo(), getBar()]);</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> fooPromise = getFoo();</span><br><span class="line"><span class="keyword">let</span> barPromise = getBar();</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">await</span> fooPromise;</span><br><span class="line"><span class="keyword">let</span> bar = <span class="keyword">await</span> barPromise;</span><br><span class="line"><span class="comment">// getFoo和getBar都是同时触发，这样就会缩短程序的执行时间</span></span><br></pre></td></tr></table></figure><ul><li>第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  docs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 上面代码会报错，因为await用在普通函数之中了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用for循环</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果确实希望多个请求并发执行，可以使用Promise.all方法。</span></span><br><span class="line"><span class="comment">// 当三个请求都会resolved时，下面两种写法效果相同。</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.map(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.post(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises);</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用下面的写法</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="keyword">let</span> promises = docs.map(<span class="function">(<span class="params">doc</span>) =&gt;</span> db.post(doc));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    results.push(<span class="keyword">await</span> promise);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(results);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="async函数实现原理"><a href="#async函数实现原理" class="headerlink" title="async函数实现原理"></a>async函数实现原理</h3><ul><li>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。</span></span><br></pre></td></tr></table></figure><h3 id="场景再现"><a href="#场景再现" class="headerlink" title="场景再现"></a>场景再现</h3><ul><li>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">chainAnimationsAsync</span>(<span class="params">elem, animations</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="literal">null</span>;  <span class="comment">// 变量ret用来保存上一个动画的返回值</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">      ret = <span class="keyword">await</span> anim(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>依次远程读取一组 URL，然后按照读取的顺序输出结果。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 远程操作继发.只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">logInOrder</span>(<span class="params">urls</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> url <span class="keyword">of</span> urls) &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> response.text());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发发出远程请求</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">logInOrder</span>(<span class="params">urls</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 并发读取远程URL</span></span><br><span class="line">  <span class="keyword">const</span> textPromises = urls.map(<span class="keyword">async</span> url =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> fetch(url);</span><br><span class="line">    <span class="keyword">return</span> response.text();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按次序输出</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> textPromise <span class="keyword">of</span> textPromises) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> textPromise);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Generator-函数&quot;&gt;&lt;a href=&quot;#Generator-函数&quot; class=&quot;headerlink&quot; title=&quot;Generator 函数&quot;&gt;&lt;/a&gt;Generator 函数&lt;/h2&gt;&lt;p&gt;学习指导：&lt;a href=&quot;http://es6.ruany</summary>
      
    
    
    
    
    <category term="JavaScript | ES6" scheme="https://mengjie0611.github.io/tags/JavaScript-ES6/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 入门初级指南</title>
    <link href="https://mengjie0611.github.io/posts/undefined.html"/>
    <id>https://mengjie0611.github.io/posts/undefined.html</id>
    <published>2021-03-18T04:07:33.000Z</published>
    <updated>2021-07-19T03:13:28.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在前边"><a href="#写在前边" class="headerlink" title="写在前边"></a>写在前边</h2><p>使用github pages服务搭建博客的好处有：</p><ol><li>全是静态文件，访问速度快；</li><li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li><li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li></ol><span id="more"></span><ol start="4"><li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li><li>博客内容可以轻松打包、转移、发布到其它平台；</li></ol><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><ul><li>打开命令行，在命令行中输入以下命令:<br><code>npm install -g hexo-cli</code> </li><li>安装Hexo的Git插件（如果不安装这个插件，会导致Hexo博客内容无法发布）<br><code>npm install hexo-deployer-git --save</code></li></ul><h2 id="本地搭建Hexo博客"><a href="#本地搭建Hexo博客" class="headerlink" title="本地搭建Hexo博客"></a>本地搭建Hexo博客</h2><ul><li><p>打开命令行，输入以下命令，用于创建Hexo博客目录。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 指的是用于创建Hexo博客的目录，例如 e:/hexo  hexo init &lt;folder&gt;</span><br><span class="line">hexo init e:/Hexo </span><br></pre></td></tr></table></figure></li><li><p>进入创建的项目，打开命令行，输入如下命令</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></li><li><p>初始化完毕后，可以在命令行中输入以下命令，启动本地Hexo博客程序。 </p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm server</span><br></pre></td></tr></table></figure></li><li><p>命令行出现如下信息，打开浏览器，访问 <a href="http://localhost:4000/">http://localhost:4000</a> 就可以访问本地的Hexo博客程序了。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure></li></ul><h2 id="发布博客到GitHub"><a href="#发布博客到GitHub" class="headerlink" title="发布博客到GitHub"></a><strong>发布博客到GitHub</strong></h2><ul><li>注册GitHub账户</li><li>创建GitHub工程</li><li>配置Hexo程序<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 进入Hexo的安装目录，打开_config.yml配置文件。</span><br><span class="line"></span><br><span class="line"># Site</span><br><span class="line">title: 网站名称</span><br><span class="line">subtitle: 网站简介</span><br><span class="line">description:</span><br><span class="line">author: 作者</span><br><span class="line">language:</span><br><span class="line">timezone:</span><br><span class="line"></span><br><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class="line">url: 网站域名  (例如：https://mengjie0611.github.io/)</span><br><span class="line">root: /</span><br><span class="line">permalink: :category/:title.html</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: http://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: GitHub新建工程的地址（例如 git@github.com:mengjie0611/mengjie0611.github.io.git）</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li></ul><h2 id="发布Hexo到GitHub"><a href="#发布Hexo到GitHub" class="headerlink" title="发布Hexo到GitHub"></a>发布Hexo到GitHub</h2><ul><li>在Hexo的安装目录中，鼠标右键选择”Git Bash Here”选项。</li><li>在Git命令行中，输入以下命令。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 生成hexo本地目录结构</span><br><span class="line">hexo generate</span><br><span class="line"></span><br><span class="line">// 将hexo本地目录上传至GitCafe</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;写在前边&quot;&gt;&lt;a href=&quot;#写在前边&quot; class=&quot;headerlink&quot; title=&quot;写在前边&quot;&gt;&lt;/a&gt;写在前边&lt;/h2&gt;&lt;p&gt;使用github pages服务搭建博客的好处有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全是静态文件，访问速度快；&lt;/li&gt;
&lt;li&gt;免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；&lt;/li&gt;
&lt;li&gt;可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Hexo" scheme="https://mengjie0611.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题积累</title>
    <link href="https://mengjie0611.github.io/posts/ab1655f6.html"/>
    <id>https://mengjie0611.github.io/posts/ab1655f6.html</id>
    <published>2021-03-18T00:00:00.000Z</published>
    <updated>2022-07-25T09:03:37.440Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端面试题积累"><a href="#前端面试题积累" class="headerlink" title="前端面试题积累"></a>前端面试题积累</h1><p>标签（空格分隔）： Summarize Interview</p><hr><h2 id="vue构造器以及实例属性"><a href="#vue构造器以及实例属性" class="headerlink" title="vue构造器以及实例属性"></a>vue构造器以及实例属性</h2><ul><li><p>构造器</p><ul><li>Vue.js是一个构造函数，编程中称之为构造器。</li><li>每一个new Vue() 都是一个Vue构造函数的实例，这个过程叫做实例化。  </li><li>构造函数需要将其实例化后才会启用。  </li><li>Vue构造器要求实例化时需要传入一个选项对象。    </li><li>选项对象包括数据(data)，模板(tamplate)，挂载元素(el)，方法(methods)，生命周期钩子等选项。</li><li>每个 Vue.js应用都是通过构造函数Vue创建一个 Vue 的根实例启动的。在文档中经常会使用 vm (ViewModel 的简称)这个变量名表示 Vue 实例。</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//vue的实例化</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  // 选项</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>可以扩展构造器Vue，从而用预定义选项创建可复用的组件构造器，所有组件都是被扩展的Vue的实例，使用 <code>Vue.extend(&#123;&#125;)</code>来扩展；</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var MyComponent = Vue.extend(&#123;</span><br><span class="line">// 扩展选项</span><br><span class="line">&#125;)</span><br><span class="line">// 所有的MyComponent实例都将以预定义的扩展选项被创建</span><br><span class="line">// 相当于MyComponent继承Vue并且加上扩展的选项</span><br><span class="line"></span><br><span class="line">// MyComponent()相当于扩展后的vue，而myComponentInstance 就是扩展后vue的实例。</span><br><span class="line">var myComponentInstance = new MyComponent();</span><br></pre></td></tr></table></figure></li><li><p>属性与方法</p><ul><li>每个Vue的实例都会代理其data对象里的所有属性，被代理的属性是响应的；  </li><li>如果实例创建之后添加新的属性到实例上，不会触发视图更新；</li><li>不要在实例属性或者回调函数中使用箭头函数（如 <code>vm.$watch(&#39;a&#39;, newVal =&gt; this.myMethod())</code>）。因为箭头函数绑定父上下文，所以 this 不会像预想的一样是 Vue 实例，而是<code>this.myMethod</code>未被定义。</li><li>Vue实例暴露了一些有用的实例属性和方法，带有前缀 <code>$</code>，便于与代理的data区分<ul><li><code>vm.$el</code>：类型（HTMLElement）挂载元素，Vue实例的DOM根元素；</li><li><code>vm.$data</code>：类型（Object），Vue实例观察的数据对象；</li><li><code>vm.$props</code>：类型（Object）。</li></ul></li></ul></li></ul><h2 id="手写实现-throttle-（节流）函数"><a href="#手写实现-throttle-（节流）函数" class="headerlink" title="手写实现 throttle （节流）函数"></a>手写实现 <code>throttle</code> （节流）函数</h2><h3 id="什么是throttle"><a href="#什么是throttle" class="headerlink" title="什么是throttle"></a>什么是throttle</h3><ul><li><p>定义：如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。</p></li><li><p>接口定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 频率控制 返回函数连续调用时，action 执行频率限定为 次 / delay</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>delay  &#123;number&#125;    延迟时间，单位毫秒</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>action &#123;function&#125;  请求关联函数，实际应用需要调用的函数</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return <span class="type">&#123;function&#125;</span>    </span>返回客户调用函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">throttle(delay,action)</span><br></pre></td></tr></table></figure></li></ul><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span>(<span class="params">delay, action</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> last = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> curr = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="keyword">if</span> (curr - last &gt; delay)&#123;</span><br><span class="line">      action.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">      last = curr </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展延伸"><a href="#拓展延伸" class="headerlink" title="拓展延伸"></a>拓展延伸</h3><p><a href="https://www.cnblogs.com/fsjohnhuang/p/4147810.html">函数节流（throttle）与函数去抖（debounce）</a></p><h2 id="css实现自适应的正方形"><a href="#css实现自适应的正方形" class="headerlink" title="css实现自适应的正方形"></a>css实现自适应的正方形</h2><ul><li><p>padding-bottom实现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;square-shape&quot;</span>&gt;</span>这是一个可以自适应的正方形，此法很好用，有内容也是正方形。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.square-shape &#123;</span><br><span class="line">  width: 30%;</span><br><span class="line">  height: 0;</span><br><span class="line">  padding-bottom: 30%;</span><br><span class="line">  border: 1px solid #f00;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>伪元素的padding-bottom，内嵌absolute元素</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;square-shape&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span>这是一个可以自适应的正方形<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.square-shape &#123;</span><br><span class="line">  width: 50%;</span><br><span class="line">  border: 1px solid #f00;</span><br><span class="line">&#125;</span><br><span class="line">.square-shape:after &#123;</span><br><span class="line">  content: &#x27;&#x27;;</span><br><span class="line">  display: block;</span><br><span class="line">  padding-bottom: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.content &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="手写实现以下事件委托函数"><a href="#手写实现以下事件委托函数" class="headerlink" title="手写实现以下事件委托函数"></a>手写实现以下事件委托函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手写实现以下事件委托函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delegate</span>(<span class="params">parent, selector, handle</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>事件委托，通俗来说就是将元素的事件委托给它的父级或者更外级元素处理。</p></li><li><p>需要注意的地方：</p><ul><li>保证兼容性，包括：事件绑定、元素选择器 Element.matches 、事件 event 对象</li><li>回调函数 this 指向</li><li>当目标元素下还有子元素时，子元素不能触发事件。<br>解决办法是在触发过程中对元素进行判断，如果当前触发的元素不是目标元素，就继续往该元素的 parentNode 查找，否则循环结束。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">/ *</span><br><span class="line">  * [delegateEvent description]</span><br><span class="line">  * @param  &#123;[type]&#125;   parentSelector 父元素</span><br><span class="line">  * @param  &#123;[type]&#125;   targetSelector 目标元素</span><br><span class="line">  * @param  &#123;[type]&#125;   events         事件</span><br><span class="line">  * @param  &#123;<span class="built_in">Function</span>&#125; fn             回调函数</span><br><span class="line">  * @<span class="keyword">return</span> &#123;[type]&#125;                  <span class="literal">null</span></span><br><span class="line">   */</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delegateEvent</span>(<span class="params">parentSelector, targetSelector, events, fn</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 事件绑定浏览器兼容性处理</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">ele, type, handle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ele.addEventListener) &#123;</span><br><span class="line">      ele.addEventListener(type, handle, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ele.attachEvent)&#123;</span><br><span class="line">      ele.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, handle);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ele[<span class="string">&#x27;on&#x27;</span> + type] = handle;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果元素被指定的选择器字符串选择， Element.matches() 方法返回 true; 否则返回 false。</span></span><br><span class="line">  <span class="comment">// 对于不支持 Element.matches() 或 Element.matchesSelector()，但支持 document.querySelectorAll() 方法的浏览器，存在以下替代方案</span></span><br><span class="line">  <span class="keyword">if</span> (!Element.prototype.matches) &#123;</span><br><span class="line">    Element.prototype.matches =</span><br><span class="line">    Element.prototype.matchesSelector ||</span><br><span class="line">    Element.prototype.mozMatchesSelector ||</span><br><span class="line">    Element.prototype.msMatchesSelector ||</span><br><span class="line">    Element.prototype.oMatchesSelector ||</span><br><span class="line">    Element.prototype.webkitMatchesSelector ||</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> matches = (<span class="built_in">this</span>.document || <span class="built_in">this</span>.ownerDocument).querySelectorAll(s),</span><br><span class="line">          i = matches.length;</span><br><span class="line">      <span class="keyword">while</span> (--i &gt;= <span class="number">0</span> &amp;&amp; matches.item(i) !== <span class="built_in">this</span>) &#123;&#125;</span><br><span class="line">      <span class="keyword">return</span> i &gt; -<span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事件处理逻辑</span></span><br><span class="line">  addEvent(parentSelector, events, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 兼容性处理</span></span><br><span class="line">    <span class="keyword">var</span> e = e || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">var</span> t = e.target || e.srcElement;</span><br><span class="line">    <span class="comment">// currentTarget === parentSelector</span></span><br><span class="line">    <span class="keyword">var</span> currentTarget = e.currentTarget;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历并判断是否为目标元素，如果不是，则往元素的 parentNode 继续查找</span></span><br><span class="line">    <span class="keyword">while</span>(!t.matches(targetSelector)) &#123;</span><br><span class="line">      <span class="comment">// 如果是目标元素则跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(t === currentTarget) &#123;</span><br><span class="line">        t = <span class="literal">null</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t = t.parentNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t) &#123;</span><br><span class="line">    <span class="comment">// 将回调函数的 this 指向目标元素</span></span><br><span class="line">    fn.call(t, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>实例</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;myLink&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;link&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;link&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:;&quot;</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;3&quot;</span> <span class="attr">class</span>=<span class="string">&quot;link&quot;</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> myLink = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#myLink&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  delegateEvent(myLink, <span class="string">&#x27;li.link&#x27;</span>, <span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">this</span>, <span class="built_in">this</span>.id + <span class="string">&#x27;：&#x27;</span> + <span class="built_in">this</span>.innerText);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前端面试题积累&quot;&gt;&lt;a href=&quot;#前端面试题积累&quot; class=&quot;headerlink&quot; title=&quot;前端面试题积累&quot;&gt;&lt;/a&gt;前端面试题积累&lt;/h1&gt;&lt;p&gt;标签（空格分隔）： Summarize Interview&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;vue</summary>
      
    
    
    
    
    <category term="面试" scheme="https://mengjie0611.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>常用前端面试参考总结</title>
    <link href="https://mengjie0611.github.io/posts/undefined.html"/>
    <id>https://mengjie0611.github.io/posts/undefined.html</id>
    <published>2021-03-18T00:00:00.000Z</published>
    <updated>2021-07-19T05:52:56.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用前端面试参考总结"><a href="#常用前端面试参考总结" class="headerlink" title="常用前端面试参考总结"></a>常用前端面试参考总结</h1><p>标签（空格分隔）： Summarize Interview</p><hr><h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><ul><li>函数的prototype属性(图)<ul><li>每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)</li><li>原型对象中有一个属性constructor, 它指向函数对象</li></ul></li><li>给原型对象添加属性(一般都是方法)<ul><li>作用: 函数的所有实例对象自动拥有原型中的属性(方法)</li><li>原型对象上的方法一般给其实例对象调用</li></ul></li></ul><h3 id="显式原型与隐式原型"><a href="#显式原型与隐式原型" class="headerlink" title="显式原型与隐式原型"></a>显式原型与隐式原型</h3><ul><li>每个函数对象function都有一个prototype，即显式原型</li><li>每个实例对象都有一个 <code>__proto__</code> ，可称为隐式原型</li><li>对象的隐式原型的值为其对应构造函数的显式原型的值 ===&gt; 都指向函数对象</li><li>内存结构(图)</li><li>总结:<ul><li>函数的prototype属性： 在定义函数时自动添加的，默认值是一个空Object对象</li><li>对象的<code>__proto__</code>属性：创建对象时自动添加的，默认值为构造函数的prototype属性值</li><li>程序员能直接操作显式原型，但不能直接操作隐式原型(ES6之前)</li></ul></li><li>举个例子</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// Fn()</span><br><span class="line">var Fn = function () &#123;&#125;  // 执行这条函数定义语句, 函数体并没有执行</span><br><span class="line"></span><br><span class="line">// 每个函数function都有一个prototype，即显式原型(属性)</span><br><span class="line">console.log(Fn.prototype)</span><br><span class="line"></span><br><span class="line">// 每个实例对象都有一个__proto__，可称为隐式原型(属性)</span><br><span class="line">var fn = new Fn()</span><br><span class="line">console.log(fn.__proto__)</span><br><span class="line"></span><br><span class="line">// 对象的隐式原型的值为其对应构造函数的显式原型的值</span><br><span class="line">console.log(fn.__proto__ === Fn.prototype)  // true</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 1. prototype属性: 函数对象</span><br><span class="line">    什么时候添加? 函数被定义时(创建函数对象时自动添加)</span><br><span class="line">    值是多少?  空的object实例对象: this.prototype = &#123;&#125;  this.prototype.constructor = this</span><br><span class="line"></span><br><span class="line">2. __proto__属性: 实例对象</span><br><span class="line">    什么时候添加? 创建实例对象时自动添加</span><br><span class="line">    值是多少?   构造函数的prototype属性值: this.__proto__ = Fn.prototype</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">    执行函数: 执行函数体中的所有语句</span><br><span class="line">    执行函数定义: 本质是创建函数对象</span><br><span class="line">*/</span><br><span class="line">console.log(Object.prototype.__proto__);  // null</span><br></pre></td></tr></table></figure><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ul><li>原型链(图解)</li><li>访问一个对象的属性时，<ul><li>先在自身属性中查找，找到返回</li><li>如果没有,再沿着<code>__proto__</code>这条链向上查找, 找到返回</li><li>如果最终没找到,返回undefined</li></ul></li><li>别名：隐式原型链</li><li>作用：<strong>查找对象的属性(方法)</strong></li><li>构造函数/原型/实体对象的关系(图解)</li><li>构造函数/原型/实体对象的关系2(图解)</li><li>举个例子<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">console.log(Function.prototype===Function.__proto__)  // true</span><br><span class="line">console.log(Object.prototype.__proto__)  // null</span><br><span class="line">console.log(Object.prototype)</span><br><span class="line">function Fn() &#123;</span><br><span class="line">    this.test1 = function () &#123;</span><br><span class="line">        console.log(&#x27;test1()&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Fn.prototype.test2 = function () &#123;</span><br><span class="line">    console.log(&#x27;test2()&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">var fn = new Fn()</span><br><span class="line"></span><br><span class="line">fn.test1()</span><br><span class="line">fn.test2()</span><br><span class="line">console.log(fn.toString())</span><br><span class="line">console.log(fn.test3)  // undefined</span><br><span class="line">fn.test3()</span><br><span class="line"></span><br><span class="line">// 详情请看githubMarkdownPhotos分析图</span><br></pre></td></tr></table></figure></li><li><strong>原型链总结</strong><ul><li>查找对象的属性沿着原型链查找，查找变量沿着作用域链查找</li><li>函数对象既有<code>prototype</code>属性，也有<code>__proto__</code>属性（函数的本质是被new出来的）</li><li>所有函数对象的<code>__proto__</code>属性值都相等，都等于大写的Function的 <code>prototype</code></li><li>所有函数都是Function的实例，包括它自己。<br><code>Function.prototype === Function.__proto__ // true</code></li><li>非函数对象（实例对象）肯定是其对应构造函数的实例</li></ul></li></ul><h3 id="原型链的属性问题"><a href="#原型链的属性问题" class="headerlink" title="原型链的属性问题"></a>原型链的属性问题</h3><ul><li>读取对象的属性值时: 会自动到原型链中查找</li><li>设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值</li><li>即：<strong>当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作</strong></li><li>方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上</li><li>举个例子</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = function (name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sex = &#x27;男&#x27;;</span><br><span class="line"></span><br><span class="line">var p1 = new Person(&#x27;Tom&#x27;, 12)</span><br><span class="line">p1.setName(&#x27;Jack&#x27;)</span><br><span class="line">console.log(p1.name, p1.age, p1.sex) // Jack 12 &#x27;男&#x27;</span><br><span class="line"></span><br><span class="line">p1.sex = &#x27;女&#x27;  // 设置属性值时, 不会查看原型链</span><br><span class="line">console.log(p1.name, p1.age, p1.sex) //Jack 12 &#x27;女&#x27;</span><br><span class="line"></span><br><span class="line">var p2 = new Person(&#x27;Bob&#x27;, 23)</span><br><span class="line">console.log(p2.name, p2.age, p2.sex) //&#x27;Bob&#x27; 23 &#x27;男&#x27;</span><br></pre></td></tr></table></figure><h3 id="探索instanceof"><a href="#探索instanceof" class="headerlink" title="探索instanceof"></a>探索instanceof</h3><ul><li>instanceof是如何判断的?<ul><li>表达式: A instanceof B</li><li>如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false</li><li>A可以寻找多步，B只能找一步到自己的显式原型上</li></ul></li><li>Function是通过new自己产生的实例。即所有函数都是Function的实例包括它自身。</li><li>几点总结<ul><li><code>Object created by Function</code></li><li><code>Object 是 Function 的实例</code></li><li><code>Object 是 Object 的实例</code></li></ul></li><li>理解实例</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object instanceof Function) // true</span><br><span class="line">console.log(Object instanceof Object) // true</span><br><span class="line">console.log(Function instanceof Object) // true</span><br><span class="line">console.log(Function instanceof Function) // true</span><br><span class="line">console.log(Object instanceof Foo); // false</span><br><span class="line"></span><br><span class="line">console.log(Function.prototype) // 不是Object的实例  ƒ () &#123; [native code] &#125;</span><br><span class="line">console.log(Function.prototype.__proto__===Object.prototype) // true</span><br></pre></td></tr></table></figure><ul><li>原型与原型链分析详图<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Foo () &#123;&#125;</span><br><span class="line">var f1 = new Foo()</span><br><span class="line">var f2 = new Foo()</span><br><span class="line">var o1 = &#123;&#125;</span><br><span class="line">var o2 = &#123;&#125;</span><br></pre></td></tr></table></figure><img src="https://i.imgur.com/Q3nxgq6.png" alt="原型与原型链分析"></li></ul><h3 id="面试题及总结"><a href="#面试题及总结" class="headerlink" title="面试题及总结"></a>面试题及总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// 测试题 1</span><br><span class="line">var A = function() &#123;&#125;</span><br><span class="line">A.prototype.n = 1</span><br><span class="line">var b = new A()</span><br><span class="line"></span><br><span class="line">A.prototype = &#123;</span><br><span class="line">    n: 2,</span><br><span class="line">    m: 3</span><br><span class="line">&#125;</span><br><span class="line">var c = new A()</span><br><span class="line">console.log(b.n, b.m, c.n, c.m) //  1 undefined  2  3</span><br><span class="line"></span><br><span class="line">// 测试题2</span><br><span class="line">var F = function()&#123;&#125;;</span><br><span class="line">Object.prototype.a = function()&#123;</span><br><span class="line">    console.log(&#x27;a()&#x27;)</span><br><span class="line">&#125;;</span><br><span class="line">Function.prototype.b = function()&#123;</span><br><span class="line">    console.log(&#x27;b()&#x27;)</span><br><span class="line">&#125;;</span><br><span class="line">var f = new F();</span><br><span class="line">f.a()     // a()</span><br><span class="line">f.b()     // f.b is not a function</span><br><span class="line">F.a()     // a()</span><br><span class="line">F.b()     // b()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">原型链（隐式原型链）：作用查找对象的属性</span><br><span class="line">    访问一个对象的属性时，先在自身属性中查找，找到返回；</span><br><span class="line">    如果没有再沿着 __proto__ 这条链向上查找，找到返回，如果最终没有找到，则返回undefined</span><br><span class="line"></span><br><span class="line">A instanceof B  的判断</span><br><span class="line">    如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false</span><br><span class="line"></span><br><span class="line">prototype 与 __proto__ 在创建的时候相关联，在执行的时候没有关联</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><h2 id="webpack及构建工具的理解"><a href="#webpack及构建工具的理解" class="headerlink" title="webpack及构建工具的理解"></a>webpack及构建工具的理解</h2><h3 id="构建工具的功能"><a href="#构建工具的功能" class="headerlink" title="构建工具的功能"></a>构建工具的功能</h3><ul><li><strong>代码转换</strong>：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。（开发写的代码有些浏览器无法识别，如ES6语法）</li><li><strong>文件优化</strong>：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。（压缩代码）</li><li><strong>模块合并</strong>：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。</li><li><strong>代码分割</strong>：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li><li><strong>自动刷新</strong>：监听本地源代码的变化，自动重新构建、刷新浏览器。 live reload 自动刷新 / hot reload 热模替换（HMR）（开发环境下修改代码后可以自动刷新浏览器看到最新的效果，可以监视源码的变化）</li><li><strong>代码校验</strong>：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</li></ul><h3 id="模块化打包和非模块化打包思想差异"><a href="#模块化打包和非模块化打包思想差异" class="headerlink" title="模块化打包和非模块化打包思想差异"></a>模块化打包和非模块化打包思想差异</h3><ul><li>非模块化打包：先对文件进行分类（如js/img/css等），然后分别打包</li><li>模块化打包：将所有资源看成模块，而所有的模块之间都是有关系的，项目中的资源是相互关联的节点通过入口js形成一个网(图)的结构。<ul><li>从入口开始递归的查找所有相关联的模块</li><li>找到一个模块(如css)后会找对应的loader，模块文件会进行正则匹配的</li><li>四个核心概念：entry | output | module(loader) | plugins</li><li>loader模块加载器，将非js模块打包成webpack能理解的js模块</li><li>图片处理推荐使用 <code>url-loader</code>，配置选项可以对图片进行限制，小于此限制的会会通过base64处理的</li></ul></li></ul><h3 id="webpack的核心概念"><a href="#webpack的核心概念" class="headerlink" title="webpack的核心概念"></a>webpack的核心概念</h3><ul><li><strong>Entry</strong>：入口，Webpack进行打包的起始点(文件)</li><li><strong>Output</strong>：出口，webpack编译打包生成的bundle(文件)</li><li><strong>Loader</strong>：模块加载(转换)器，将非js模块包装成webpack能理解的js模块<ul><li>（举例：如处理css要用到style-loader/css-loader;处理img使用file-loader/url-loader）</li></ul></li><li><strong>Plugin</strong>：插件，在Webpack构建流程中的特定时机插入具有特定功能的代码<ul><li>（举例：CleanPlugin一开始就会清除指定的文件/夹；</li><li>ExtractTextPlugin用于样式的抽取，用来从js中分离出css并单独打包；</li><li>CopyPlugin复制静态资源；</li><li>webpack.HashedModuleIdsPlugin根据代码内容生成hash作为模块的id(默认是下标)；</li><li>webpack.optimize.CommonsChunkPlugin将第三方模块单独打包</li><li>……） </li></ul></li><li>Module：模块，在 Webpack眼里一切皆模块，默认只识别js文件，如果是其它类型文件利用对应的loader转换为js模块</li><li>Chunk：代码块，一个 Chunk 由多个模块组合而成，最终浏览器执行的是webpack打包生成的chunk文件(bundle同理)</li></ul><h3 id="webpack的其他概念"><a href="#webpack的其他概念" class="headerlink" title="webpack的其他概念"></a>webpack的其他概念</h3><ul><li><img src="http://static.zybuluo.com/MarlonChiu/12qcvudloms3ft00fsxugjtt/webpack%E5%85%B6%E5%AE%83%E6%A6%82%E5%BF%B5_1.png" alt="webpack其它概念_1.png-39.4kB"></li><li><img src="http://static.zybuluo.com/MarlonChiu/sxodezube6trrxitofbx3drp/webpack%E5%85%B6%E5%AE%83%E6%A6%82%E5%BF%B5_2.png" alt="webpack其它概念_2.png-27.8kB"></li></ul><h3 id="webpack-和-gulp-的区别"><a href="#webpack-和-gulp-的区别" class="headerlink" title="webpack 和 gulp 的区别"></a>webpack 和 gulp 的区别</h3><ul><li>webpack 是一种模块化打包工具，主要用于模块化方案，预编译模块的方案；</li><li>gulp 是工具链、构建工具，可以配合各种插件做 js 压缩，css压缩，less 编译替代手工实现自动化工作。</li><li>Grunt/Gulp 更多的是一种工作流；提供集成所有服务的一站式平台； gulp可以用来优化前端工作流程。</li></ul><h2 id="客户端两种存储"><a href="#客户端两种存储" class="headerlink" title="客户端两种存储"></a>客户端两种存储</h2><h3 id="Cookie存储"><a href="#Cookie存储" class="headerlink" title="Cookie存储"></a>Cookie存储</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie是一项很老的技术的，就是因为它老，所以兼容性还是不错的。</span><br><span class="line">使用Cookie作为本地存储优点：兼容性好，缺点：操作繁琐，只能存简单的数据，还会过期，站点设置httponly的话，JS就不无法操作Cookie了。</span><br></pre></td></tr></table></figure><h3 id="Web-Storage存储"><a href="#Web-Storage存储" class="headerlink" title="Web Storage存储"></a>Web Storage存储</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebStorage是HTML5中为WebApplication提供一种存储的API，目前主流的新版本的浏览器都支持，当然IE789你就没有办法了。WebStorage主要分成localStorage和sessionStorage两种。</span><br></pre></td></tr></table></figure><h4 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage是个全局对象，它维护着在页面会话(page session)期间有效的存储空间。只要浏览器开着，页面会话周期就会一直持续。当页面重新载入(reload)或者被恢复(restores)时，页面会话也是一直存在的。每在新标签或者新窗口中打开一个新页面，都会初始化一个新的会话。</span><br></pre></td></tr></table></figure><h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage也是一个全局变量，它的生命周期比sessionStorage长。localStorage和sessionStorage都继承自Storage因此它们的用法相同。</span><br></pre></td></tr></table></figure><h4 id="WebStorage的优点"><a href="#WebStorage的优点" class="headerlink" title="WebStorage的优点"></a>WebStorage的优点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用简单方便，缺点：IE有些版本不支持，不能存复杂的对象，必须先转化成JSON字符串，没有索引搜索效率不高，只能同步读写操作，当写入的数据比较大时可能造成JS引擎堵塞。</span><br></pre></td></tr></table></figure><h4 id="sessionStorage用法和localStorage区别"><a href="#sessionStorage用法和localStorage区别" class="headerlink" title="sessionStorage用法和localStorage区别"></a>sessionStorage用法和localStorage区别</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">完全一致，差别只在有效期：</span><br><span class="line">sessionStorage在用户结束会话（即关闭浏览器或退出账户时失效）；</span><br><span class="line">localStorage无失效期，用户在清理浏览器缓存的时候会被清除。</span><br></pre></td></tr></table></figure><h3 id="Cookie存储和Web-Storage存储区别"><a href="#Cookie存储和Web-Storage存储区别" class="headerlink" title="Cookie存储和Web Storage存储区别"></a>Cookie存储和Web Storage存储区别</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">localStorage与sessionStorage作为新时代的产物，相比旧时代的cookie有其巨大的优越性。优越性有三:</span><br><span class="line">    其一在能存储的数据量，cookie最大能存储4kb的数据，而localStorage与sessionStorage最大能存储5Mb，目前各大浏览器支持的标准都是如此；</span><br><span class="line">    </span><br><span class="line">    其二在功能上，cookie只能存储String类型的数据，以往要将用户数据存储在本地，需要将数据拼接成字符串，再存进cookie,取数据的时候同样麻烦，先将整个cookie对象拿到（String对象），再按拼接的规则拆分，再拿需要的数据，存取都很麻烦！</span><br><span class="line">    localStorage与sessionStorage不仅支持传统的String类型，还可以将json对象存储进去,存取数据都方便不少，json的优越性就不赘述，localStorage与sessionStorage无疑更现代化；</span><br><span class="line">    </span><br><span class="line">    其三是cookie是不可或缺的，cookie的作用是与服务器进行交互，作为http规范的一部分而存在；而web storage仅仅是为了在本地‘存储’而生；</span><br><span class="line">    其四在语义层面上，localStorage与sessionStorage语法更优雅、简便。</span><br></pre></td></tr></table></figure><h3 id="存储方式的操作对比演示"><a href="#存储方式的操作对比演示" class="headerlink" title="存储方式的操作对比演示"></a>存储方式的操作对比演示</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// cookie的操作</span><br><span class="line">设置cookie: document.cookie = &#x27;key=value&#x27;;</span><br><span class="line">获取cookie: document.cookie;</span><br><span class="line">删除cookie: document.cookie = &quot;key=value;max-age=0&quot;;</span><br><span class="line">设置max-age存储期限: document.cookie = &quot;key=value;max-age=1000&quot;; // 1000秒</span><br><span class="line"></span><br><span class="line">// web storage操作</span><br><span class="line">保存数据 setItem(key,value)</span><br><span class="line">读取数据 getItem(key)</span><br><span class="line">删除单个数据 removeItem(key)</span><br><span class="line">清空全部数据 clearItem()</span><br><span class="line">获取数据索引 key(index)</span><br></pre></td></tr></table></figure><h3 id="cookie-storage-session-关系"><a href="#cookie-storage-session-关系" class="headerlink" title="cookie / storage / session 关系"></a>cookie / storage / session 关系</h3><ul><li>cookie<ul><li>优点：可以解决http无状态问题 </li><li>缺点：<ol><li>与服务器交互的时候有数量和长度限制 每个域名最多20条，长度不能超过4KB  </li><li>安全性问题 容易被人拦截 </li><li>浪费宽带，每次请求新页面，cookie都会被发过去 </li><li>不可以跨域  </li></ol></li></ul></li></ul><ul><li>cookie 和session区别<ul><li>cookie是把数据放在客户的浏览器上，只能存储sting类型</li><li>session数据是放在服务器上，能存储json 类型、sting类型</li><li>session会在一定的时间内保留数据存在服务器上，当访问增多，<br>会比较占你服务器的性能 ，减轻服务器的性能 应当使用cookie</li><li>sessionStorage是当前对话的缓存，浏览器窗口关闭即消失，会话级别的存储</li><li>localStorage持久存在，除非清除浏览器缓存。</li></ul></li></ul><h2 id="数组的一些方法"><a href="#数组的一些方法" class="headerlink" title="数组的一些方法"></a>数组的一些方法</h2><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.先将原数组进行排序</span></span><br><span class="line"><span class="comment">2.检查原数组中的第i个元素 与 结果数组中的最后一个元素是否相同，因为已经排序，所以重复元素会在相邻位置</span></span><br><span class="line"><span class="comment">3.如果不相同，则将该元素存入结果数组中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.sort(); <span class="comment">//先排序</span></span><br><span class="line">    <span class="keyword">var</span> res = [<span class="built_in">this</span>[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">this</span>.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>[i] !== res[res.length - <span class="number">1</span>])&#123;</span><br><span class="line">        res.push(<span class="built_in">this</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.创建一个新的数组存放结果</span></span><br><span class="line"><span class="comment">2.创建一个空对象</span></span><br><span class="line"><span class="comment">3.for循环时，每次取出一个元素与对象进行对比，如果这个元素不重复，</span></span><br><span class="line"><span class="comment">  则把它存放到结果数组中，同时把这个元素的内容作为对象的一个属性，</span></span><br><span class="line"><span class="comment">  并赋值为1，存入到第2步建立的对象中。</span></span><br><span class="line"><span class="comment">说明：至于如何对比，就是每次从原数组中取出一个元素，然后到对象中去访问这个属性，如果能访问到值，则说明重复。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = [];</span><br><span class="line">    <span class="keyword">var</span> json = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!json[<span class="built_in">this</span>[i]])&#123;</span><br><span class="line">            res.push(<span class="built_in">this</span>[i]);</span><br><span class="line">            json[<span class="built_in">this</span>[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">112</span>,<span class="number">112</span>,<span class="number">34</span>,<span class="string">&#x27;你好&#x27;</span>,<span class="number">112</span>,<span class="number">112</span>,<span class="number">34</span>,<span class="string">&#x27;你好&#x27;</span>,<span class="string">&#x27;str&#x27;</span>,<span class="string">&#x27;str1&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>];</span><br><span class="line"><span class="comment">// 方法零</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));  <span class="comment">// Set(7) &#123;1, 7, 3, 4, 11, 2, 0&#125;</span></span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.unique1()); <span class="comment">// (7) [0, 1, 11, 2, 3, 4, 7]  按照Unicode排列了</span></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.unique2()); <span class="comment">// (7) [0, 1, 11, 2, 3, 4, 7]</span></span><br></pre></td></tr></table></figure><h3 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(arr) &#123;</span><br><span class="line">  if(arr.length &lt;= 1)&#123;</span><br><span class="line">    return arr;</span><br><span class="line">  &#125;</span><br><span class="line">  // 基准索引（理论上可以任意选取）</span><br><span class="line">  var pivotIndex = parseInt(arr.length/2),</span><br><span class="line">    // 基准值</span><br><span class="line">    pivot = arr.splice(pivotIndex,1)[0],</span><br><span class="line">    leftArr = [],</span><br><span class="line">    rightArr = [],</span><br><span class="line">    length = arr.length;</span><br><span class="line">  // 遍历序列，根据基准拆分为两个子序列</span><br><span class="line">  for (var i = 0; i &lt; length; i++) &#123;</span><br><span class="line">    if(arr[i] &lt; pivot)&#123;</span><br><span class="line">      leftArr.push(arr[i]);</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">      rightArr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  console.log(pivot); // 输出了三次 3 1 7</span><br><span class="line">  </span><br><span class="line">  // 连接左序列、基准、右序列</span><br><span class="line">  return quickSort(leftArr).concat(pivot, quickSort(rightArr))</span><br><span class="line">&#125;</span><br><span class="line">var demoArr = [8,4,7,2,0,3,1]</span><br><span class="line"></span><br><span class="line">// 方法一</span><br><span class="line">console.log(demoArr.sort()); // (7) [0, 1, 2, 3, 4, 7, 8]</span><br><span class="line">// 方法二</span><br><span class="line">console.log(quickSort(demoArr)) // (7) [0, 1, 2, 3, 4, 7, 8]</span><br></pre></td></tr></table></figure><h2 id="前端WEB-H5性能优化"><a href="#前端WEB-H5性能优化" class="headerlink" title="前端WEB/H5性能优化"></a>前端WEB/H5性能优化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 参考CSDN博客</span><br><span class="line">http://blog.csdn.net/lpf1215/article/details/74315797?locationNum=8&amp;fps=1</span><br></pre></td></tr></table></figure><ul><li>减少http请求，合理设置 HTTP缓存</li><li>使用浏览器缓存</li><li>启用压缩</li><li>CSS Sprites</li><li>LazyLoad Images</li><li>CSS放在页面最上部，javascript放在页面最下面</li><li>异步请求Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容）</li><li>减少cookie传输</li><li>Javascript代码优化</li><li>CSS选择符优化</li><li>CDN加速</li><li>反向代理</li></ul><h2 id="px-em-rem-区别"><a href="#px-em-rem-区别" class="headerlink" title="px em rem 区别"></a>px em rem 区别</h2><ul><li>px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的</li><li>em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸</li><li>rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素</li></ul><h2 id="实现一个jsonp请求"><a href="#实现一个jsonp请求" class="headerlink" title="实现一个jsonp请求"></a>实现一个jsonp请求</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">function jsonpCallback(result) &#123;</span><br><span class="line">    // alert(result);  </span><br><span class="line">    for(var i in result) &#123;</span><br><span class="line">        alert(i+&quot;:&quot;+result[i]);// 循环输出a:1,b:2,etc.  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var JSONP = document.createElement(&quot;script&quot;);</span><br><span class="line">JSONP.type = &quot;text/javascript&quot;;</span><br><span class="line">JSONP.src = &quot;http://crossdomain.com/services.php?callback=jsonpCallback&quot;;</span><br><span class="line">document.getElementsByTagName(&quot;head&quot;)[0].appendChild(JSONP);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="原型与原型链分析图例"><a href="#原型与原型链分析图例" class="headerlink" title="原型与原型链分析图例"></a>原型与原型链分析图例</h2><ul><li><p>图例一<br><img src="http://static.zybuluo.com/MarlonChiu/v5fxgw1c326yrmvru8gt4qxa/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90%E5%9B%BE%E4%BE%8B_01.png" alt="原型链分析图例_01.png-35.1kB"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 图例分析说明</span><br></pre></td></tr></table></figure></li><li><p>图例二<br><img src="http://static.zybuluo.com/MarlonChiu/qj4jj2hpkqymby58zjazwl7x/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90%E5%9B%BE%E4%BE%8B_02.png" alt="原型链分析图例_02.png-46.7kB"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 图例分析说明</span><br><span class="line">两个空间：栈和堆。在代码未执行之前，JS引擎就会先加载执行一些内置的代码就。在开始之前就先执行了Object定义（function Object(value)&#123;&#125;），栈空间会有一个Object引用变量，传的是地址值0x123，开辟出一块空间，该空间就是Object函数对象，函数对象上有一个prototype属性，该属性也是引用类型，传递地址值0x234，开辟出一块新的空间，该空间指向Object原型对象，该Object原型对象的原型上包含hasOwnProperty、toString......等一些属性，也就说在代码执行之前第一列的关系已经存在了。</span><br><span class="line"></span><br><span class="line">代码执行function Fn()&#123;&#125;，Fn指向的堆空间中一块区域，地址值为0x345，即Fn函数对象，Fn函数对象有一个prototype属性，该属性也是指向一块地址值0x456，指向Fn原型对象，该对象是一个空对象即&#123;&#125;。这个实例对象的__proto__又会指向Object的函数对象的prototype属性（实例对象的隐式原型等于函数对象的显示原型），地址值也是0x234，也会指向Object原型对象。</span><br><span class="line">代码执行Fn.prototype.test2 则在Fn原型对象上添加test2()方法</span><br><span class="line"></span><br><span class="line">代码执行var fn = new Fn()，fn的地址值为0x567，在堆内存中开辟空间指向Fn实例对象，该对象有隐式原型__proto__，其值是0x456，箭头指向Fn原型对象。Fn实例对象上有个方法test1()。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">console.log(Function.prototype === Function.__proto__)  // true</span><br><span class="line">console.log(Object.prototype.__proto__)  // null</span><br><span class="line">console.log(Object.prototype.toString)  // ƒ toString() &#123; [native code] &#125;  Object原型上有toString方法</span><br></pre></td></tr></table></figure></li><li><p>图例三<br><img src="http://static.zybuluo.com/MarlonChiu/2o4q7d8zguhokxee7b4avun1/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90%E5%9B%BE%E4%BE%8B_03.png" alt="原型与原型链分析图例_03.png-129.8kB"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;</span><br><span class="line">&#125;</span><br><span class="line">var f1 = new Foo()</span><br><span class="line">var f2 = new Foo()</span><br><span class="line">var o1 = &#123;&#125;</span><br><span class="line">var o2 = &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>图例四<br><img src="http://static.zybuluo.com/MarlonChiu/4shqfy3qe573pw8t7fi70jpz/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%88%86%E6%9E%90.png" alt="函数对象的原型分析.png-60.3kB"></p></li></ul><h2 id="实现类的继承"><a href="#实现类的继承" class="headerlink" title="实现类的继承"></a>实现类的继承</h2><h3 id="原型链的方法"><a href="#原型链的方法" class="headerlink" title="原型链的方法"></a>原型链的方法</h3><ul><li>套路<ol><li>定义父类型构造函数</li><li>给父类型的原型添加方法</li><li>定义子类型的构造函数</li><li>创建父类型的对象赋值给子类型的原型</li><li>将子类型原型的构造属性设置为子类型</li><li>给子类型原型添加方法</li><li>创建子类型的对象: 可以调用父类型的方法</li></ol></li><li>关键<ol><li>子类型的原型为父类型的一个实例对象<br>Child.prototype = new Parent()</li></ol></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function Parent() &#123;</span><br><span class="line">    this.pProp = &#x27;this Parent prop&#x27;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.showPProp = function () &#123;</span><br><span class="line">    console.log(&#x27;showPProp()&#x27;, this.pProp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Child() &#123;</span><br><span class="line">    this.cProp = &#x27;this Child prop&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 让子类原型指向父类型实例</span><br><span class="line">Child.prototype = new Parent()</span><br><span class="line">// 让子类原型对象构造器属性指向子类</span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line"></span><br><span class="line">Child.prototype.showCProp = function () &#123;</span><br><span class="line">    console.log(&#x27;showCProp()&#x27;, this.cProp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var child = new Child()</span><br><span class="line">child.showPProp()</span><br><span class="line">console.log(child.constructor) // ƒ Child() &#123; this.cProp = &#x27;this Child prop&#x27;&#125;</span><br><span class="line">console.log(child)   // Child &#123;cProp: &quot;this Child prop&quot;&#125;</span><br></pre></td></tr></table></figure><h3 id="class-类的方式"><a href="#class-类的方式" class="headerlink" title="class 类的方式"></a>class 类的方式</h3><ul><li>通过class定义类/实现类的继承</li><li>在类中通过constructor定义构造方法</li><li>通过new来创建类的实例</li><li>通过extends来实现类的继承</li><li>通过super调用父类的构造方法</li><li>重写从父类中继承的一般方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 用class定义一个Person类</span><br><span class="line">class Person&#123;</span><br><span class="line">    constructor (name, age)&#123;   // 类的构造方法</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    showName ()&#123;   // 类的一般方法</span><br><span class="line">        console.log(this.name, this.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p1 = new Person(&quot;TOM&quot;, 18);</span><br><span class="line">console.log(p1.name);</span><br><span class="line">p1.showName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 定义一个Student 继承Person</span><br><span class="line">class Student extends Person &#123;  // 定义的Student类继承自Person类</span><br><span class="line">    constructor (name, age, salary)&#123;</span><br><span class="line">        super(name,age);  // 通过super调用父类的构造方法</span><br><span class="line">        this.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line">    showName (name, age, salary)&#123;</span><br><span class="line">        console.log(this.name, this.age, this.salary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let s1 = new Student(&quot;MARLON&quot;, 26, 17000);</span><br><span class="line">console.log(s1.name);</span><br><span class="line">s1.showName();</span><br></pre></td></tr></table></figure><h3 id="Object-create-方法"><a href="#Object-create-方法" class="headerlink" title="Object.create()方法"></a>Object.create()方法</h3><ul><li><code>Object.create(prototype, [descriptors])</code><ul><li>作用: 以指定对象为原型创建新的对象</li><li>为新的对象指定新的属性, 并对属性进行描述<br>value : 指定值<br>writable : 标识当前属性值是否是可修改的, 默认为 false</li></ul></li><li>用法演示<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//  Object.create(prototype, [descriptors])</span><br><span class="line">var obj = &#123;n:11&#125;;</span><br><span class="line">var obj2 = Object.create(obj);</span><br><span class="line">console.log(obj2, obj2.n);   // &#123;&#125; 11</span><br><span class="line">var obj3 = Object.create(obj,&#123;</span><br><span class="line">    m: &#123;</span><br><span class="line">        value: &quot;asd&quot;,</span><br><span class="line">        writable: false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">obj3.m = 456;</span><br><span class="line">console.log(obj3.m);  // asd</span><br></pre></td></tr></table></figure></li></ul><h3 id="原型链-借用构造函数的组合继承"><a href="#原型链-借用构造函数的组合继承" class="headerlink" title="原型链 + 借用构造函数的组合继承"></a>原型链 + 借用构造函数的组合继承</h3><ul><li>利用原型链实现对父类型对象的方法继承</li><li>利用call()借用父类型构建函数初始化相同属性</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">    this.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.setName = function (name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">&#125;</span><br><span class="line">function Student(name, age, price) &#123; // 身价</span><br><span class="line">    Person.call(this, name, age)  // 相当于: this.Person(name, age)</span><br><span class="line">    this.price = price</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype = new Person()</span><br><span class="line">Student.prototype.constructor = Student</span><br><span class="line"></span><br><span class="line">Student.prototype.setPrice = function (price) &#123;</span><br><span class="line">    this.price = price</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var s = new Student(&#x27;Jack&#x27;, 21, 13000)</span><br><span class="line">s.setName(&#x27;Bob&#x27;)</span><br><span class="line">s.setPrice(14000)</span><br><span class="line">console.log(s.name, s.age, s.price)</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用前端面试参考总结&quot;&gt;&lt;a href=&quot;#常用前端面试参考总结&quot; class=&quot;headerlink&quot; title=&quot;常用前端面试参考总结&quot;&gt;&lt;/a&gt;常用前端面试参考总结&lt;/h1&gt;&lt;p&gt;标签（空格分隔）： Summarize Interview&lt;/p&gt;
&lt;hr&gt;</summary>
      
    
    
    
    
    <category term="面试" scheme="https://mengjie0611.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
</feed>
