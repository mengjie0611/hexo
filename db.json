{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/avatat.png","path":"img/avatat.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/background.css","path":"css/background.css","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/baiyue.png","path":"img/baiyue.png","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"4c03fe90239b888c5005486beea186056d081729","modified":1626162719214},{"_id":"themes/butterfly/package.json","hash":"c0d62352ca336c5322fdf5e45d756779c10bdaea","modified":1626661154844},{"_id":"themes/butterfly/README_CN.md","hash":"459d6f3200863021bee1fe72a719aef236fb4090","modified":1626661154836},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1626661154836},{"_id":"themes/butterfly/.github/stale.yml","hash":"05a55a87fa7f122c59683e41c8b2e37e79f688f0","modified":1626661154836},{"_id":"themes/butterfly/README.md","hash":"cedd13fcd8c75a68742265dd8eced4087e940ffd","modified":1626661154836},{"_id":"themes/butterfly/languages/default.yml","hash":"7ca673fb629ea74f5ba5e75b4f0f95248cfb5090","modified":1626661154837},{"_id":"themes/butterfly/languages/en.yml","hash":"cd333235ff1648a6bf58dfafc81f2c57672a15a5","modified":1626661154837},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"741e522b2387f94764a73844e7b084cc7e927c54","modified":1626661154837},{"_id":"themes/butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":1626661154837},{"_id":"themes/butterfly/layout/post.pug","hash":"8d398c8925182699d9f2b9f1b727f06228488312","modified":1626661154844},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1626661154844},{"_id":"themes/butterfly/layout/category.pug","hash":"60c1b795b6e227b5dd81963b51d29d1b81d0bf49","modified":1626661154837},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"79a50c40d9f5463f1fa42aa870ac6b8b84540412","modified":1626661154837},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1626661154844},{"_id":"themes/butterfly/layout/page.pug","hash":"82aa988527a11835e7ac86ce4f23b8cd20014dfa","modified":1626661154844},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"eff495eb1584cf4586e33c76e8b2fa6a469a179b","modified":1626661154835},{"_id":"themes/butterfly/_config.yml","hash":"7845d0d45fde0a845130878421046ed0cac3143c","modified":1626675325948},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"476802922b774b679225102ac30a9d9183394701","modified":1626661154835},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1626661154836},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"f6867a2f0417fe89a0f2008730ee19dd38422021","modified":1626661154836},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"7d378e328a53cc99d5acc9682dce53f5eb61537d","modified":1626661154837},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"1377952022ee0a9eaa7a2fd1098f1571efc468d9","modified":1626661154837},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1626661154837},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"4156224c47bfc2482281ac4e4df701c30476ff00","modified":1626661154837},{"_id":"themes/butterfly/scripts/events/init.js","hash":"018aa446265fe627301b1d53d7cba4f4ff1960ac","modified":1626661154844},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"6f2608c4d93d3d10ae6b2cd7f8918f303f024321","modified":1626661154838},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"2d0453adf92a3fd3466cf0793f14685d17b8b51d","modified":1626661154839},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"9821872007cf57efae4b728dc575ef9d004547bb","modified":1626661154844},{"_id":"themes/butterfly/scripts/events/404.js","hash":"83cd7f73225ccad123afbd526ce1834eb1eb6a6d","modified":1626661154844},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"0b80f04950bd0fe5e6c4e7b7559adf4d0ce28436","modified":1626661154839},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"4cc2d517195c8779471d326ada09f9371cbad4dd","modified":1626661154844},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1626661154845},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"d575137c8779e50422c2416f4d0832fdea346ee6","modified":1626661154844},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"c6611d97087c51845cb1ab4821696a62fa33daeb","modified":1626661154845},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"65f2442e04c4defd16e7c1e67701d3bb41d9577a","modified":1626661154845},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1626661154844},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"54b9324e3506dcc9c9991ef5e11e37e66e21594f","modified":1626661154845},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"b816ded1451f28c7c54151ffe6c259b110253ae3","modified":1626661154845},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"03b2afef41d02bd1045c89578a02402c28356006","modified":1626661154845},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"94826ea6bcc4d2304199adae12c4e2b272caf529","modified":1626661154845},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"f33858ffb9e88191e644796e11d2f901eb332308","modified":1626661154845},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"35f073021db93699fcac9ef351e26c59c31aadf7","modified":1626661154845},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1626661154845},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"8dafc2dcd8c33f70a546fee443f0b6d80b3cd243","modified":1626661154839},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"c16c6eb058af2b36bcd583b2591076c7ebdd51ad","modified":1626661154845},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1626661154845},{"_id":"themes/butterfly/source/css/index.styl","hash":"861998e4ac67a59529a8245a9130d68f826c9c12","modified":1626661154849},{"_id":"themes/butterfly/source/css/var.styl","hash":"4b7ba48942bc25244d155333c3657f5c1448addf","modified":1626661154849},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1626661154849},{"_id":"themes/butterfly/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1626661154849},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1626661154849},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"6c41f49a3e682067533dd9384e6e4511fc3a1349","modified":1626661154837},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1626661154850},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1626661154849},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"889ef16fa34a39e5533bc170e62f20f3450cc522","modified":1626661154838},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"4def0aab9e2172ad1f29abd1535d8e08ff23aa0b","modified":1626661154838},{"_id":"themes/butterfly/source/js/main.js","hash":"8ef2821ceb92d81aa0f8c02ee932f094adcafb2b","modified":1626661154850},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1626661154838},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"e55f8bdb876d5429a908498db1307b94094c0d06","modified":1626661154838},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1626661154838},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1626661154838},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"e2e8d681f183f00ce5ee239c42d2e36b3744daad","modified":1626661154838},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"90d01b88d0f406d00184960b1afe9230aec2ebe6","modified":1626661154837},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"65fa23680af0daf64930a399c2f2ca37809a8149","modified":1626661154838},{"_id":"themes/butterfly/source/js/utils.js","hash":"8319b59c26ce8cd2b0ae7d030c4912215148fa92","modified":1626661154850},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"c205b9fd72b2fe19e6d15c5b5ab0fb38c653032e","modified":1626661154838},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"24370508ee87f14418e8f06e9d79ad8c52a342c4","modified":1626661154838},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"4c3c5cb69b3aead8c232cb0fbc251929f28aad75","modified":1626661154839},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":1626661154838},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"92f81a437c9db49f7ebcf608bc09488ecdb55a21","modified":1626661154838},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"dbec869c62135695495703a29ad7655e9965d461","modified":1626661154839},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"4cfcf0100e37ce91864703cd44f1cb99cb5493ea","modified":1626661154838},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"2fb74d0b0e4b98749427c5a1a1b0acb6c85fadc4","modified":1626661154839},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"93d4ebc7dc8228c7a10ddeb5a553d0dcdabbe145","modified":1626661154839},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":1626661154838},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"1f30952fed73dec21b42e2e30b7fe2e84618d2e4","modified":1626661154839},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"5b404356f311d2ee36478291ca3553210867b738","modified":1626661154839},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"b53a2d4f9c37b375a4446d2273dcfb7712d91b3e","modified":1626661154839},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"292646dfab135973b09f0fa9e3931e83da2ed30e","modified":1626661154839},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"88e3b611b03149665e4113cfa39595c1a3fca7e5","modified":1626661154839},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"b9d54a01d7c2a7a183cb7209e99430ce7fea1fe3","modified":1626661154842},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"d5fec7dedc52ab23865fb4db002755e9bdaadc9f","modified":1626661154843},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"933cb710d2dbcea25c6426a57c6f49d2f48b792c","modified":1626661154843},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"3d8e3706a056389176f55dd21956aabc78046761","modified":1626661154843},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1626661154843},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"1fbecfd299068f90d727f0c8c65e2a792fa6e3e2","modified":1626661154843},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"d50e5c22cd6bc3c378bc581918136746cfa3447f","modified":1626661154843},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1626661154843},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"ae9336bf31cdad08ff586ead4295912a96563c76","modified":1626661154844},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"13dc8ce922e2e2332fe6ad5856ebb5dbf9ea4444","modified":1626661154843},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"0366c658cdcff839aa1df2e2d252a03a53fd427e","modified":1626661154843},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"9c1229af6ab48961021886882c473514101fba21","modified":1626661154844},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1626661154843},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"27afd2274bd5f2cbbf1bad9f0afe2b2b72c213ca","modified":1626661154843},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"0612aaee878f33ea8d3da0293c7dc3b6cd871466","modified":1626661154844},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"438aea3e713ed16b7559b9a80a9c5ec0221263df","modified":1626661154844},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"b5525891f6affd02c1ea3b2327c026882efe428b","modified":1626661154844},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"ae67c6d4130a6c075058a9c1faea1648bcc6f83e","modified":1626661154844},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"eda47f3e807a466ba8275627ea936c5100c43818","modified":1626661154845},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"85e72c70a0cef29e40be1968f5d23b06c6f8e3aa","modified":1626661154846},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"e211efbd1952d4b1b881287aa43423133c1d166e","modified":1626661154845},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"7feb755ca7c22da36bbad11e74ecd95fdcf3b879","modified":1626661154846},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"29f48f9370f245e6e575b5836bccf47eb5688d8b","modified":1626661154846},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"fa7a4c1685f391d60ed863e869b9604b59746c27","modified":1626661154846},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"f1b63892baafa48ab872bc79671d57aafd511f6c","modified":1626661154846},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"7d18a7be9cfea65091de3ef00014063d2d649912","modified":1626661154846},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"dd8cdf639ba2b726437c77fa7aa8d5edbabe8f9b","modified":1626661154846},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"d748951d9fbcd04dda839085af78b01b8fa04cba","modified":1626661154847},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"950cc2afb5c0be5bfc192dc68a2c30c8acfbde95","modified":1626661154846},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"90fe01c968696a9f791cb2b84fca621cbbb56f47","modified":1626661154846},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"0551c5893d1589a3d17ce161e50ecb1d724cc6e8","modified":1626661154847},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"978c397d0966eaf9e6e2afd13866f8f4900b509f","modified":1626661154847},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"7a072589e6097dbe942783131964f2372fdf1eb6","modified":1626661154847},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"ea1ba40dd5954c2ed718a126336fb7f94da4e66f","modified":1626661154847},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"4e629f510b73f998ab208b739c5bd7dcd168d1a7","modified":1626661154847},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"2c5fb77c448ce0a734040c8ce532b28fed688899","modified":1626661154847},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"f168f5c669978f633abe118cdcc4a12cfc883c01","modified":1626661154848},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"f59a9a0059d5261251bdd6de45aa97dd2d11e633","modified":1626661154847},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"6befe4c51b86d0c1de130beeecad9e28d6442713","modified":1626661154848},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"917e0e399e117217184ca63d3eb5c4843bcccf7b","modified":1626661154848},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"1c3f9d7efc3b9dfcfa8926a1132d0c44ffc7d4b2","modified":1626661154848},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"21964fdd6d74ffbea519418bab65024aee5f3736","modified":1626661154848},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"f741e85295ce15c70a6027ec15a542636dd5dcca","modified":1626661154848},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d0386ba6d8d63afc72b9673e8f3e89df6446ffc2","modified":1626661154848},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"86fee274a62f7f034547342930f445c47378eb55","modified":1626661154848},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"1756791581c0ec51cb03353a09dac4778d944349","modified":1626661154848},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"b0488ceacde74af139d66c8db5cb36cc21737b9b","modified":1626661154847},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"6874adc2e276443f354bbe50d0072e9bec37243c","modified":1626661154847},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"53ecae272e16223a436c497abbf25dd5f0fc4aaa","modified":1626661154848},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"2cc49d3f6a6beb9f7bff93e292f88aa5681da1d0","modified":1626661154848},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"90d1ce76b0486ede809bc3b5d4935c22ee376c91","modified":1626661154847},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"7c4152162a03aa8331a783df5695e4ebbb816a8c","modified":1626661154848},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"e554549f0a0ae85362f0b0e8687981741f486f6b","modified":1626661154847},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1626661154849},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1626661154848},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9a881c031f463c486bd25248c2814fd09f97892b","modified":1626661154848},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1626661154850},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"7848ec58c6ec03243abf80a3b22b4dc10f3edf53","modified":1626661154840},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1626661154840},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"ef1b2b5b980d6aeaa5d06b97d1afc9644b155a16","modified":1626661154840},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"bba9871f446c10ffcc8fa9023f5a2eb701a86bae","modified":1626661154840},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1626661154850},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"e3bf847553515174f6085df982f0623e9783db7a","modified":1626661154840},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1626661154840},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"400ce038548d6f9ddb486150c724c87b6923a88b","modified":1626661154840},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1626661154840},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"3f05f8311ae559d768ee3d0925e84ed767c314d3","modified":1626661154841},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1626661154841},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":1626661154841},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"a111407fdcafcf1099e26ffa69786f8822c5d9fb","modified":1626661154841},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"2e52c64e89f16267596a8465841dd46f51820982","modified":1626661154841},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"0b7571919e8ad51285deda56a1868fccf8c563d7","modified":1626661154841},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1626661154841},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"c46a932257212f82e4a9974fbbc5de8878c8b383","modified":1626661154841},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"da9813f8dc0d388869c15413cf056012cfb69e1a","modified":1626661154841},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"bafb3d5710824caa59a56017afb058fd2b4eac65","modified":1626661154841},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"16378d8646ea3f4ac99c18f0296dd85b13f9d775","modified":1626661154842},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"b871ea208e36398b4d668db9a9a0b61c79415381","modified":1626661154842},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1626661154842},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1626661154842},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"f9b00ead54573ba6e6eb33481588af144aab648d","modified":1626661154842},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"360845d02c3864975349ae60b3d0c68253ca001c","modified":1626661154842},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"a47d8f9f593091cc91192c0c49deaa2c0d2317fd","modified":1626661154842},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"34088a15655704d12e9b1807b47b3f6a860c9eec","modified":1626661154842},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"2b45fe09d5b591dca156b76dae99981f8d8e1c61","modified":1626661154842},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"3f3a3cd8bea2103dedd754f767aca5cb84d5f586","modified":1626661154842},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"cb38ffe911023092a90a28f2ba8317a92b22cd0c","modified":1626661154842},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"a2bc2601b7e0ae5caf1fc51a07390562d928620a","modified":1626661154842},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"b443d6b16baf3ea250041342cc0361a42a412b7f","modified":1626661154842},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"59b4c26a827ace5a54855881d199977103ff6f50","modified":1626661154842},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"d8f59e94eafc669c49349561dc5bbea3915aecb7","modified":1626661154843},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1626661154843},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"309f51bc5302e72fc469d54c577fbcfe57fb07a8","modified":1626661154843},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":1626661154843},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"006acc91ce25fc7c7d778ca043e970f57dc46b83","modified":1626661154843},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"f6506ccfd1ce994b9e53aa95588d0b6dbad11411","modified":1626661154842},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"8c0726fb8d9a497d2f900b0be2845efaa68e3d87","modified":1626661154846},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1626661154843},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1626661154846},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"89cbcc8e087788ecec18b5fa58710afacdb7d080","modified":1626661154846},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"e0e7065124ef0d99f8322a47bc47838982e04ad0","modified":1626661154846},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1626661154846},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"613280d61b8ab9612014ec016ae3d3698d36fd1a","modified":1626661154843},{"_id":"public/sitemap.xml","hash":"bbfc8d1b344215a795c842bc2f7390d91875ff90","modified":1626662849243},{"_id":"public/atom.xml","hash":"71b4884abef6ff9a4a1b8df59c8de30d52b3ef10","modified":1626662849243},{"_id":"public/2021/07/13/hello-world/index.html","hash":"b32c3876b50b475ec67ad53ba132f5436e95c81e","modified":1626662849243},{"_id":"public/archives/index.html","hash":"eb56db686af42d989b683ffa85906e03bfe2a34e","modified":1626662849243},{"_id":"public/archives/2021/index.html","hash":"3ae891361d77d702b8bb09cab17834d455f163f4","modified":1626662849243},{"_id":"public/archives/2021/07/index.html","hash":"824b16cacf49137a9cbc9f619a083be8a5e64f96","modified":1626662849243},{"_id":"public/index.html","hash":"beae88aaf340896b8cbf09ba7dfdbdcd3280de24","modified":1626662849243},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1626662849243},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1626662849243},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1626662849243},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1626662849243},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"5f1a807437cc723bcadc3791d37add5ceed566a2","modified":1626662849243},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"3290fe2df45f065b51a1cd7b24ec325cbf9bb5ce","modified":1626662849243},{"_id":"public/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1626662849243},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1626662849243},{"_id":"public/js/utils.js","hash":"8319b59c26ce8cd2b0ae7d030c4912215148fa92","modified":1626662849243},{"_id":"public/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1626662849243},{"_id":"public/css/index.css","hash":"43a3e4279c34ed3542b557ecb49a9681ec61119f","modified":1626662849243},{"_id":"public/js/main.js","hash":"8ef2821ceb92d81aa0f8c02ee932f094adcafb2b","modified":1626662849243},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1626662849243},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"35bb5b588b6de25c9be2dd51d3fd331feafac02d","modified":1626662849243},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"35e71cc2a130199efb167b9a06939576602f0d75","modified":1626662849243},{"_id":"source/_posts/sense-of-ritual.md","hash":"d1e43a83c0baa82147d8bb13a974fa6a8d7f710a","modified":1626664056489},{"_id":"themes/butterfly/source/img/avatat.png","hash":"7f90f86022a42312415fece69802e11cfdb8a3b6","modified":1626663776828},{"_id":"source/_posts/butterfly.md","hash":"d065e93710686aecdd7757a295bb6d3833e74616","modified":1626664921366},{"_id":"source/_posts/Koa2入门小基础.md","hash":"eeba9268b5c07f9440f34db5c49700449bfeee2a","modified":1626674006049},{"_id":"source/_posts/MongoDB基础入门.md","hash":"425e2cbc974b5a0d2f44ef68a87f2515a7b97d19","modified":1626674009406},{"_id":"source/_posts/hexo入门.md","hash":"1833e07be4645615718763af6bffbd02ec710055","modified":1626664408201},{"_id":"source/_posts/vscode-sync-setting.md","hash":"1330c31331f0a015c692c1a915fe6bca30ad9b18","modified":1626673939386},{"_id":"source/_posts/vscode-tips.md","hash":"a01aca7ddeb94c44c6fb49b7e8ce1b6e4fe5cab8","modified":1626673934524},{"_id":"source/_posts/常用前端面试参考总结.md","hash":"78f379343c324a2bb968c8da9479efac0da94870","modified":1626673976184},{"_id":"source/_posts/前端面试题积累.md","hash":"f303c5de754de2adcc713b481a1993bcb76c8dbf","modified":1626673989722},{"_id":"source/_posts/异步编程.md","hash":"b76ca770e61dff3c66116de76dbaca41bd3ea9fe","modified":1626674036480},{"_id":"themes/butterfly/source/css/background.css","hash":"b8f414cd2fb0e6a175bd4573e78f099a89579fd9","modified":1626675788240},{"_id":"themes/butterfly/source/img/baiyue.png","hash":"b97e7a10e2817a046dcb2b98a52801cbd02cac54","modified":1626674883146}],"Category":[],"Data":[],"Page":[],"Post":[{"_content":"> 命运善嫉，总吝啬赋予世人恒久的平静，\n> 总猝不及防的把人一下子塞进过山车，\n> 任你怎么恐惧挣扎也不肯轻易停下来，\n> 非要把圆满的颠簸成支离破碎的，\n> 再命你耗尽半生去拼补……\n> From 知乎 / 你一生的最低点是怎样的经历？","source":"_posts/hello-world.md","raw":"> 命运善嫉，总吝啬赋予世人恒久的平静，\n> 总猝不及防的把人一下子塞进过山车，\n> 任你怎么恐惧挣扎也不肯轻易停下来，\n> 非要把圆满的颠簸成支离破碎的，\n> 再命你耗尽半生去拼补……\n> From 知乎 / 你一生的最低点是怎样的经历？","slug":"hello-world","published":1,"date":"2021-07-13T06:51:08.365Z","updated":"2021-07-13T07:51:59.214Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ckra127mj0000ixzthfjwgvzb","content":"<blockquote>\n<p>命运善嫉，总吝啬赋予世人恒久的平静，<br>总猝不及防的把人一下子塞进过山车，<br>任你怎么恐惧挣扎也不肯轻易停下来，<br>非要把圆满的颠簸成支离破碎的，<br>再命你耗尽半生去拼补……<br>From 知乎 / 你一生的最低点是怎样的经历？</p>\n</blockquote>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<blockquote>\n<p>命运善嫉，总吝啬赋予世人恒久的平静，<br>总猝不及防的把人一下子塞进过山车，<br>任你怎么恐惧挣扎也不肯轻易停下来，<br>非要把圆满的颠簸成支离破碎的，<br>再命你耗尽半生去拼补……<br>From 知乎 / 你一生的最低点是怎样的经历？</p>\n</blockquote>\n"},{"title":"没有仪式感的人生，永远都是灰头土脸","date":"2020-03-17T16:18:11.000Z","type":"随笔","note":"仪式感之所以重要，是通过不断暗示自己，强化精神，能够让我们继续坚持枯燥的生活，在遇到变故或者彷徨无助的时候，带来希望。","_content":"\n　　村上春树说：仪式是一件很重要的事情。\n\n  <!--more-->\n\n　　喝牛奶时，你特意替我擦掉嘴边的白泡沫，是仪式。\n　　出门时，你特意把我的领带给调整好，是仪式。\n　　走路时，你特意蹲下来帮我系好鞋带，是仪式。\n　　逛街时，你特意记得我喜欢的衣服买来送给我，是仪式。\n　　别人生日你切蛋糕下去的第一刀是仪式，拆掉新书的塑料包装也是仪式。\n　　其实仪式就是把本来单调普通的事情，变得不一样。\n　　仪式是让我们对所在意的事情，怀有敬畏。\n\n　　01. 婚姻里的仪式感。\n\n　　普华永道的老总唐徽，她曾说结婚十几年了，她雷打不动的规定就是每周五和先生约会。她老公是一个喜欢吃意大利餐的美国男人，所以他们每周五晚餐都会坐在高档的意大利餐厅享受美食。\n　　她说仪式感是婚姻中不可或缺的元素，因为它会时时刻刻提醒夫妻俩人，必须认真、敬畏得去经营婚姻。\n　　朋友A是一个婚姻心理咨询师，他和说曾说过一个案例。丈夫和妻子结婚8年多了，每次遇到重要的节日时，丈夫提议出去庆祝一下，而妻子每次都说要花多少多少钱，要节省钱就不去了，结婚8年竟然难忘的日子没有几个。\n　　后来他们离婚了，丈夫遇到节日都会欢欢喜喜和新的伴侣出去庆祝，在新的婚姻里如鱼得水。可是这时，前妻却无法释怀了，生活一直过得不好，常常跑心理咨询室解决心理问题。\n　　仪式感是获得安全感的源泉之一。\n　　很多女孩子描述恋爱细节都会这样说：我记得那天我生日，他特地来看我，陪我在哪里做了什么，送了我什么礼物，对我说了什么话，他对我很用心，我觉得很幸福。\n　　从感性的角度，在某事某刻特别用心做某事，带有仪式感，让人刻骨铭心。\n　　女孩子都向往一场浪漫的婚礼，很多细节都会有特别的要求，在那个仪式上彼此说着爱的誓言，一生中记忆最深的莫过于此吧。\n　　因为有仪式感，你才记得那天的阳光和白云，还有他身旁的微风和眼中的光芒。\n\n　　02. 生活里的仪式感。\n\n　　记得一个牛津大学毕业的著名学者说过他上学的事情：在他上高中的时候，父亲每次接他、送他的前一天，都会认真去洗一次车，而且要洗得非常干净。\n　　父亲的洗车让他觉得上学有了仪式感，也特别用心。\n　　在我家里有一个不成文的规定，就是：一家人吃饭必须围着桌子一起吃饭，不能看电视，不能一个个东奔西跑。\n　　母亲常说：民以食为天，对于食物我们应该怀有敬畏心理，人家老外吃饭前还要祷告咧，家的意思不就是一家人常常在一起吃饭么！\n　　家里不管是哪个人过生日，父母必将准备丰盛的菜肴，一家人都要穿上最好的衣服，来庆祝这个特别的节日，像是参加一个重大的仪式。\n　　母亲还有一个歪理：连吃饭都不能好好聚在一起的家庭，走不远。\n　　于是我开始观察了几个街坊邻居，居然还真的是母亲说的那样。就拿我家的邻居来说吧，妇女做完饭就会端着饭跑到外面去和别人聊天，子女端着饭边看电视看吃，丈夫端着饭坐在门口台阶上。\n　　果然，没几日妇女就和别的男人跑了，过了一段时间又回来了。于是野男人和家里的男人引发了战争，女儿写信给母亲要断绝母女关系。\n　　从此这个家庭一地鸡毛，狼狈不堪，争吵的响声常常传到我家里。\n　　一家人一起认真吃饭，这是我们家里的仪式感，每当我想家的时候，出现最多的画面就是一家人开开心心吃饭的场景。\n　　第三季《唐顿庄园》中有一次因为炉子坏了，唐顿第一次放弃了繁文缛节。他和别人谈论此事时，显得对生活中的仪式感非常着迷。\n　　他说：“你厌倦了生活中的格调，就是厌倦了生活。”\n\n\n　　我们成长、我们毕业、我们离开，我们需要一个个的仪式来对过去的自己告别，然后重新开始新的生活。\n　　王阳明名言：你未看此花时，此花与汝心同归于寂。你来看此花时，则此花颜色一时明白起来。\n　　一切繁杂里才能照见简单，一切世俗中才能照见脱俗，一切喧闹中才能照见宁静。在如今缺乏仪式感的国度里，我们会失去很多觉察的机会。\n　　不敬天地，不敬鬼神，觉察自然也会离我们越来越远。\n　　仪式感之所以重要，是通过不断暗示自己，强化精神，能够让我们继续坚持枯燥的生活，在遇到变故或者彷徨无助的时候，带来希望。\n\n   文/肖卓","source":"_posts/sense-of-ritual.md","raw":"---\ntitle: 没有仪式感的人生，永远都是灰头土脸\ndate: 2020-03-18 00:18:11\ntype: 随笔\ntags: 人生\nnote: 仪式感之所以重要，是通过不断暗示自己，强化精神，能够让我们继续坚持枯燥的生活，在遇到变故或者彷徨无助的时候，带来希望。\n---\n\n　　村上春树说：仪式是一件很重要的事情。\n\n  <!--more-->\n\n　　喝牛奶时，你特意替我擦掉嘴边的白泡沫，是仪式。\n　　出门时，你特意把我的领带给调整好，是仪式。\n　　走路时，你特意蹲下来帮我系好鞋带，是仪式。\n　　逛街时，你特意记得我喜欢的衣服买来送给我，是仪式。\n　　别人生日你切蛋糕下去的第一刀是仪式，拆掉新书的塑料包装也是仪式。\n　　其实仪式就是把本来单调普通的事情，变得不一样。\n　　仪式是让我们对所在意的事情，怀有敬畏。\n\n　　01. 婚姻里的仪式感。\n\n　　普华永道的老总唐徽，她曾说结婚十几年了，她雷打不动的规定就是每周五和先生约会。她老公是一个喜欢吃意大利餐的美国男人，所以他们每周五晚餐都会坐在高档的意大利餐厅享受美食。\n　　她说仪式感是婚姻中不可或缺的元素，因为它会时时刻刻提醒夫妻俩人，必须认真、敬畏得去经营婚姻。\n　　朋友A是一个婚姻心理咨询师，他和说曾说过一个案例。丈夫和妻子结婚8年多了，每次遇到重要的节日时，丈夫提议出去庆祝一下，而妻子每次都说要花多少多少钱，要节省钱就不去了，结婚8年竟然难忘的日子没有几个。\n　　后来他们离婚了，丈夫遇到节日都会欢欢喜喜和新的伴侣出去庆祝，在新的婚姻里如鱼得水。可是这时，前妻却无法释怀了，生活一直过得不好，常常跑心理咨询室解决心理问题。\n　　仪式感是获得安全感的源泉之一。\n　　很多女孩子描述恋爱细节都会这样说：我记得那天我生日，他特地来看我，陪我在哪里做了什么，送了我什么礼物，对我说了什么话，他对我很用心，我觉得很幸福。\n　　从感性的角度，在某事某刻特别用心做某事，带有仪式感，让人刻骨铭心。\n　　女孩子都向往一场浪漫的婚礼，很多细节都会有特别的要求，在那个仪式上彼此说着爱的誓言，一生中记忆最深的莫过于此吧。\n　　因为有仪式感，你才记得那天的阳光和白云，还有他身旁的微风和眼中的光芒。\n\n　　02. 生活里的仪式感。\n\n　　记得一个牛津大学毕业的著名学者说过他上学的事情：在他上高中的时候，父亲每次接他、送他的前一天，都会认真去洗一次车，而且要洗得非常干净。\n　　父亲的洗车让他觉得上学有了仪式感，也特别用心。\n　　在我家里有一个不成文的规定，就是：一家人吃饭必须围着桌子一起吃饭，不能看电视，不能一个个东奔西跑。\n　　母亲常说：民以食为天，对于食物我们应该怀有敬畏心理，人家老外吃饭前还要祷告咧，家的意思不就是一家人常常在一起吃饭么！\n　　家里不管是哪个人过生日，父母必将准备丰盛的菜肴，一家人都要穿上最好的衣服，来庆祝这个特别的节日，像是参加一个重大的仪式。\n　　母亲还有一个歪理：连吃饭都不能好好聚在一起的家庭，走不远。\n　　于是我开始观察了几个街坊邻居，居然还真的是母亲说的那样。就拿我家的邻居来说吧，妇女做完饭就会端着饭跑到外面去和别人聊天，子女端着饭边看电视看吃，丈夫端着饭坐在门口台阶上。\n　　果然，没几日妇女就和别的男人跑了，过了一段时间又回来了。于是野男人和家里的男人引发了战争，女儿写信给母亲要断绝母女关系。\n　　从此这个家庭一地鸡毛，狼狈不堪，争吵的响声常常传到我家里。\n　　一家人一起认真吃饭，这是我们家里的仪式感，每当我想家的时候，出现最多的画面就是一家人开开心心吃饭的场景。\n　　第三季《唐顿庄园》中有一次因为炉子坏了，唐顿第一次放弃了繁文缛节。他和别人谈论此事时，显得对生活中的仪式感非常着迷。\n　　他说：“你厌倦了生活中的格调，就是厌倦了生活。”\n\n\n　　我们成长、我们毕业、我们离开，我们需要一个个的仪式来对过去的自己告别，然后重新开始新的生活。\n　　王阳明名言：你未看此花时，此花与汝心同归于寂。你来看此花时，则此花颜色一时明白起来。\n　　一切繁杂里才能照见简单，一切世俗中才能照见脱俗，一切喧闹中才能照见宁静。在如今缺乏仪式感的国度里，我们会失去很多觉察的机会。\n　　不敬天地，不敬鬼神，觉察自然也会离我们越来越远。\n　　仪式感之所以重要，是通过不断暗示自己，强化精神，能够让我们继续坚持枯燥的生活，在遇到变故或者彷徨无助的时候，带来希望。\n\n   文/肖卓","slug":"sense-of-ritual","published":1,"updated":"2021-07-19T03:07:36.489Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckra1uprq00002nzt7hssfto4","content":"<p>　　村上春树说：仪式是一件很重要的事情。</p>\n  <span id=\"more\"></span>\n\n<p>　　喝牛奶时，你特意替我擦掉嘴边的白泡沫，是仪式。<br>　　出门时，你特意把我的领带给调整好，是仪式。<br>　　走路时，你特意蹲下来帮我系好鞋带，是仪式。<br>　　逛街时，你特意记得我喜欢的衣服买来送给我，是仪式。<br>　　别人生日你切蛋糕下去的第一刀是仪式，拆掉新书的塑料包装也是仪式。<br>　　其实仪式就是把本来单调普通的事情，变得不一样。<br>　　仪式是让我们对所在意的事情，怀有敬畏。</p>\n<p>　　01. 婚姻里的仪式感。</p>\n<p>　　普华永道的老总唐徽，她曾说结婚十几年了，她雷打不动的规定就是每周五和先生约会。她老公是一个喜欢吃意大利餐的美国男人，所以他们每周五晚餐都会坐在高档的意大利餐厅享受美食。<br>　　她说仪式感是婚姻中不可或缺的元素，因为它会时时刻刻提醒夫妻俩人，必须认真、敬畏得去经营婚姻。<br>　　朋友A是一个婚姻心理咨询师，他和说曾说过一个案例。丈夫和妻子结婚8年多了，每次遇到重要的节日时，丈夫提议出去庆祝一下，而妻子每次都说要花多少多少钱，要节省钱就不去了，结婚8年竟然难忘的日子没有几个。<br>　　后来他们离婚了，丈夫遇到节日都会欢欢喜喜和新的伴侣出去庆祝，在新的婚姻里如鱼得水。可是这时，前妻却无法释怀了，生活一直过得不好，常常跑心理咨询室解决心理问题。<br>　　仪式感是获得安全感的源泉之一。<br>　　很多女孩子描述恋爱细节都会这样说：我记得那天我生日，他特地来看我，陪我在哪里做了什么，送了我什么礼物，对我说了什么话，他对我很用心，我觉得很幸福。<br>　　从感性的角度，在某事某刻特别用心做某事，带有仪式感，让人刻骨铭心。<br>　　女孩子都向往一场浪漫的婚礼，很多细节都会有特别的要求，在那个仪式上彼此说着爱的誓言，一生中记忆最深的莫过于此吧。<br>　　因为有仪式感，你才记得那天的阳光和白云，还有他身旁的微风和眼中的光芒。</p>\n<p>　　02. 生活里的仪式感。</p>\n<p>　　记得一个牛津大学毕业的著名学者说过他上学的事情：在他上高中的时候，父亲每次接他、送他的前一天，都会认真去洗一次车，而且要洗得非常干净。<br>　　父亲的洗车让他觉得上学有了仪式感，也特别用心。<br>　　在我家里有一个不成文的规定，就是：一家人吃饭必须围着桌子一起吃饭，不能看电视，不能一个个东奔西跑。<br>　　母亲常说：民以食为天，对于食物我们应该怀有敬畏心理，人家老外吃饭前还要祷告咧，家的意思不就是一家人常常在一起吃饭么！<br>　　家里不管是哪个人过生日，父母必将准备丰盛的菜肴，一家人都要穿上最好的衣服，来庆祝这个特别的节日，像是参加一个重大的仪式。<br>　　母亲还有一个歪理：连吃饭都不能好好聚在一起的家庭，走不远。<br>　　于是我开始观察了几个街坊邻居，居然还真的是母亲说的那样。就拿我家的邻居来说吧，妇女做完饭就会端着饭跑到外面去和别人聊天，子女端着饭边看电视看吃，丈夫端着饭坐在门口台阶上。<br>　　果然，没几日妇女就和别的男人跑了，过了一段时间又回来了。于是野男人和家里的男人引发了战争，女儿写信给母亲要断绝母女关系。<br>　　从此这个家庭一地鸡毛，狼狈不堪，争吵的响声常常传到我家里。<br>　　一家人一起认真吃饭，这是我们家里的仪式感，每当我想家的时候，出现最多的画面就是一家人开开心心吃饭的场景。<br>　　第三季《唐顿庄园》中有一次因为炉子坏了，唐顿第一次放弃了繁文缛节。他和别人谈论此事时，显得对生活中的仪式感非常着迷。<br>　　他说：“你厌倦了生活中的格调，就是厌倦了生活。”</p>\n<p>　　我们成长、我们毕业、我们离开，我们需要一个个的仪式来对过去的自己告别，然后重新开始新的生活。<br>　　王阳明名言：你未看此花时，此花与汝心同归于寂。你来看此花时，则此花颜色一时明白起来。<br>　　一切繁杂里才能照见简单，一切世俗中才能照见脱俗，一切喧闹中才能照见宁静。在如今缺乏仪式感的国度里，我们会失去很多觉察的机会。<br>　　不敬天地，不敬鬼神，觉察自然也会离我们越来越远。<br>　　仪式感之所以重要，是通过不断暗示自己，强化精神，能够让我们继续坚持枯燥的生活，在遇到变故或者彷徨无助的时候，带来希望。</p>\n<p>   文/肖卓</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"<p>　　村上春树说：仪式是一件很重要的事情。</p>","more":"<p>　　喝牛奶时，你特意替我擦掉嘴边的白泡沫，是仪式。<br>　　出门时，你特意把我的领带给调整好，是仪式。<br>　　走路时，你特意蹲下来帮我系好鞋带，是仪式。<br>　　逛街时，你特意记得我喜欢的衣服买来送给我，是仪式。<br>　　别人生日你切蛋糕下去的第一刀是仪式，拆掉新书的塑料包装也是仪式。<br>　　其实仪式就是把本来单调普通的事情，变得不一样。<br>　　仪式是让我们对所在意的事情，怀有敬畏。</p>\n<p>　　01. 婚姻里的仪式感。</p>\n<p>　　普华永道的老总唐徽，她曾说结婚十几年了，她雷打不动的规定就是每周五和先生约会。她老公是一个喜欢吃意大利餐的美国男人，所以他们每周五晚餐都会坐在高档的意大利餐厅享受美食。<br>　　她说仪式感是婚姻中不可或缺的元素，因为它会时时刻刻提醒夫妻俩人，必须认真、敬畏得去经营婚姻。<br>　　朋友A是一个婚姻心理咨询师，他和说曾说过一个案例。丈夫和妻子结婚8年多了，每次遇到重要的节日时，丈夫提议出去庆祝一下，而妻子每次都说要花多少多少钱，要节省钱就不去了，结婚8年竟然难忘的日子没有几个。<br>　　后来他们离婚了，丈夫遇到节日都会欢欢喜喜和新的伴侣出去庆祝，在新的婚姻里如鱼得水。可是这时，前妻却无法释怀了，生活一直过得不好，常常跑心理咨询室解决心理问题。<br>　　仪式感是获得安全感的源泉之一。<br>　　很多女孩子描述恋爱细节都会这样说：我记得那天我生日，他特地来看我，陪我在哪里做了什么，送了我什么礼物，对我说了什么话，他对我很用心，我觉得很幸福。<br>　　从感性的角度，在某事某刻特别用心做某事，带有仪式感，让人刻骨铭心。<br>　　女孩子都向往一场浪漫的婚礼，很多细节都会有特别的要求，在那个仪式上彼此说着爱的誓言，一生中记忆最深的莫过于此吧。<br>　　因为有仪式感，你才记得那天的阳光和白云，还有他身旁的微风和眼中的光芒。</p>\n<p>　　02. 生活里的仪式感。</p>\n<p>　　记得一个牛津大学毕业的著名学者说过他上学的事情：在他上高中的时候，父亲每次接他、送他的前一天，都会认真去洗一次车，而且要洗得非常干净。<br>　　父亲的洗车让他觉得上学有了仪式感，也特别用心。<br>　　在我家里有一个不成文的规定，就是：一家人吃饭必须围着桌子一起吃饭，不能看电视，不能一个个东奔西跑。<br>　　母亲常说：民以食为天，对于食物我们应该怀有敬畏心理，人家老外吃饭前还要祷告咧，家的意思不就是一家人常常在一起吃饭么！<br>　　家里不管是哪个人过生日，父母必将准备丰盛的菜肴，一家人都要穿上最好的衣服，来庆祝这个特别的节日，像是参加一个重大的仪式。<br>　　母亲还有一个歪理：连吃饭都不能好好聚在一起的家庭，走不远。<br>　　于是我开始观察了几个街坊邻居，居然还真的是母亲说的那样。就拿我家的邻居来说吧，妇女做完饭就会端着饭跑到外面去和别人聊天，子女端着饭边看电视看吃，丈夫端着饭坐在门口台阶上。<br>　　果然，没几日妇女就和别的男人跑了，过了一段时间又回来了。于是野男人和家里的男人引发了战争，女儿写信给母亲要断绝母女关系。<br>　　从此这个家庭一地鸡毛，狼狈不堪，争吵的响声常常传到我家里。<br>　　一家人一起认真吃饭，这是我们家里的仪式感，每当我想家的时候，出现最多的画面就是一家人开开心心吃饭的场景。<br>　　第三季《唐顿庄园》中有一次因为炉子坏了，唐顿第一次放弃了繁文缛节。他和别人谈论此事时，显得对生活中的仪式感非常着迷。<br>　　他说：“你厌倦了生活中的格调，就是厌倦了生活。”</p>\n<p>　　我们成长、我们毕业、我们离开，我们需要一个个的仪式来对过去的自己告别，然后重新开始新的生活。<br>　　王阳明名言：你未看此花时，此花与汝心同归于寂。你来看此花时，则此花颜色一时明白起来。<br>　　一切繁杂里才能照见简单，一切世俗中才能照见脱俗，一切喧闹中才能照见宁静。在如今缺乏仪式感的国度里，我们会失去很多觉察的机会。<br>　　不敬天地，不敬鬼神，觉察自然也会离我们越来越远。<br>　　仪式感之所以重要，是通过不断暗示自己，强化精神，能够让我们继续坚持枯燥的生活，在遇到变故或者彷徨无助的时候，带来希望。</p>\n<p>   文/肖卓</p>"},{"title":"mongodb基础入门","date":"2021-03-18T00:00:00.000Z","type":"技术","sidebarDepth":3,"sidebar":"auto","note":"MongoDB是一个基于分布式文件存储的数据库，非关系型数据库。","_content":"\n# MongoDB基础入门\n\n学习指导：[挑战全栈 MongoDB基础视频教程 (共21集)](http://www.jspang.com/posts/2017/12/16/mongodb.html)\n\n参考：[MongoDB 教程 | 菜鸟教程](https://www.runoob.com/mongodb/mongodb-tutorial.html)\n\n## 第01节：认识和安装MongoDB\n\n* **MongoDB是非关系型数据库**，要了解非关系型数据库就必须先了解关系型数据库，关系数据库，是建立在关系模型基础上的数据库。比较有名气的关系型数据库，比如Oracle、DB2、MSSQL、Mysql。\n\n* 非关系数据库和关系型数据库的区别是什么？\n\n  * 实质：非关系型数据库的实质：非关系型数据库产品是传统关系型数据库的功能阉割版，通过减少用不到或很少用的功能，来大幅度提高产品性能。\n  * 价格：目前的非关系型数据库基本都是免费的，而比较有名气的关系型数据库都是收费的，比如：Oracle、DB2、MSSQL。MySql虽然是免费的，但是处理大型数据还是要提前作很多工作的。\n  * 功能：实际开发中，很多业务需求，其实并不需要完整的关系型数据库功能，非关系型数据库的功能就足够使用了。这种情况下，使用性能更高、成本更低的非关系型数据库当然是更明智的选择。\n\n* 了解关系型数据库和非关系型数据库的区别后，需要有一点的取舍，**比较复杂和大型的项目不建议使用非关系型数据库**，但是如果你想作个博客，CMS系统这类业务逻辑不复杂的程序，MongoDB是完全可以胜任的。\n\n* MongoDB简介：\n\n  * MongoDB是一个基于分布式文件存储的数据库，由C++语言编写。目的是为WEB应用提供扩展的高性能的数据存储解决方案。\n  * MongoDB是一个介于关系型数据库和非关系型数据库之间的产品，是非关系型数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。\n  * Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。\n\n* 安装忽略\n\n* **运行MongoDB服务端：**\n\n  * 安装好MongoDB数据库后，我们需要启用服务端才能使用。启用服务的命令是：Mongod。\n  * 打开命令行: 先打开运行（快捷键win+R），然后输入cmd后回车，就可以打开命令行工具。\n  * 执行mongod: 在命令中直接输入mongod，但是你会发现服务并没有启动，报了一个exception，服务停止了。\n  * 新建文件夹:出现上边的错误，是因为我们没有简历Mongodb需要的文件夹，`一般是安装盘的根目录，建立data/db,这两个文件夹`。\n  * 运行mongod：这时候服务就可以开启了，链接默认端口是27017。\n\n* **链接服务：**\n\n  ```bash\n  # cmd 输入 mongo\n  mongo\n  \n  #查看存在数据库命令：\n  show dbs\n  \n  # 查看数据库版本命令：\n  db.version()\n  ```\n\n## 第02节：Mongo基本命令-1\n\n* **MongoDB的存储结构** 以前我们的关系型数据库的数据结构都是顶层是库，库下面是表，表下面是数据。但是MongoDB有所不同，库下面是集合，集合下面是文件。\n\n* **基础Shell命令：**\n  * `show dbs` :显示已有数据库，如果你刚安装好，会默认有`local、admin、config`，这是MongoDB的默认数据库，我们在新建库时是不允许起这些名称的。\n  * `use admin`： 进入数据，也可以理解成为使用数据库。成功会显示：switched to db admin。\n  * `show collections`: 显示数据库中的集合（关系型中叫表，我们要逐渐熟悉）。\n  * `db`:显示当前位置，也就是你当前使用的数据库名称，这个命令算是最常用的，因为你在作任何操作的时候都要先查看一下自己所在的库，以免造成操作错误。\n\n## 第03节：Mongo基本命令-2\n\n* **数据操作基础命令：**\n  * `use db（建立数据库）`：use不仅可以进入一个数据库，如果你敲入的库不存在，它还可以帮你建立一个库。但是在没有集合前，它还是默认为空。\n\n  * `db.集合.insert( )`:新建数据集合和插入文件（数据），当集合没有时，这时候就可以新建一个集合，并向里边插入数据。\n\n    ```bash\n    db.user.insert({“name”:”jspang”})\n    ```\n\n  * `db.集合.find( )`:查询所有数据，这条命令会列出集合下的所有数据，可以看到MongoDB是自动给我们加入了索引值的。\n\n    ```bash\n    db.user.find()\n    ```\n\n  * `db.集合.findOne( )`:查询第一个文件数据，这里需要注意的，所有MongoDB的组合单词都使用首字母小写的驼峰式写法。\n\n  * `db.集合.update({查询},{修改})`:修改文件数据，第一个是查询条件，第二个是要修改成的值。这里注意的是可以多加文件数据项的，比如下面的例子。\n\n    ```bash\n    db.jspang.update({\"name\":\"jspang\"},{\"name\":\"jspang\",\"age\":\"32\"})\n    ```\n\n  * `db.集合.remove(条件)`：删除文件数据，注意的是要跟一个条件。\n\n    ```bash\n    db.user.remove({“name”:”jspang”})\n    ```\n\n  * `db.集合.drop()`:删除整个集合，这个在实际工作中一定要谨慎使用，如果是程序，一定要二次确认。\n\n  * `db.dropDatabase()`: 删除整个数据库，在删除库时，一定要先进入数据库，然后再删除。实际工作中这个基本不用，实际工作可定需要保留数据和痕迹的。\n\n## 第04节：用js文件写mongo命令\n\n* 编写执行代码\n\n  ```javascript\n  // ./mongoShell/goTask.js\n  \n  var userName = 'jspang'  // 声明一个登录名  \n  var timeStamp = Date.parse(new Date()) // 声明登录时的时间戳  \n  var jsonDdatabase = {  // 组成JSON字符串\n    \"loginUnser\": userName,\n    \"loginTime\": timeStamp\n  }\n  var db = connect('log')  //链接数据库\n  db.login.insert(jsonDdatabase) //插入数据\n  \n  print('[demo]log  print success')  //没有错误显示成功\n  ```\n\n* 执行\n\n  ```bash\n  # 链接数据库(cmd)\n  mongo\n  \n  mongo goTask.js\n  \n  show dbs\n  use log\n  show collections\n  db.login.find()\n  ```\n\n## 第05节：批量插入的正确方法\n\n* 在操作数据库时要注意两个能力：\n  * 第一个是快速存储能力。\n  * 第二个是方便迅速查询能力。\n\n* **批量插入**\n\n  * 批量数据插入是以数组的方式进行的（如果写错，可以3个回车可以切出来）\n\n  * 插入数据测试\n\n    ```bash\n    db.test.insert([\n        {\"_id\":1},\n        {\"_id\":2},\n        {\"_id\":3}\n    ])\n\n    # 3.2版本以前的用法\n    db.test.batchInsert([\n        {\"_id\":1},\n        {\"_id\":2},\n        {\"_id\":3}\n    ])\n    ```\n\n  * 注意一次插入不要超过48M，向.zip和大图片什么的尽量用静态存储，MongoDB存储静态路径就好。\n\n* **批量插入性能测试**\n\n  ```bash\n  # 一个个插入  执行insertTest1.js  耗时622ms\n  mongo insertTest1.js\n  \n  # 批量插入  执行insertTest2.js  耗时15ms\n  mongo insertTest2.js\n  ```\n\n* 总结：在工作中一定要照顾数据库性能，这也是你水平的提现，一个技术会了很简单，但是要作精通不那么简单。学完这节，记得在工作中如果在循环插入和批量插入举起不定，那就选批量插入吧，它会给我们更优的性能体验。\n\n* 范式流程：\n\n  ```javascript\n  var db = connect('company')  // 连接数据库\n  var workmateArray = [workmate1, workmate2, workmate3]\n  db.workmate.insert(workmateArray)  // 数据库插入集合\n  print('[SUCCESS]: The data was inserted successfully.');\n  ```\n\n  \n\n## 第06节：修改：Update常见错误\n\n了解常见的错误操作\n\n## 第07节：修改：初识update修改器\n\n* **`$set`修改器**\n\n  用来修改一个指定的键值(key)，这时候我们要修改上节课的sex和age就非常方便了，只要一句话就可以搞定。\n\n  ```javascript\n  db.workmate.update({ \"name\":\"MinJie\" }, { \"$set\": {sex:2,age:21} })\n  ```\n\n  修改好后，我们可以用db.workmate.find()来进行查看\n\n* **修改嵌套内容(内嵌文档)**\n\n  skill数据是内嵌的，这时候我们可以属性的形式进行修改，skill.skillThree\n\n  ```javascript\n  db.workmate.update({ \"name\": \"MinJie\" }, { $set: { \"skill.skillThree\": 'word' } })\n  ```\n\n* **`$unset`用于将key删除**\n\n  作用其实就是删除一个key值和键\n\n  ```javascript\n  db.workmate.update({ \"name\": \"MinJie\" }, { $unset: { \"age\": '' } })\n  \n  // 直接用set进行添加\n  ```\n\n* **`$inc`对数字进行计算**\n\n  ```javascript\n  db.workmate.update({ \"name\": \"MinJie\" }, { $inc: { \"age\": -2 } })\n  ```\n\n* **`multi`选项**\n\n  ```javascript\n  db.workmate.update({}, { $set: { interset: ['basketball'] } }, { multi: true })\n  \n  //每个数据都发生了改变，multi是有ture和false两个值，true代表全部修改，false代表只修改一个（默认值）\n  ```\n\n* **`upsert`选项**\n\n  upsert是在找不到值的情况下，直接插入这条数据\n\n  ```javascript\n  db.workmate.update({ name: 'xiaoWang' }, { $set: { age: 20 } }, { upsert: true })\n  \n  // upsert也有两个值：true代表没有就添加，false代表没有不添加(默认值)\n  ```\n\n## [#](http://www.jspang.com/posts/2017/12/16/mongodb.html#第08节：修改：update数组修改器)第08节：修改：update数组修改器\n\n* **`$push`追加数组/内嵌文档值**\n\n  `$push`的功能是追加数组中的值，但我们也经常用它操作内嵌稳文档，就是{}对象型的值\n\n  ```javascript\n  // $push追加数组/内嵌文档值\n  db.workmate.update({ name: 'xiaoWang' }, { $push: { interest: 'draw' } })\n  \n  // $push修饰符还可以为内嵌文档增加值\n  db.workmate.update({ name: 'MinJie' }, { $push: { \"skill.skillFour\": 'draw' } })\n  ```\n\n  **`$push`修饰符还可以为内嵌文档增加值**\n\n* **`$ne`查找是否存在**\n\n  **检查一个值是否存在，如果不存在再执行操作，存在就不执行**\n\n  ```javascript\n  db.workmate.update({ name: 'xiaoWang', \"interest\": { $ne: 'playGame' } }, { $push: { interest: 'playGame' } })\n  \n  // 总结：没有则修改，有则不修改。\n  ```\n\n* **`$addToSet` 升级版的`$ne`**\n\n  `$ne`的升级版本（查找是否存在，不存在就push上去），操作起来更直观和方便，所以再工作中这个要比`$en`用的多。\n\n  ```javascript\n  // 查看小王(xiaoWang)兴趣(interest)中有没有阅读（readBook）这项，没有则加入读书(readBook)的兴趣.\n  \n  db.workmate.update({ name: \"xiaoWang\" }, { $addToSet: { interest: \"readBook\" } })\n  ```\n\n* **`$each`批量追加**\n\n  可以传入一个数组，一次增加多个值进去，相当于批量操作，性能同样比循环操作要好很多，这个是需要我们注意的，工作中也要先组合成数组，然后用批量的形式进行操作。\n\n  ```javascript\n  // 给xiaoWang,一次加入三个爱好，唱歌（Sing），跳舞（Dance），编码（Code）\n  \n  var newInterset = [\"Sing\", \"Dance\", \"Code\"]\n  db.workmate.update({ name: \"xiaoWang\" }, { $addToSet: { interest: { $each: newInterset } } })\n  ```\n\n* **`$pop` 删除数组值**\n\n  `$pop`只删除一次，并不是删除所有数组中的值。而且它有两个选项，一个是1和-1。\n\n    1：从数组末端进行删除；  -1：从数组开端进行删除\n\n  ```javascript\n  db.workmate.update({ name: 'xiaoWang' }, { $pop: { interest: 1 } })\n  ```\n\n* **`interest.int` 数组定位修改**\n\n  修改数组的第几位，但并不知道是什么，这时候我们可以使用`interest.int` 的形式\n\n  ```javascript\n  // 修改xiaoWang的第三个兴趣为编码（Code），注意这里的计数是从0开始的\n  \n  db.workmate.update({ name: 'xiaoWang' }, { $set: { \"interest.2\": \"Code\" } })\n  ```\n\n## 第09节：修改：状态返回与安全\n\n在修改时我们都会用`findAndModify`，它可以给我们返回来一些必要的参数，让我们对修改多了很多控制力，控制力的加强也就是对安全的强化能力加强。\n\n* **应答式写入**\n\n  在之前的操作都是非应答式写入，就是在操作完数据库后，它并没有给我们任何的回应和返回值，而是我们自己安慰自己写了一句话 `print(‘[update]:The data was updated successfully’)`。这在工作中是不允许的，因为根本不能提现我们修改的结果。应答式写入就会给我们直接返回结果（报表），结果里边的包含项会很多，这样我们就可以很好的进行程序的控制和安全机制的处理。有点像前端调用后端接口，无论作什么，后端都要给我一些状态字一样。\n\n* **`db.runCommand( )`**\n\n  它是数据库运行命令的执行器，执行命令首选就要使用它，因为它在Shell和驱动程序间提供了一致的接口。（几乎操作数据库的所有操作，都可以使用`runCommand来执行`）现在我们试着用`runCommand`来修改数据库，看看结果和直接用`db.collections.update`有什么不同。\n\n  ```javascript\n  // 修改了所有男士的数据，每个人增加了1000元钱(money)，然后用db.runCommand()执行\n  db.workmate.update({ sex: 1 }, { $set: { money: 1000 } }, false, true)\n  var resultMessage = db.runCommand({ getLastError: 1 })\n  printjson(resultMessage)\n  \n  /*\n  false：第一句末尾的false是upsert的简写，代表没有此条数据时不增加;\n  true：true是multi的简写，代表修改所有，这两个我们在前边课程已经学过。\n  getLastError:1 :表示返回功能错误，这里的参数很多，如果有兴趣请自行查找学习，\n  printjson：表示以json对象的格式输出到控制台。\n  */\n  \n  // 执行返回结果\n  {\n    \"connectionId\" : 9,\n    \"updatedExisting\" : true,\n    \"n\" : 3,\n    \"syncMillis\" : 0,\n    \"writtenTo\" : null,\n    \"err\" : null,\n    \"ok\" : 1\n  }\n  ```\n\n* 查看是否和数据库链接成功\n\n  ```javascript\n  db.runCommand({ ping: 1 })\n  \n  // 返回ok：1就代表链接正常\n  /*\n  connecting to: mongodb://127.0.0.1:27017/company\n  Implicit session: session { \"id\" : UUID(\"f8e213c6-c27b-4282-be47-df5a76eb72ae\") }\n  MongoDB server version: 4.0.10\n  true\n  */\n  ```\n\n* **findAndModify**\n\n  * `findAndModify`是查找并修改的意思。配置它可以在修改后给我们返回修改的结果\n\n  * **`findAndModify`属性值：**\n    * `query`：需要查询的条件/文档\n    * `sort`: 进行排序\n    * `remove：[boolean]`是否删除查找到的文档，值填写true，可以删除。\n    * `new:[boolean]`返回更新前的文档还是更新后的文档。\n    * `fields`：需要返回的字段\n    * `upsert`：没有这个值是否增加。\n\n    ```javascript\n    // findAndModify是查找并修改的意思。配置它可以在修改后给我们返回修改的结果\n    var myModify = {\n      findAndModify: \"workmate\",\n      query: { name: 'JSPang' },\n      update: { $set: { age: 18 } },\n      new: true    // 更新完成，需要查看结果，如果为false不进行查看结果\n    }\n\n    var ResultMessage = db.runCommand(myModify)\n    printjson(ResultMessage)\n\n    // 返回结果  是最新的JSPang 数据\n    ```\n\n  * `findAndModify`的性能是没有直接使用`db.collections.update`的性能好，但是在实际工作中都是使用它，毕竟要商用的程序安全性还是比较重要的。\n  \n## 第10节：查询：find的不等修饰符\n\n* 基础查找\n\n  ```javascript\n  // 简单查找\n  db.workmate.find({ \"skill.skillOne\": \"HTML + CSS\" })\n  \n  // 筛选字段\n  db.workmate.find(\n    { \"skill.skillOne\": \"HTML+CSS\" },\n    {\n      name: true,\n      \"skill.skillOne\": true,\n      _id: false  // 不显示_id\n    }\n  )\n  ```\n\n* **不等修饰符**\n  * `小于($lt)` : 英文全称less-than\n  * `小于等于($lte)` ： 英文全称less-than-equal\n  * `大于($gt)` : 英文全称greater-than\n  * `大于等于($gte)`: 英文全称greater-than-equal\n  * `不等于($ne)`: 英文全称not-equal\n\n  ```javascript\n  // 不等查找  年龄小于30大于25岁的人\n  db.workmate.find(\n    { age: { $lte: 30, $gte: 25 } },\n    { name: true, age: true, \"skill.skillOne\": true, _id: false }\n  )\n  ```\n\n* **日期查找**\n\n  ```javascript\n  var startDate = new Date('01/01/2018')\n  \n  db.workmate.find(\n    { regeditTime: { $gt: startDate } },\n    { name: true, age: true, \"skill.skillOne\": true, _id: false }\n  )\n  ```\n\n* vscode清屏 `cls`\n\n## 第11节：查询：find的多条件查询\n\n* **`$in`修饰符** ：in修饰符可以轻松解决一键多值的查询情况\n\n* **`$in`相对的修饰符是`$nin`修饰符**\n* **`$or`修饰符**：用来查询多个键值的情况\n* **`$nor`修饰符**\n* **`$and`修饰符**：用来查找几个key值都满足的情况  \n* **`$not`修饰符**： 用来查询除条件之外的值\n\n* 查询演示：\n\n  ```javascript\n  var db = connect('company')\n  \n  // $in 修饰符\n  db.workmate.find({\n    age: {\n      $in: [25, 33]\n    }\n  },\n    {\n      name: 1,\n      \"skill.skillOne\": 1,\n      age: 1,\n      _id: 0\n    }\n  )\n  \n  // $or修饰符  查出年龄大于30岁的，或者会做PHP的信息\n  db.workmate.find({\n    $or: [\n      { age: { $gt3: 30 } },\n      { \"skill.skillThree\": 'PHP' }\n  ]},\n    {\n      name: 1,\n      \"skill.skillThree\": 1,\n      age: 1,\n      _id: 0\n    }\n  )\n  \n  \n  // $and用来查找几个key值都满足 查询同事中大于30岁并且会做PHP的信息\n  db.workmate.find({\n    $and: [\n      { age: { $gte: 30 } },\n      { \"skill.skillThree\": 'PHP' }\n  ]},\n    {\n      name: 1,\n      \"skill.skillThree\": 1,\n      age: 1,\n      _id: 0\n    }\n  )\n  \n  // $not修饰符  用来查询除条件之外的值，比如我们现在要查找除年龄大于20岁，小于30岁的人员信息\n  db.workmate.find({\n    age: {\n      $not: {\n        $lte: 30,\n        $gte: 20\n      }\n    }\n  },\n    {\n      name: 1,\n      \"skill.skillOne\": 1,\n      age: 1,\n      _id: 0\n    }\n  )\n  ```\n\n## 第12节：查询：find的数组查询\n\n* **基本数组查询**\n\n* **`$all`数组多项查询** ： 对数组中的对象进行查询，是需要满足所有条件的\n\n* **`$in`数组的或者查询** ： 满足数组中的一项就可以被查出来\n\n* **`$size`数组个数查询** : 根据数组的数量查询出结果\n\n* **`$slice`显示选项**: 并不需要显示出数组中的所有值，而是只显示前两项\n\n* 查询演示：\n\n  ```javascript\n  // 基本数组查询\n  // 查询一个人的爱好是’画画’,’聚会’,’看电影’\n  db.workmate.find(\n    {\n      interest: ['画画', '聚会', '看电影']\n    },\n    {\n      name: 1,\n      interest: 1,\n      age: 1,\n      _id: 0\n    } \n  )\n  \n  // 查出看兴趣中有看电影的员工信息\n  db.workmate.find({\n    interest: '看电影'\n  },\n    {\n      name: 1,\n      interest: 1,\n      age: 1,\n      _id: 0\n    }\n  )\n  \n  \n  // $all-数组多项查询  查询出喜欢看电影和看书的人员信息\n  db.workmate.find({\n    interest: {\n      $all: ['看电影', '看书']\n    }\n  },\n    {\n      name: 1,\n      interest: 1,\n      age: 1,\n      _id: 0\n    } \n  )\n  \n  \n  // $in-数组的或者查询\n  // 用$all修饰符，是需要满足所有条件的，\n  // $in主要满足数组中的一项就可以被查出来（有时候会跟$or弄混）\n  // 查询爱好中有看电影的或者看书的员工信息\n  db.workmate.find({\n    interest: {\n      $in: ['看电影', '看书']\n    }\n  },\n    {\n      name: 1,\n      interest: 1,\n      age: 1,\n      _id: 0\n    }\n  )\n  \n  \n  // $size-数组个数查询\n  // $size修饰符可以根据数组的数量查询出结果。\n  // 查找兴趣的数量是5个人员信息\n  db.workmate.find({\n    interest: {\n      $size: 5\n    }\n  },\n    {\n      name: 1,\n      interest: 1,\n      age: 1,\n      _id: 0\n    }\n  )\n  \n  \n  // $slice-显示选项\n  // 有时候我并不需要显示出数组中的所有值，而是只显示前两项，\n  // 比如我们现在想显示每个人兴趣的前两项，而不是把每个人所有的兴趣都显示出来\n  db.workmate.find({\n    // interest: {\n    //   $size: 5\n    // }\n  },\n    {\n      name: 1,\n      interest: {$slice: 2},\n      age: 1,\n      _id: 0\n    }\n  )\n  // 想显示兴趣的最后一项，可以直接使用slice:-1，来进行查询\n  ```\n\n## 第13节：查询：find的参数使用方法\n\n**在操作`find方法`的`第一个参数（query）`和`第二个参数（fields）`。`find`还有几个常用的参数，这些参数多用在分页和排序上**\n\n* `find`参数：\n  \n  * `query`：这个就是查询条件，MongoDB默认的第一个参数。\n  * `fields`：（返回内容）查询出来后显示的结果样式，可以用true和false控制是否显示。\n  * `limit`：返回的数量，后边跟数字，控制每次查询返回的结果数量。\n  * `skip`: 跳过多少个显示，和limit结合可以实现分页。\n  * `sort`：排序方式，从小到大排序使用1，从大到小排序使用-1\n  \n  ```javascript\n  // 分页展示\n  db.workmate.find(\n      {},\n      {\n          name: true,\n          age: true,\n          _id: false\n      }).limit(0).skip(2).sort({ age: 1 }\n  )\n  ```\n\n* **`$where`修饰符**\n\n  它是一个非常强大的修饰符，但强大的背后也意味着有风险存在。它可以让我们在条件里使用javascript的方法来进行复杂查询。\n\n  ```javascript\n  // 查询年龄大于30岁的人员\n  db.workmate.find(\n      { $where: \"this.age>30\" },\n      { name: true, age: true, _id: false }\n  )\n  // this指向的是workmate（查询集合）本身。\n  // 这样我们就可以在程序中随意调用。\n  // 虽然强大和灵活，但是这种查询对于数据库的压力和安全性都会变重，\n  // 所以在工作中尽量减少$where修饰符的使用。\n  ```\n\n## 第14节：查询：find如何在js文本中使用\n\n* `find`查询如何才终端中`load()`执行\n\n* **hasNext循环结果**\n\n  ```javascript\n  // hasNext循环结果\n  \n  var db = connect(\"company\")  // 进行链接对应的集合collections\n  var result = db.workmate.find() // 声明变量result，并把查询结果赋值给result\n  // 利用游标的hasNext()进行循环输出结果。\n  while (result.hasNext()) {\n    printjson(result.next())  //用json格式打印结果\n  }\n  ```\n\n* **`forEach`循环**\n\n  ```javascript\n  // forEach循环\n  // 利用hasNext循环结果，需要借助while的帮助，\n  // MongoDB也为我们提供了forEach循环，现在修改上边的代码，使用forEach循环来输出结果。\n  \n  var db = connect(\"company\")  // 进行链接对应的集合collections\n  var result = db.workmate.find() // 声明变量result，并把查询结果赋值给result\n  // 利用forEach循环\n  result.forEach(function (result) {\n    printjson(result)\n  })\n  ```\n\n* `forEach`循环更为优雅。这两种方法都是非常不错的,凭借自己爱好进行选择吧\n\n## 第15节：索引:构造百万级数据\n\n* 构造百万级的数据集合\n\n  ```javascript\n  // 构造百万级的数据集合\n  \n  // 生成随机数\n  function GetRandomNum(min, max) {\n    let range = max - min  //得到随机数区间\n    let rand = Math.random() //得到随机值\n    return (min + Math.round(rand * range)) //最小值+随机数取整 \n  }\n  // console.log(GetRandomNum(10000, 99999))\n  \n  // 生成随机用户名\n  function GetRadomUserName(min, max) {\n    let tempStringArray = \"123456789qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM\".split(\"\") //构造生成时的字母库数组\n    let outPuttext = \"\" // 最后输出的变量\n    // 进行循环，随机生产用户名的长度，这里需要生成随机数方法的配合\n    for (let i = 1; i < GetRandomNum(min, max); i++){\n      // 随机抽取字母，拼装成需要的用户名\n      outPuttext = outPuttext + tempStringArray[GetRandomNum(0, tempStringArray.length)]\n    }\n    return outPuttext\n  }\n  // console.log(GetRadomUserName(7, 16))\n  \n  // 插入200万数据\n  var startTime = (new Date()).getTime()\n  \n  var db = connect('company')\n  db.randomInfo.drop()\n  var tempInfo = []\n  for (let i = 0; i < 2000000; i++){\n    tempInfo.push({\n      username: GetRadomUserName(7, 16),\n      regeditTime: new Date(),\n      randNum0: GetRandomNum(100000, 999999),\n      randNum1: GetRandomNum(100000, 999999),\n      randNum2: GetRandomNum(100000, 999999),\n      randNum3: GetRandomNum(100000, 999999),\n      randNum4: GetRandomNum(100000, 999999),\n      randNum5: GetRandomNum(100000, 999999),\n      randNum6: GetRandomNum(100000, 999999),\n      randNum7: GetRandomNum(100000, 999999),\n      randNum8: GetRandomNum(100000, 999999),\n      randNum8: GetRandomNum(100000, 999999)\n    })\n  }\n  \n  db.randomInfo.insert(tempInfo)\n  var endTime = (new Date()).getTime()\n  \n  print(\"[demo]:------\" + (endTime - startTime) + \"ms\")\n  ```\n\n* 使用 `db.randomInfo.stats()`这个命令查看数据中的数据条数\n\n## 第16节：索引：索引入门\n\n* **索引查询** --- 普通查询性能\n\n  ```javascript\n  // 索引查询 --- 普通查询性能\n  var startTime = (new Date()).getTime()\n  \n  var db = connect('company')\n  // 跳过 5000 查询  db.randomInfo.find().skip(50000)\n  var result = db.randomInfo.find({\n    username:\"undefined4pi4n\"\n  })\n  \n  result.forEach(result => {\n    printjson(result)\n  })\n  \n  var endTime = (new Date()).getTime()\n  \n  print(\"[SUCCESS]:THIS RUN TIME IS:\" + (endTime - startTime) + \"ms\")\n  \n  // 查询时间 875ms左右\n  ```\n\n* **建立索引** `createIndex()`\n\n  > *注意在 3.0.0 版本前创建索引方法为 db.collection.ensureIndex()，之后的版本使用了 db.collection.createIndex() 方法，ensureIndex() 还能用，但只是 createIndex() 的别名。*\n\n  * 语法\n\n    ```javascript\n    db.collection.createIndex(keys, options)\n\n    // 语法中 Key 值为你要创建的索引字段，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。\n    ```\n\n  * 用法实例：\n\n  ```javascript\n  // 建立索引  --- 试着为用户名（username）建立索引\n  db.randomInfo.createIndex({ username: 1 })\n  \n  // or\n  db.randomInfo.ensureIndex({ username: 1 })\n  \n  // 复合索引\n  db.col.createIndex({\"title\":1,\"description\":-1})\n  ```\n\n* **查看现有索引**\n\n  ```javascript\n  // 查看现有索引\n  \n  db.randomInfo.getIndexes()\n  ```\n\n* 建立索引后再次执行查询 `load('./index_demo2.js')`，时间下降到 7ms了，随机波动，不超过20ms\n  \n* 无论是在关系型数据库还是文档数据库，建立索引都是非常重要的。索引这东西是要消耗硬盘和内存资源的，所以还是要根据程序需要进行建立了。**MongoDB也给我们进行了限制，只允许我们建立64个索引值**。\n\n## 第17节：索引：复合索引\n\n* **索引中的小坑**\n\n  * 通过实际开发和性能对比，总结了几条不用索引的情况（不一定对，但是自己的经验之谈）。\n\n  * 数据不超万条时，不需要使用索引。性能的提升并不明显，而大大增加了内存和硬盘的消耗。\n  * 查询数据超过表数据量30%时，不要使用索引字段查询。实际证明会比不使用索引更慢，因为它大量检索了索引表和我们原表。（如查询员工的性别）\n  * 数字索引，要比字符串索引快的多，在百万级甚至千万级数据量面前，使用数字索引是个明确的选择。\n  * 把你经常查询的数据做成一个内嵌数据（对象型的数据），然后集体进行索引。\n\n* **复合索引** : 复合索引就是两条以上的索引\n\n  ```javascript\n  // db.randomInfo.ensureIndex({ username: 1 })\n  \n  // 增加建立randNum0 的索引\n  db.randomInfo.ensureIndex({randNum0:1})\n  // 查看现有索引\n  db.randomInfo.getIndexes()\n  ```\n\n* **两个索引同时查询**\n\n  ```javascript\n  var startTime = (new Date()).getTime()\n  var db = connect('company')\n  \n  var result = db.randomInfo.find({\n    username: \"undefined4pi4n\",\n    randNum0: 565509\n  })\n  \n  result.forEach(result => {\n    printjson(result)\n  })\n  \n  var endTime = (new Date()).getTime()\n  print(\"[SUCCESS]:THIS RUN TIME IS:\" + (endTime - startTime) + \"ms\")\n  \n  // 查询时间 8ms\n  // 从性能上看并没有什么特殊的变化，查询时间还是在8ms左右。\n  // MongoDB的复合查询是按照我们的索引顺序进行查询的\n  ```\n\n* 执行查询 `load('./index_demo3.js')`\n\n* **指定索引查询（`hint`）**\n\n  数字的索引要比字符串的索引快，这就需要一个方法来打破索引表的查询顺序，用我们自己指定的索引优先查询，这个方法就是`hint()`\n\n  ```javascript\n  // 打破索引表的查询顺序\n  var result = db.randomInfo.find({\n    username: \"undefined4pi4n\",\n    randNum0: 565509\n  }).hint({ randNum0: 1 })\n  ```\n\n* **删除索引**\n\n  当索引性能不佳或起不到作用时，我们需要删除索引，删除索引的命令是`dropIndex()`. \n\n  ```javascript\n  db.randomInfo.dropIndex('randNum0_1') //索引的唯一ID\n  \n  // 删除时填写的值，并不是我们的字段名称（key），而是我们索引查询表中的name值\n  ```\n\n## 第18节：索引：全文索引\n\n* 准备数据\n\n* **建立全文索引**\n\n  ```javascript\n  // 建立全文索引\n  db.info.ensureIndex({ contextInfo: 'text' })\n  \n  // 需要注意的是这里使用text关键词来代表全文索引，我们在这里就不建立数据模型了\n  ```\n\n* **全文索引查找**\n\n  * 建立好了全文索引就可以查找了，查找时需要两个关键修饰符:\n\n  * `$text`: 表示要在全文索引中查东西。\n\n  * `$search`:后边跟查找的内容。\n\n    ```javascript\n    db.info.find({$text:{$search:\"programmer\"}})\n    ```\n\n* **查找多个词**\n\n  ```javascript\n  // 全文索引是支持多个次查找的，\n  // 查找数据中有programmer，family，diary，drink的数据（这是或的关系），所以两条数据都会出现\n  db.info.find({ $text: { $search: \"programmer family diary drink\" } })\n  \n  // 希望不查找出来有drink这个单词的记录，我们可以使用“-”减号来取消。\n  db.info.find({ $text: { $search: \"programmer family diary -drink\" } })\n  ```\n\n* **转义符：**\n\n  ```javascript\n  // 全文搜索中是支持转义符的，比如我们想搜索的是两个词（love PlayGame和drink），这时候需要使用\\斜杠来转意。\n  \n  db.info.find({ $text: { $search: \"\\\"love PlayGame\\\" drink\" } })\n  ```\n\n##  第19节：管理:用户的创建、删除与修改\n\n* **创建用户：**\n\n  首先要进入我们的`admin`库中，进入方法是直接使用`use admin `就可以。进入后可以使用`show collections`来查看数据库中的集合。默认是只有一个集合的`（system.version）`。\n\n  * 语法： `db.createUser()`\n  * 展示代码：\n\n  ```javascript\n  // 创建用户权限\n  db.createUser({  \n    user: \"marlon\",  \n    pwd: \"123456\",  \n    customData: {\n      name: 'marlon',\n      email: 'marlon@126.com',\n      age: 18,\n    },\n    roles: ['read']  \n  })\n  \n  // or\n  // 单独配置一个数据库的权限，比如我们现在要配置compay数据库的权限为读写\n  db.createUser({  \n    user: \"jspang\",  \n    pwd: \"123456\",  \n    customData: {\n      name: '技术胖',\n      email: 'web0432@126.com',\n      age: 18,\n    },\n    roles: [\n      {\n        role: \"readWrite\",\n        db: \"company\"\n      },\n      'read'\n    ]  \n  })\n  \n  \n  /**\n  内置角色：\n    数据库用户角色：read、readWrite；\n    数据库管理角色：dbAdmin、dbOwner、userAdmin;\n    集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManage；\n    备份恢复角色：backup、restore；\n    所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase\n    超级用户角色：root\n    内部角色：__system\n   */\n  ```\n\n  * 数据库内置角色配置说明：\n    1. 数据库用户角色：read、readWrite；\n    2. 数据库管理角色：dbAdmin、dbOwner、userAdmin;\n    3. 集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManage；\n    4. 备份恢复角色：backup、restore；\n    5. 所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase\n    6. 超级用户角色：root\n    7. 内部角色：__system\n\n* **查找用户信息** `db.system.users.find()`\n\n  ```javascript\n  // 查找用户信息\n  db.system.users.find()\n  ```\n\n* **删除用户** `db.system.users.remove({ user: \"marlon\" })`\n\n  ```javascript\n  // 删除用户\n  db.system.users.remove({ user: \"marlon\" })\n  ```\n\n* **鉴权** `db.auth(name, pwd)`\n\n  ```javascript\n  // 验证用户的用户名密码是否正确，就需要用到MongoDB提供的鉴权操作。也算是一种登录操作\n  \n  db.auth(\"jspang\", \"123456\")\n  // 正确返回1，如果错误返回0。（Error：Authentication failed。）\n  ```\n\n* **启动建权** `mongod --auth`\n\n  重启MongoDB服务器，然后设置必须使用鉴权登录。\n\n  ```javascript\n  // cmd 重新启动\n\n  mongod --auth\n  ```\n\n* **登录** `mongo  -u jspang -p 123456 127.0.0.1:27017/admin`\n\n  如果在配置用户之后，用户想登录，可以使用mongo的形式，不过需要配置用户名密码：\n\n  ```javascript\n  mongo  -u jspang -p 123456 127.0.0.1:27017/admin\n  ```\n\n\n\n## 第20节：管理：备份和还原\n\n* 对数据库的备份和还原: `mongodump`和`mongorestore`两个命令\n\n* **备份`mongodump`**\n\n  * mongodump备份的基本格式\n\n    ```javascript\n    mongodump\n        --host 127.0.0.1\n        --port 27017\n        --out D:/databack/backup   // 备份地址\n        --collection myCollections\n        --db test\n        --username username\n        --password password\n    ```\n\n  * 备份演示：\n\n    ```javascript\n    mongodump --host 127.0.0.1 --port 27017 --out D:/databack/\n    ```\n\n* **数据恢复`mongorestore`**\n\n  * mongorestore恢复基本格式\n\n    ```javascript\n    mongorestore\n        --host 127.0.0.1\n        --port 27017\n        --username username\n        --password password\n        <path to the backup>\n    ```\n\n  * 恢复演示\n\n    ```javascript\n    mongorestore --host 127.0.0.1 --port 27017 D:/databack/\n    ```\n\n* 两个命令很简单，甚至你可以写成脚本和定时任务，让他每天自己执行。但是如果你真的使用了MongoDB数据库，这是一个最基本的操作。\n\n## 第21节：管理：图形界面管理（完结）\n\n* `NoSQL Manager for MongoDB`\n* `Studio 3T`\n* `MongoDB Compass`\n","source":"_posts/MongoDB基础入门.md","raw":"---\ntitle: mongodb基础入门\ndate: '2021-03-18'\ntype: 技术\ntags: Mongodb | Mongodb\nsidebarDepth: 3\nsidebar: auto\nnote: MongoDB是一个基于分布式文件存储的数据库，非关系型数据库。\n---\n\n# MongoDB基础入门\n\n学习指导：[挑战全栈 MongoDB基础视频教程 (共21集)](http://www.jspang.com/posts/2017/12/16/mongodb.html)\n\n参考：[MongoDB 教程 | 菜鸟教程](https://www.runoob.com/mongodb/mongodb-tutorial.html)\n\n## 第01节：认识和安装MongoDB\n\n* **MongoDB是非关系型数据库**，要了解非关系型数据库就必须先了解关系型数据库，关系数据库，是建立在关系模型基础上的数据库。比较有名气的关系型数据库，比如Oracle、DB2、MSSQL、Mysql。\n\n* 非关系数据库和关系型数据库的区别是什么？\n\n  * 实质：非关系型数据库的实质：非关系型数据库产品是传统关系型数据库的功能阉割版，通过减少用不到或很少用的功能，来大幅度提高产品性能。\n  * 价格：目前的非关系型数据库基本都是免费的，而比较有名气的关系型数据库都是收费的，比如：Oracle、DB2、MSSQL。MySql虽然是免费的，但是处理大型数据还是要提前作很多工作的。\n  * 功能：实际开发中，很多业务需求，其实并不需要完整的关系型数据库功能，非关系型数据库的功能就足够使用了。这种情况下，使用性能更高、成本更低的非关系型数据库当然是更明智的选择。\n\n* 了解关系型数据库和非关系型数据库的区别后，需要有一点的取舍，**比较复杂和大型的项目不建议使用非关系型数据库**，但是如果你想作个博客，CMS系统这类业务逻辑不复杂的程序，MongoDB是完全可以胜任的。\n\n* MongoDB简介：\n\n  * MongoDB是一个基于分布式文件存储的数据库，由C++语言编写。目的是为WEB应用提供扩展的高性能的数据存储解决方案。\n  * MongoDB是一个介于关系型数据库和非关系型数据库之间的产品，是非关系型数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。\n  * Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。\n\n* 安装忽略\n\n* **运行MongoDB服务端：**\n\n  * 安装好MongoDB数据库后，我们需要启用服务端才能使用。启用服务的命令是：Mongod。\n  * 打开命令行: 先打开运行（快捷键win+R），然后输入cmd后回车，就可以打开命令行工具。\n  * 执行mongod: 在命令中直接输入mongod，但是你会发现服务并没有启动，报了一个exception，服务停止了。\n  * 新建文件夹:出现上边的错误，是因为我们没有简历Mongodb需要的文件夹，`一般是安装盘的根目录，建立data/db,这两个文件夹`。\n  * 运行mongod：这时候服务就可以开启了，链接默认端口是27017。\n\n* **链接服务：**\n\n  ```bash\n  # cmd 输入 mongo\n  mongo\n  \n  #查看存在数据库命令：\n  show dbs\n  \n  # 查看数据库版本命令：\n  db.version()\n  ```\n\n## 第02节：Mongo基本命令-1\n\n* **MongoDB的存储结构** 以前我们的关系型数据库的数据结构都是顶层是库，库下面是表，表下面是数据。但是MongoDB有所不同，库下面是集合，集合下面是文件。\n\n* **基础Shell命令：**\n  * `show dbs` :显示已有数据库，如果你刚安装好，会默认有`local、admin、config`，这是MongoDB的默认数据库，我们在新建库时是不允许起这些名称的。\n  * `use admin`： 进入数据，也可以理解成为使用数据库。成功会显示：switched to db admin。\n  * `show collections`: 显示数据库中的集合（关系型中叫表，我们要逐渐熟悉）。\n  * `db`:显示当前位置，也就是你当前使用的数据库名称，这个命令算是最常用的，因为你在作任何操作的时候都要先查看一下自己所在的库，以免造成操作错误。\n\n## 第03节：Mongo基本命令-2\n\n* **数据操作基础命令：**\n  * `use db（建立数据库）`：use不仅可以进入一个数据库，如果你敲入的库不存在，它还可以帮你建立一个库。但是在没有集合前，它还是默认为空。\n\n  * `db.集合.insert( )`:新建数据集合和插入文件（数据），当集合没有时，这时候就可以新建一个集合，并向里边插入数据。\n\n    ```bash\n    db.user.insert({“name”:”jspang”})\n    ```\n\n  * `db.集合.find( )`:查询所有数据，这条命令会列出集合下的所有数据，可以看到MongoDB是自动给我们加入了索引值的。\n\n    ```bash\n    db.user.find()\n    ```\n\n  * `db.集合.findOne( )`:查询第一个文件数据，这里需要注意的，所有MongoDB的组合单词都使用首字母小写的驼峰式写法。\n\n  * `db.集合.update({查询},{修改})`:修改文件数据，第一个是查询条件，第二个是要修改成的值。这里注意的是可以多加文件数据项的，比如下面的例子。\n\n    ```bash\n    db.jspang.update({\"name\":\"jspang\"},{\"name\":\"jspang\",\"age\":\"32\"})\n    ```\n\n  * `db.集合.remove(条件)`：删除文件数据，注意的是要跟一个条件。\n\n    ```bash\n    db.user.remove({“name”:”jspang”})\n    ```\n\n  * `db.集合.drop()`:删除整个集合，这个在实际工作中一定要谨慎使用，如果是程序，一定要二次确认。\n\n  * `db.dropDatabase()`: 删除整个数据库，在删除库时，一定要先进入数据库，然后再删除。实际工作中这个基本不用，实际工作可定需要保留数据和痕迹的。\n\n## 第04节：用js文件写mongo命令\n\n* 编写执行代码\n\n  ```javascript\n  // ./mongoShell/goTask.js\n  \n  var userName = 'jspang'  // 声明一个登录名  \n  var timeStamp = Date.parse(new Date()) // 声明登录时的时间戳  \n  var jsonDdatabase = {  // 组成JSON字符串\n    \"loginUnser\": userName,\n    \"loginTime\": timeStamp\n  }\n  var db = connect('log')  //链接数据库\n  db.login.insert(jsonDdatabase) //插入数据\n  \n  print('[demo]log  print success')  //没有错误显示成功\n  ```\n\n* 执行\n\n  ```bash\n  # 链接数据库(cmd)\n  mongo\n  \n  mongo goTask.js\n  \n  show dbs\n  use log\n  show collections\n  db.login.find()\n  ```\n\n## 第05节：批量插入的正确方法\n\n* 在操作数据库时要注意两个能力：\n  * 第一个是快速存储能力。\n  * 第二个是方便迅速查询能力。\n\n* **批量插入**\n\n  * 批量数据插入是以数组的方式进行的（如果写错，可以3个回车可以切出来）\n\n  * 插入数据测试\n\n    ```bash\n    db.test.insert([\n        {\"_id\":1},\n        {\"_id\":2},\n        {\"_id\":3}\n    ])\n\n    # 3.2版本以前的用法\n    db.test.batchInsert([\n        {\"_id\":1},\n        {\"_id\":2},\n        {\"_id\":3}\n    ])\n    ```\n\n  * 注意一次插入不要超过48M，向.zip和大图片什么的尽量用静态存储，MongoDB存储静态路径就好。\n\n* **批量插入性能测试**\n\n  ```bash\n  # 一个个插入  执行insertTest1.js  耗时622ms\n  mongo insertTest1.js\n  \n  # 批量插入  执行insertTest2.js  耗时15ms\n  mongo insertTest2.js\n  ```\n\n* 总结：在工作中一定要照顾数据库性能，这也是你水平的提现，一个技术会了很简单，但是要作精通不那么简单。学完这节，记得在工作中如果在循环插入和批量插入举起不定，那就选批量插入吧，它会给我们更优的性能体验。\n\n* 范式流程：\n\n  ```javascript\n  var db = connect('company')  // 连接数据库\n  var workmateArray = [workmate1, workmate2, workmate3]\n  db.workmate.insert(workmateArray)  // 数据库插入集合\n  print('[SUCCESS]: The data was inserted successfully.');\n  ```\n\n  \n\n## 第06节：修改：Update常见错误\n\n了解常见的错误操作\n\n## 第07节：修改：初识update修改器\n\n* **`$set`修改器**\n\n  用来修改一个指定的键值(key)，这时候我们要修改上节课的sex和age就非常方便了，只要一句话就可以搞定。\n\n  ```javascript\n  db.workmate.update({ \"name\":\"MinJie\" }, { \"$set\": {sex:2,age:21} })\n  ```\n\n  修改好后，我们可以用db.workmate.find()来进行查看\n\n* **修改嵌套内容(内嵌文档)**\n\n  skill数据是内嵌的，这时候我们可以属性的形式进行修改，skill.skillThree\n\n  ```javascript\n  db.workmate.update({ \"name\": \"MinJie\" }, { $set: { \"skill.skillThree\": 'word' } })\n  ```\n\n* **`$unset`用于将key删除**\n\n  作用其实就是删除一个key值和键\n\n  ```javascript\n  db.workmate.update({ \"name\": \"MinJie\" }, { $unset: { \"age\": '' } })\n  \n  // 直接用set进行添加\n  ```\n\n* **`$inc`对数字进行计算**\n\n  ```javascript\n  db.workmate.update({ \"name\": \"MinJie\" }, { $inc: { \"age\": -2 } })\n  ```\n\n* **`multi`选项**\n\n  ```javascript\n  db.workmate.update({}, { $set: { interset: ['basketball'] } }, { multi: true })\n  \n  //每个数据都发生了改变，multi是有ture和false两个值，true代表全部修改，false代表只修改一个（默认值）\n  ```\n\n* **`upsert`选项**\n\n  upsert是在找不到值的情况下，直接插入这条数据\n\n  ```javascript\n  db.workmate.update({ name: 'xiaoWang' }, { $set: { age: 20 } }, { upsert: true })\n  \n  // upsert也有两个值：true代表没有就添加，false代表没有不添加(默认值)\n  ```\n\n## [#](http://www.jspang.com/posts/2017/12/16/mongodb.html#第08节：修改：update数组修改器)第08节：修改：update数组修改器\n\n* **`$push`追加数组/内嵌文档值**\n\n  `$push`的功能是追加数组中的值，但我们也经常用它操作内嵌稳文档，就是{}对象型的值\n\n  ```javascript\n  // $push追加数组/内嵌文档值\n  db.workmate.update({ name: 'xiaoWang' }, { $push: { interest: 'draw' } })\n  \n  // $push修饰符还可以为内嵌文档增加值\n  db.workmate.update({ name: 'MinJie' }, { $push: { \"skill.skillFour\": 'draw' } })\n  ```\n\n  **`$push`修饰符还可以为内嵌文档增加值**\n\n* **`$ne`查找是否存在**\n\n  **检查一个值是否存在，如果不存在再执行操作，存在就不执行**\n\n  ```javascript\n  db.workmate.update({ name: 'xiaoWang', \"interest\": { $ne: 'playGame' } }, { $push: { interest: 'playGame' } })\n  \n  // 总结：没有则修改，有则不修改。\n  ```\n\n* **`$addToSet` 升级版的`$ne`**\n\n  `$ne`的升级版本（查找是否存在，不存在就push上去），操作起来更直观和方便，所以再工作中这个要比`$en`用的多。\n\n  ```javascript\n  // 查看小王(xiaoWang)兴趣(interest)中有没有阅读（readBook）这项，没有则加入读书(readBook)的兴趣.\n  \n  db.workmate.update({ name: \"xiaoWang\" }, { $addToSet: { interest: \"readBook\" } })\n  ```\n\n* **`$each`批量追加**\n\n  可以传入一个数组，一次增加多个值进去，相当于批量操作，性能同样比循环操作要好很多，这个是需要我们注意的，工作中也要先组合成数组，然后用批量的形式进行操作。\n\n  ```javascript\n  // 给xiaoWang,一次加入三个爱好，唱歌（Sing），跳舞（Dance），编码（Code）\n  \n  var newInterset = [\"Sing\", \"Dance\", \"Code\"]\n  db.workmate.update({ name: \"xiaoWang\" }, { $addToSet: { interest: { $each: newInterset } } })\n  ```\n\n* **`$pop` 删除数组值**\n\n  `$pop`只删除一次，并不是删除所有数组中的值。而且它有两个选项，一个是1和-1。\n\n    1：从数组末端进行删除；  -1：从数组开端进行删除\n\n  ```javascript\n  db.workmate.update({ name: 'xiaoWang' }, { $pop: { interest: 1 } })\n  ```\n\n* **`interest.int` 数组定位修改**\n\n  修改数组的第几位，但并不知道是什么，这时候我们可以使用`interest.int` 的形式\n\n  ```javascript\n  // 修改xiaoWang的第三个兴趣为编码（Code），注意这里的计数是从0开始的\n  \n  db.workmate.update({ name: 'xiaoWang' }, { $set: { \"interest.2\": \"Code\" } })\n  ```\n\n## 第09节：修改：状态返回与安全\n\n在修改时我们都会用`findAndModify`，它可以给我们返回来一些必要的参数，让我们对修改多了很多控制力，控制力的加强也就是对安全的强化能力加强。\n\n* **应答式写入**\n\n  在之前的操作都是非应答式写入，就是在操作完数据库后，它并没有给我们任何的回应和返回值，而是我们自己安慰自己写了一句话 `print(‘[update]:The data was updated successfully’)`。这在工作中是不允许的，因为根本不能提现我们修改的结果。应答式写入就会给我们直接返回结果（报表），结果里边的包含项会很多，这样我们就可以很好的进行程序的控制和安全机制的处理。有点像前端调用后端接口，无论作什么，后端都要给我一些状态字一样。\n\n* **`db.runCommand( )`**\n\n  它是数据库运行命令的执行器，执行命令首选就要使用它，因为它在Shell和驱动程序间提供了一致的接口。（几乎操作数据库的所有操作，都可以使用`runCommand来执行`）现在我们试着用`runCommand`来修改数据库，看看结果和直接用`db.collections.update`有什么不同。\n\n  ```javascript\n  // 修改了所有男士的数据，每个人增加了1000元钱(money)，然后用db.runCommand()执行\n  db.workmate.update({ sex: 1 }, { $set: { money: 1000 } }, false, true)\n  var resultMessage = db.runCommand({ getLastError: 1 })\n  printjson(resultMessage)\n  \n  /*\n  false：第一句末尾的false是upsert的简写，代表没有此条数据时不增加;\n  true：true是multi的简写，代表修改所有，这两个我们在前边课程已经学过。\n  getLastError:1 :表示返回功能错误，这里的参数很多，如果有兴趣请自行查找学习，\n  printjson：表示以json对象的格式输出到控制台。\n  */\n  \n  // 执行返回结果\n  {\n    \"connectionId\" : 9,\n    \"updatedExisting\" : true,\n    \"n\" : 3,\n    \"syncMillis\" : 0,\n    \"writtenTo\" : null,\n    \"err\" : null,\n    \"ok\" : 1\n  }\n  ```\n\n* 查看是否和数据库链接成功\n\n  ```javascript\n  db.runCommand({ ping: 1 })\n  \n  // 返回ok：1就代表链接正常\n  /*\n  connecting to: mongodb://127.0.0.1:27017/company\n  Implicit session: session { \"id\" : UUID(\"f8e213c6-c27b-4282-be47-df5a76eb72ae\") }\n  MongoDB server version: 4.0.10\n  true\n  */\n  ```\n\n* **findAndModify**\n\n  * `findAndModify`是查找并修改的意思。配置它可以在修改后给我们返回修改的结果\n\n  * **`findAndModify`属性值：**\n    * `query`：需要查询的条件/文档\n    * `sort`: 进行排序\n    * `remove：[boolean]`是否删除查找到的文档，值填写true，可以删除。\n    * `new:[boolean]`返回更新前的文档还是更新后的文档。\n    * `fields`：需要返回的字段\n    * `upsert`：没有这个值是否增加。\n\n    ```javascript\n    // findAndModify是查找并修改的意思。配置它可以在修改后给我们返回修改的结果\n    var myModify = {\n      findAndModify: \"workmate\",\n      query: { name: 'JSPang' },\n      update: { $set: { age: 18 } },\n      new: true    // 更新完成，需要查看结果，如果为false不进行查看结果\n    }\n\n    var ResultMessage = db.runCommand(myModify)\n    printjson(ResultMessage)\n\n    // 返回结果  是最新的JSPang 数据\n    ```\n\n  * `findAndModify`的性能是没有直接使用`db.collections.update`的性能好，但是在实际工作中都是使用它，毕竟要商用的程序安全性还是比较重要的。\n  \n## 第10节：查询：find的不等修饰符\n\n* 基础查找\n\n  ```javascript\n  // 简单查找\n  db.workmate.find({ \"skill.skillOne\": \"HTML + CSS\" })\n  \n  // 筛选字段\n  db.workmate.find(\n    { \"skill.skillOne\": \"HTML+CSS\" },\n    {\n      name: true,\n      \"skill.skillOne\": true,\n      _id: false  // 不显示_id\n    }\n  )\n  ```\n\n* **不等修饰符**\n  * `小于($lt)` : 英文全称less-than\n  * `小于等于($lte)` ： 英文全称less-than-equal\n  * `大于($gt)` : 英文全称greater-than\n  * `大于等于($gte)`: 英文全称greater-than-equal\n  * `不等于($ne)`: 英文全称not-equal\n\n  ```javascript\n  // 不等查找  年龄小于30大于25岁的人\n  db.workmate.find(\n    { age: { $lte: 30, $gte: 25 } },\n    { name: true, age: true, \"skill.skillOne\": true, _id: false }\n  )\n  ```\n\n* **日期查找**\n\n  ```javascript\n  var startDate = new Date('01/01/2018')\n  \n  db.workmate.find(\n    { regeditTime: { $gt: startDate } },\n    { name: true, age: true, \"skill.skillOne\": true, _id: false }\n  )\n  ```\n\n* vscode清屏 `cls`\n\n## 第11节：查询：find的多条件查询\n\n* **`$in`修饰符** ：in修饰符可以轻松解决一键多值的查询情况\n\n* **`$in`相对的修饰符是`$nin`修饰符**\n* **`$or`修饰符**：用来查询多个键值的情况\n* **`$nor`修饰符**\n* **`$and`修饰符**：用来查找几个key值都满足的情况  \n* **`$not`修饰符**： 用来查询除条件之外的值\n\n* 查询演示：\n\n  ```javascript\n  var db = connect('company')\n  \n  // $in 修饰符\n  db.workmate.find({\n    age: {\n      $in: [25, 33]\n    }\n  },\n    {\n      name: 1,\n      \"skill.skillOne\": 1,\n      age: 1,\n      _id: 0\n    }\n  )\n  \n  // $or修饰符  查出年龄大于30岁的，或者会做PHP的信息\n  db.workmate.find({\n    $or: [\n      { age: { $gt3: 30 } },\n      { \"skill.skillThree\": 'PHP' }\n  ]},\n    {\n      name: 1,\n      \"skill.skillThree\": 1,\n      age: 1,\n      _id: 0\n    }\n  )\n  \n  \n  // $and用来查找几个key值都满足 查询同事中大于30岁并且会做PHP的信息\n  db.workmate.find({\n    $and: [\n      { age: { $gte: 30 } },\n      { \"skill.skillThree\": 'PHP' }\n  ]},\n    {\n      name: 1,\n      \"skill.skillThree\": 1,\n      age: 1,\n      _id: 0\n    }\n  )\n  \n  // $not修饰符  用来查询除条件之外的值，比如我们现在要查找除年龄大于20岁，小于30岁的人员信息\n  db.workmate.find({\n    age: {\n      $not: {\n        $lte: 30,\n        $gte: 20\n      }\n    }\n  },\n    {\n      name: 1,\n      \"skill.skillOne\": 1,\n      age: 1,\n      _id: 0\n    }\n  )\n  ```\n\n## 第12节：查询：find的数组查询\n\n* **基本数组查询**\n\n* **`$all`数组多项查询** ： 对数组中的对象进行查询，是需要满足所有条件的\n\n* **`$in`数组的或者查询** ： 满足数组中的一项就可以被查出来\n\n* **`$size`数组个数查询** : 根据数组的数量查询出结果\n\n* **`$slice`显示选项**: 并不需要显示出数组中的所有值，而是只显示前两项\n\n* 查询演示：\n\n  ```javascript\n  // 基本数组查询\n  // 查询一个人的爱好是’画画’,’聚会’,’看电影’\n  db.workmate.find(\n    {\n      interest: ['画画', '聚会', '看电影']\n    },\n    {\n      name: 1,\n      interest: 1,\n      age: 1,\n      _id: 0\n    } \n  )\n  \n  // 查出看兴趣中有看电影的员工信息\n  db.workmate.find({\n    interest: '看电影'\n  },\n    {\n      name: 1,\n      interest: 1,\n      age: 1,\n      _id: 0\n    }\n  )\n  \n  \n  // $all-数组多项查询  查询出喜欢看电影和看书的人员信息\n  db.workmate.find({\n    interest: {\n      $all: ['看电影', '看书']\n    }\n  },\n    {\n      name: 1,\n      interest: 1,\n      age: 1,\n      _id: 0\n    } \n  )\n  \n  \n  // $in-数组的或者查询\n  // 用$all修饰符，是需要满足所有条件的，\n  // $in主要满足数组中的一项就可以被查出来（有时候会跟$or弄混）\n  // 查询爱好中有看电影的或者看书的员工信息\n  db.workmate.find({\n    interest: {\n      $in: ['看电影', '看书']\n    }\n  },\n    {\n      name: 1,\n      interest: 1,\n      age: 1,\n      _id: 0\n    }\n  )\n  \n  \n  // $size-数组个数查询\n  // $size修饰符可以根据数组的数量查询出结果。\n  // 查找兴趣的数量是5个人员信息\n  db.workmate.find({\n    interest: {\n      $size: 5\n    }\n  },\n    {\n      name: 1,\n      interest: 1,\n      age: 1,\n      _id: 0\n    }\n  )\n  \n  \n  // $slice-显示选项\n  // 有时候我并不需要显示出数组中的所有值，而是只显示前两项，\n  // 比如我们现在想显示每个人兴趣的前两项，而不是把每个人所有的兴趣都显示出来\n  db.workmate.find({\n    // interest: {\n    //   $size: 5\n    // }\n  },\n    {\n      name: 1,\n      interest: {$slice: 2},\n      age: 1,\n      _id: 0\n    }\n  )\n  // 想显示兴趣的最后一项，可以直接使用slice:-1，来进行查询\n  ```\n\n## 第13节：查询：find的参数使用方法\n\n**在操作`find方法`的`第一个参数（query）`和`第二个参数（fields）`。`find`还有几个常用的参数，这些参数多用在分页和排序上**\n\n* `find`参数：\n  \n  * `query`：这个就是查询条件，MongoDB默认的第一个参数。\n  * `fields`：（返回内容）查询出来后显示的结果样式，可以用true和false控制是否显示。\n  * `limit`：返回的数量，后边跟数字，控制每次查询返回的结果数量。\n  * `skip`: 跳过多少个显示，和limit结合可以实现分页。\n  * `sort`：排序方式，从小到大排序使用1，从大到小排序使用-1\n  \n  ```javascript\n  // 分页展示\n  db.workmate.find(\n      {},\n      {\n          name: true,\n          age: true,\n          _id: false\n      }).limit(0).skip(2).sort({ age: 1 }\n  )\n  ```\n\n* **`$where`修饰符**\n\n  它是一个非常强大的修饰符，但强大的背后也意味着有风险存在。它可以让我们在条件里使用javascript的方法来进行复杂查询。\n\n  ```javascript\n  // 查询年龄大于30岁的人员\n  db.workmate.find(\n      { $where: \"this.age>30\" },\n      { name: true, age: true, _id: false }\n  )\n  // this指向的是workmate（查询集合）本身。\n  // 这样我们就可以在程序中随意调用。\n  // 虽然强大和灵活，但是这种查询对于数据库的压力和安全性都会变重，\n  // 所以在工作中尽量减少$where修饰符的使用。\n  ```\n\n## 第14节：查询：find如何在js文本中使用\n\n* `find`查询如何才终端中`load()`执行\n\n* **hasNext循环结果**\n\n  ```javascript\n  // hasNext循环结果\n  \n  var db = connect(\"company\")  // 进行链接对应的集合collections\n  var result = db.workmate.find() // 声明变量result，并把查询结果赋值给result\n  // 利用游标的hasNext()进行循环输出结果。\n  while (result.hasNext()) {\n    printjson(result.next())  //用json格式打印结果\n  }\n  ```\n\n* **`forEach`循环**\n\n  ```javascript\n  // forEach循环\n  // 利用hasNext循环结果，需要借助while的帮助，\n  // MongoDB也为我们提供了forEach循环，现在修改上边的代码，使用forEach循环来输出结果。\n  \n  var db = connect(\"company\")  // 进行链接对应的集合collections\n  var result = db.workmate.find() // 声明变量result，并把查询结果赋值给result\n  // 利用forEach循环\n  result.forEach(function (result) {\n    printjson(result)\n  })\n  ```\n\n* `forEach`循环更为优雅。这两种方法都是非常不错的,凭借自己爱好进行选择吧\n\n## 第15节：索引:构造百万级数据\n\n* 构造百万级的数据集合\n\n  ```javascript\n  // 构造百万级的数据集合\n  \n  // 生成随机数\n  function GetRandomNum(min, max) {\n    let range = max - min  //得到随机数区间\n    let rand = Math.random() //得到随机值\n    return (min + Math.round(rand * range)) //最小值+随机数取整 \n  }\n  // console.log(GetRandomNum(10000, 99999))\n  \n  // 生成随机用户名\n  function GetRadomUserName(min, max) {\n    let tempStringArray = \"123456789qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM\".split(\"\") //构造生成时的字母库数组\n    let outPuttext = \"\" // 最后输出的变量\n    // 进行循环，随机生产用户名的长度，这里需要生成随机数方法的配合\n    for (let i = 1; i < GetRandomNum(min, max); i++){\n      // 随机抽取字母，拼装成需要的用户名\n      outPuttext = outPuttext + tempStringArray[GetRandomNum(0, tempStringArray.length)]\n    }\n    return outPuttext\n  }\n  // console.log(GetRadomUserName(7, 16))\n  \n  // 插入200万数据\n  var startTime = (new Date()).getTime()\n  \n  var db = connect('company')\n  db.randomInfo.drop()\n  var tempInfo = []\n  for (let i = 0; i < 2000000; i++){\n    tempInfo.push({\n      username: GetRadomUserName(7, 16),\n      regeditTime: new Date(),\n      randNum0: GetRandomNum(100000, 999999),\n      randNum1: GetRandomNum(100000, 999999),\n      randNum2: GetRandomNum(100000, 999999),\n      randNum3: GetRandomNum(100000, 999999),\n      randNum4: GetRandomNum(100000, 999999),\n      randNum5: GetRandomNum(100000, 999999),\n      randNum6: GetRandomNum(100000, 999999),\n      randNum7: GetRandomNum(100000, 999999),\n      randNum8: GetRandomNum(100000, 999999),\n      randNum8: GetRandomNum(100000, 999999)\n    })\n  }\n  \n  db.randomInfo.insert(tempInfo)\n  var endTime = (new Date()).getTime()\n  \n  print(\"[demo]:------\" + (endTime - startTime) + \"ms\")\n  ```\n\n* 使用 `db.randomInfo.stats()`这个命令查看数据中的数据条数\n\n## 第16节：索引：索引入门\n\n* **索引查询** --- 普通查询性能\n\n  ```javascript\n  // 索引查询 --- 普通查询性能\n  var startTime = (new Date()).getTime()\n  \n  var db = connect('company')\n  // 跳过 5000 查询  db.randomInfo.find().skip(50000)\n  var result = db.randomInfo.find({\n    username:\"undefined4pi4n\"\n  })\n  \n  result.forEach(result => {\n    printjson(result)\n  })\n  \n  var endTime = (new Date()).getTime()\n  \n  print(\"[SUCCESS]:THIS RUN TIME IS:\" + (endTime - startTime) + \"ms\")\n  \n  // 查询时间 875ms左右\n  ```\n\n* **建立索引** `createIndex()`\n\n  > *注意在 3.0.0 版本前创建索引方法为 db.collection.ensureIndex()，之后的版本使用了 db.collection.createIndex() 方法，ensureIndex() 还能用，但只是 createIndex() 的别名。*\n\n  * 语法\n\n    ```javascript\n    db.collection.createIndex(keys, options)\n\n    // 语法中 Key 值为你要创建的索引字段，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。\n    ```\n\n  * 用法实例：\n\n  ```javascript\n  // 建立索引  --- 试着为用户名（username）建立索引\n  db.randomInfo.createIndex({ username: 1 })\n  \n  // or\n  db.randomInfo.ensureIndex({ username: 1 })\n  \n  // 复合索引\n  db.col.createIndex({\"title\":1,\"description\":-1})\n  ```\n\n* **查看现有索引**\n\n  ```javascript\n  // 查看现有索引\n  \n  db.randomInfo.getIndexes()\n  ```\n\n* 建立索引后再次执行查询 `load('./index_demo2.js')`，时间下降到 7ms了，随机波动，不超过20ms\n  \n* 无论是在关系型数据库还是文档数据库，建立索引都是非常重要的。索引这东西是要消耗硬盘和内存资源的，所以还是要根据程序需要进行建立了。**MongoDB也给我们进行了限制，只允许我们建立64个索引值**。\n\n## 第17节：索引：复合索引\n\n* **索引中的小坑**\n\n  * 通过实际开发和性能对比，总结了几条不用索引的情况（不一定对，但是自己的经验之谈）。\n\n  * 数据不超万条时，不需要使用索引。性能的提升并不明显，而大大增加了内存和硬盘的消耗。\n  * 查询数据超过表数据量30%时，不要使用索引字段查询。实际证明会比不使用索引更慢，因为它大量检索了索引表和我们原表。（如查询员工的性别）\n  * 数字索引，要比字符串索引快的多，在百万级甚至千万级数据量面前，使用数字索引是个明确的选择。\n  * 把你经常查询的数据做成一个内嵌数据（对象型的数据），然后集体进行索引。\n\n* **复合索引** : 复合索引就是两条以上的索引\n\n  ```javascript\n  // db.randomInfo.ensureIndex({ username: 1 })\n  \n  // 增加建立randNum0 的索引\n  db.randomInfo.ensureIndex({randNum0:1})\n  // 查看现有索引\n  db.randomInfo.getIndexes()\n  ```\n\n* **两个索引同时查询**\n\n  ```javascript\n  var startTime = (new Date()).getTime()\n  var db = connect('company')\n  \n  var result = db.randomInfo.find({\n    username: \"undefined4pi4n\",\n    randNum0: 565509\n  })\n  \n  result.forEach(result => {\n    printjson(result)\n  })\n  \n  var endTime = (new Date()).getTime()\n  print(\"[SUCCESS]:THIS RUN TIME IS:\" + (endTime - startTime) + \"ms\")\n  \n  // 查询时间 8ms\n  // 从性能上看并没有什么特殊的变化，查询时间还是在8ms左右。\n  // MongoDB的复合查询是按照我们的索引顺序进行查询的\n  ```\n\n* 执行查询 `load('./index_demo3.js')`\n\n* **指定索引查询（`hint`）**\n\n  数字的索引要比字符串的索引快，这就需要一个方法来打破索引表的查询顺序，用我们自己指定的索引优先查询，这个方法就是`hint()`\n\n  ```javascript\n  // 打破索引表的查询顺序\n  var result = db.randomInfo.find({\n    username: \"undefined4pi4n\",\n    randNum0: 565509\n  }).hint({ randNum0: 1 })\n  ```\n\n* **删除索引**\n\n  当索引性能不佳或起不到作用时，我们需要删除索引，删除索引的命令是`dropIndex()`. \n\n  ```javascript\n  db.randomInfo.dropIndex('randNum0_1') //索引的唯一ID\n  \n  // 删除时填写的值，并不是我们的字段名称（key），而是我们索引查询表中的name值\n  ```\n\n## 第18节：索引：全文索引\n\n* 准备数据\n\n* **建立全文索引**\n\n  ```javascript\n  // 建立全文索引\n  db.info.ensureIndex({ contextInfo: 'text' })\n  \n  // 需要注意的是这里使用text关键词来代表全文索引，我们在这里就不建立数据模型了\n  ```\n\n* **全文索引查找**\n\n  * 建立好了全文索引就可以查找了，查找时需要两个关键修饰符:\n\n  * `$text`: 表示要在全文索引中查东西。\n\n  * `$search`:后边跟查找的内容。\n\n    ```javascript\n    db.info.find({$text:{$search:\"programmer\"}})\n    ```\n\n* **查找多个词**\n\n  ```javascript\n  // 全文索引是支持多个次查找的，\n  // 查找数据中有programmer，family，diary，drink的数据（这是或的关系），所以两条数据都会出现\n  db.info.find({ $text: { $search: \"programmer family diary drink\" } })\n  \n  // 希望不查找出来有drink这个单词的记录，我们可以使用“-”减号来取消。\n  db.info.find({ $text: { $search: \"programmer family diary -drink\" } })\n  ```\n\n* **转义符：**\n\n  ```javascript\n  // 全文搜索中是支持转义符的，比如我们想搜索的是两个词（love PlayGame和drink），这时候需要使用\\斜杠来转意。\n  \n  db.info.find({ $text: { $search: \"\\\"love PlayGame\\\" drink\" } })\n  ```\n\n##  第19节：管理:用户的创建、删除与修改\n\n* **创建用户：**\n\n  首先要进入我们的`admin`库中，进入方法是直接使用`use admin `就可以。进入后可以使用`show collections`来查看数据库中的集合。默认是只有一个集合的`（system.version）`。\n\n  * 语法： `db.createUser()`\n  * 展示代码：\n\n  ```javascript\n  // 创建用户权限\n  db.createUser({  \n    user: \"marlon\",  \n    pwd: \"123456\",  \n    customData: {\n      name: 'marlon',\n      email: 'marlon@126.com',\n      age: 18,\n    },\n    roles: ['read']  \n  })\n  \n  // or\n  // 单独配置一个数据库的权限，比如我们现在要配置compay数据库的权限为读写\n  db.createUser({  \n    user: \"jspang\",  \n    pwd: \"123456\",  \n    customData: {\n      name: '技术胖',\n      email: 'web0432@126.com',\n      age: 18,\n    },\n    roles: [\n      {\n        role: \"readWrite\",\n        db: \"company\"\n      },\n      'read'\n    ]  \n  })\n  \n  \n  /**\n  内置角色：\n    数据库用户角色：read、readWrite；\n    数据库管理角色：dbAdmin、dbOwner、userAdmin;\n    集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManage；\n    备份恢复角色：backup、restore；\n    所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase\n    超级用户角色：root\n    内部角色：__system\n   */\n  ```\n\n  * 数据库内置角色配置说明：\n    1. 数据库用户角色：read、readWrite；\n    2. 数据库管理角色：dbAdmin、dbOwner、userAdmin;\n    3. 集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManage；\n    4. 备份恢复角色：backup、restore；\n    5. 所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase\n    6. 超级用户角色：root\n    7. 内部角色：__system\n\n* **查找用户信息** `db.system.users.find()`\n\n  ```javascript\n  // 查找用户信息\n  db.system.users.find()\n  ```\n\n* **删除用户** `db.system.users.remove({ user: \"marlon\" })`\n\n  ```javascript\n  // 删除用户\n  db.system.users.remove({ user: \"marlon\" })\n  ```\n\n* **鉴权** `db.auth(name, pwd)`\n\n  ```javascript\n  // 验证用户的用户名密码是否正确，就需要用到MongoDB提供的鉴权操作。也算是一种登录操作\n  \n  db.auth(\"jspang\", \"123456\")\n  // 正确返回1，如果错误返回0。（Error：Authentication failed。）\n  ```\n\n* **启动建权** `mongod --auth`\n\n  重启MongoDB服务器，然后设置必须使用鉴权登录。\n\n  ```javascript\n  // cmd 重新启动\n\n  mongod --auth\n  ```\n\n* **登录** `mongo  -u jspang -p 123456 127.0.0.1:27017/admin`\n\n  如果在配置用户之后，用户想登录，可以使用mongo的形式，不过需要配置用户名密码：\n\n  ```javascript\n  mongo  -u jspang -p 123456 127.0.0.1:27017/admin\n  ```\n\n\n\n## 第20节：管理：备份和还原\n\n* 对数据库的备份和还原: `mongodump`和`mongorestore`两个命令\n\n* **备份`mongodump`**\n\n  * mongodump备份的基本格式\n\n    ```javascript\n    mongodump\n        --host 127.0.0.1\n        --port 27017\n        --out D:/databack/backup   // 备份地址\n        --collection myCollections\n        --db test\n        --username username\n        --password password\n    ```\n\n  * 备份演示：\n\n    ```javascript\n    mongodump --host 127.0.0.1 --port 27017 --out D:/databack/\n    ```\n\n* **数据恢复`mongorestore`**\n\n  * mongorestore恢复基本格式\n\n    ```javascript\n    mongorestore\n        --host 127.0.0.1\n        --port 27017\n        --username username\n        --password password\n        <path to the backup>\n    ```\n\n  * 恢复演示\n\n    ```javascript\n    mongorestore --host 127.0.0.1 --port 27017 D:/databack/\n    ```\n\n* 两个命令很简单，甚至你可以写成脚本和定时任务，让他每天自己执行。但是如果你真的使用了MongoDB数据库，这是一个最基本的操作。\n\n## 第21节：管理：图形界面管理（完结）\n\n* `NoSQL Manager for MongoDB`\n* `Studio 3T`\n* `MongoDB Compass`\n","slug":"MongoDB基础入门","published":1,"updated":"2021-07-19T05:53:29.406Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrd8jv150000kwzt3zuu0ly8","content":"<h1 id=\"MongoDB基础入门\"><a href=\"#MongoDB基础入门\" class=\"headerlink\" title=\"MongoDB基础入门\"></a>MongoDB基础入门</h1><p>学习指导：<a href=\"http://www.jspang.com/posts/2017/12/16/mongodb.html\">挑战全栈 MongoDB基础视频教程 (共21集)</a></p>\n<p>参考：<a href=\"https://www.runoob.com/mongodb/mongodb-tutorial.html\">MongoDB 教程 | 菜鸟教程</a></p>\n<h2 id=\"第01节：认识和安装MongoDB\"><a href=\"#第01节：认识和安装MongoDB\" class=\"headerlink\" title=\"第01节：认识和安装MongoDB\"></a>第01节：认识和安装MongoDB</h2><ul>\n<li><p><strong>MongoDB是非关系型数据库</strong>，要了解非关系型数据库就必须先了解关系型数据库，关系数据库，是建立在关系模型基础上的数据库。比较有名气的关系型数据库，比如Oracle、DB2、MSSQL、Mysql。</p>\n</li>\n<li><p>非关系数据库和关系型数据库的区别是什么？</p>\n<ul>\n<li>实质：非关系型数据库的实质：非关系型数据库产品是传统关系型数据库的功能阉割版，通过减少用不到或很少用的功能，来大幅度提高产品性能。</li>\n<li>价格：目前的非关系型数据库基本都是免费的，而比较有名气的关系型数据库都是收费的，比如：Oracle、DB2、MSSQL。MySql虽然是免费的，但是处理大型数据还是要提前作很多工作的。</li>\n<li>功能：实际开发中，很多业务需求，其实并不需要完整的关系型数据库功能，非关系型数据库的功能就足够使用了。这种情况下，使用性能更高、成本更低的非关系型数据库当然是更明智的选择。</li>\n</ul>\n</li>\n<li><p>了解关系型数据库和非关系型数据库的区别后，需要有一点的取舍，<strong>比较复杂和大型的项目不建议使用非关系型数据库</strong>，但是如果你想作个博客，CMS系统这类业务逻辑不复杂的程序，MongoDB是完全可以胜任的。</p>\n</li>\n<li><p>MongoDB简介：</p>\n<ul>\n<li>MongoDB是一个基于分布式文件存储的数据库，由C++语言编写。目的是为WEB应用提供扩展的高性能的数据存储解决方案。</li>\n<li>MongoDB是一个介于关系型数据库和非关系型数据库之间的产品，是非关系型数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。</li>\n<li>Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</li>\n</ul>\n</li>\n<li><p>安装忽略</p>\n</li>\n<li><p><strong>运行MongoDB服务端：</strong></p>\n<ul>\n<li>安装好MongoDB数据库后，我们需要启用服务端才能使用。启用服务的命令是：Mongod。</li>\n<li>打开命令行: 先打开运行（快捷键win+R），然后输入cmd后回车，就可以打开命令行工具。</li>\n<li>执行mongod: 在命令中直接输入mongod，但是你会发现服务并没有启动，报了一个exception，服务停止了。</li>\n<li>新建文件夹:出现上边的错误，是因为我们没有简历Mongodb需要的文件夹，<code>一般是安装盘的根目录，建立data/db,这两个文件夹</code>。</li>\n<li>运行mongod：这时候服务就可以开启了，链接默认端口是27017。</li>\n</ul>\n</li>\n<li><p><strong>链接服务：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># cmd 输入 mongo</span></span><br><span class=\"line\">mongo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#查看存在数据库命令：</span></span><br><span class=\"line\">show dbs</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看数据库版本命令：</span></span><br><span class=\"line\">db.version()</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第02节：Mongo基本命令-1\"><a href=\"#第02节：Mongo基本命令-1\" class=\"headerlink\" title=\"第02节：Mongo基本命令-1\"></a>第02节：Mongo基本命令-1</h2><ul>\n<li><p><strong>MongoDB的存储结构</strong> 以前我们的关系型数据库的数据结构都是顶层是库，库下面是表，表下面是数据。但是MongoDB有所不同，库下面是集合，集合下面是文件。</p>\n</li>\n<li><p><strong>基础Shell命令：</strong></p>\n<ul>\n<li><code>show dbs</code> :显示已有数据库，如果你刚安装好，会默认有<code>local、admin、config</code>，这是MongoDB的默认数据库，我们在新建库时是不允许起这些名称的。</li>\n<li><code>use admin</code>： 进入数据，也可以理解成为使用数据库。成功会显示：switched to db admin。</li>\n<li><code>show collections</code>: 显示数据库中的集合（关系型中叫表，我们要逐渐熟悉）。</li>\n<li><code>db</code>:显示当前位置，也就是你当前使用的数据库名称，这个命令算是最常用的，因为你在作任何操作的时候都要先查看一下自己所在的库，以免造成操作错误。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第03节：Mongo基本命令-2\"><a href=\"#第03节：Mongo基本命令-2\" class=\"headerlink\" title=\"第03节：Mongo基本命令-2\"></a>第03节：Mongo基本命令-2</h2><ul>\n<li><p><strong>数据操作基础命令：</strong></p>\n<ul>\n<li><p><code>use db（建立数据库）</code>：use不仅可以进入一个数据库，如果你敲入的库不存在，它还可以帮你建立一个库。但是在没有集合前，它还是默认为空。</p>\n</li>\n<li><p><code>db.集合.insert( )</code>:新建数据集合和插入文件（数据），当集合没有时，这时候就可以新建一个集合，并向里边插入数据。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.insert(&#123;“name”:”jspang”&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><code>db.集合.find( )</code>:查询所有数据，这条命令会列出集合下的所有数据，可以看到MongoDB是自动给我们加入了索引值的。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.find()</span><br></pre></td></tr></table></figure></li>\n<li><p><code>db.集合.findOne( )</code>:查询第一个文件数据，这里需要注意的，所有MongoDB的组合单词都使用首字母小写的驼峰式写法。</p>\n</li>\n<li><p><code>db.集合.update(&#123;查询&#125;,&#123;修改&#125;)</code>:修改文件数据，第一个是查询条件，第二个是要修改成的值。这里注意的是可以多加文件数据项的，比如下面的例子。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.jspang.update(&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;jspang&quot;</span>&#125;,&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;jspang&quot;</span>,<span class=\"string\">&quot;age&quot;</span>:<span class=\"string\">&quot;32&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><code>db.集合.remove(条件)</code>：删除文件数据，注意的是要跟一个条件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.remove(&#123;“name”:”jspang”&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><code>db.集合.drop()</code>:删除整个集合，这个在实际工作中一定要谨慎使用，如果是程序，一定要二次确认。</p>\n</li>\n<li><p><code>db.dropDatabase()</code>: 删除整个数据库，在删除库时，一定要先进入数据库，然后再删除。实际工作中这个基本不用，实际工作可定需要保留数据和痕迹的。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第04节：用js文件写mongo命令\"><a href=\"#第04节：用js文件写mongo命令\" class=\"headerlink\" title=\"第04节：用js文件写mongo命令\"></a>第04节：用js文件写mongo命令</h2><ul>\n<li><p>编写执行代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./mongoShell/goTask.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> userName = <span class=\"string\">&#x27;jspang&#x27;</span>  <span class=\"comment\">// 声明一个登录名  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> timeStamp = <span class=\"built_in\">Date</span>.parse(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()) <span class=\"comment\">// 声明登录时的时间戳  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> jsonDdatabase = &#123;  <span class=\"comment\">// 组成JSON字符串</span></span><br><span class=\"line\">  <span class=\"string\">&quot;loginUnser&quot;</span>: userName,</span><br><span class=\"line\">  <span class=\"string\">&quot;loginTime&quot;</span>: timeStamp</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> db = connect(<span class=\"string\">&#x27;log&#x27;</span>)  <span class=\"comment\">//链接数据库</span></span><br><span class=\"line\">db.login.insert(jsonDdatabase) <span class=\"comment\">//插入数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">&#x27;[demo]log  print success&#x27;</span>)  <span class=\"comment\">//没有错误显示成功</span></span><br></pre></td></tr></table></figure></li>\n<li><p>执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 链接数据库(cmd)</span></span><br><span class=\"line\">mongo</span><br><span class=\"line\"></span><br><span class=\"line\">mongo goTask.js</span><br><span class=\"line\"></span><br><span class=\"line\">show dbs</span><br><span class=\"line\">use <span class=\"built_in\">log</span></span><br><span class=\"line\">show collections</span><br><span class=\"line\">db.login.find()</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第05节：批量插入的正确方法\"><a href=\"#第05节：批量插入的正确方法\" class=\"headerlink\" title=\"第05节：批量插入的正确方法\"></a>第05节：批量插入的正确方法</h2><ul>\n<li><p>在操作数据库时要注意两个能力：</p>\n<ul>\n<li>第一个是快速存储能力。</li>\n<li>第二个是方便迅速查询能力。</li>\n</ul>\n</li>\n<li><p><strong>批量插入</strong></p>\n<ul>\n<li><p>批量数据插入是以数组的方式进行的（如果写错，可以3个回车可以切出来）</p>\n</li>\n<li><p>插入数据测试</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.test.insert([</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;_id&quot;</span>:1&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;_id&quot;</span>:2&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;_id&quot;</span>:3&#125;</span><br><span class=\"line\">])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.2版本以前的用法</span></span><br><span class=\"line\">db.test.batchInsert([</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;_id&quot;</span>:1&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;_id&quot;</span>:2&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;_id&quot;</span>:3&#125;</span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure></li>\n<li><p>注意一次插入不要超过48M，向.zip和大图片什么的尽量用静态存储，MongoDB存储静态路径就好。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>批量插入性能测试</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 一个个插入  执行insertTest1.js  耗时622ms</span></span><br><span class=\"line\">mongo insertTest1.js</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 批量插入  执行insertTest2.js  耗时15ms</span></span><br><span class=\"line\">mongo insertTest2.js</span><br></pre></td></tr></table></figure></li>\n<li><p>总结：在工作中一定要照顾数据库性能，这也是你水平的提现，一个技术会了很简单，但是要作精通不那么简单。学完这节，记得在工作中如果在循环插入和批量插入举起不定，那就选批量插入吧，它会给我们更优的性能体验。</p>\n</li>\n<li><p>范式流程：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> db = connect(<span class=\"string\">&#x27;company&#x27;</span>)  <span class=\"comment\">// 连接数据库</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> workmateArray = [workmate1, workmate2, workmate3]</span><br><span class=\"line\">db.workmate.insert(workmateArray)  <span class=\"comment\">// 数据库插入集合</span></span><br><span class=\"line\">print(<span class=\"string\">&#x27;[SUCCESS]: The data was inserted successfully.&#x27;</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第06节：修改：Update常见错误\"><a href=\"#第06节：修改：Update常见错误\" class=\"headerlink\" title=\"第06节：修改：Update常见错误\"></a>第06节：修改：Update常见错误</h2><p>了解常见的错误操作</p>\n<h2 id=\"第07节：修改：初识update修改器\"><a href=\"#第07节：修改：初识update修改器\" class=\"headerlink\" title=\"第07节：修改：初识update修改器\"></a>第07节：修改：初识update修改器</h2><ul>\n<li><p><strong><code>$set</code>修改器</strong></p>\n<p>用来修改一个指定的键值(key)，这时候我们要修改上节课的sex和age就非常方便了，只要一句话就可以搞定。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123; <span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;MinJie&quot;</span> &#125;, &#123; <span class=\"string\">&quot;$set&quot;</span>: &#123;<span class=\"attr\">sex</span>:<span class=\"number\">2</span>,<span class=\"attr\">age</span>:<span class=\"number\">21</span>&#125; &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>修改好后，我们可以用db.workmate.find()来进行查看</p>\n</li>\n<li><p><strong>修改嵌套内容(内嵌文档)</strong></p>\n<p>skill数据是内嵌的，这时候我们可以属性的形式进行修改，skill.skillThree</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123; <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;MinJie&quot;</span> &#125;, &#123; <span class=\"attr\">$set</span>: &#123; <span class=\"string\">&quot;skill.skillThree&quot;</span>: <span class=\"string\">&#x27;word&#x27;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong><code>$unset</code>用于将key删除</strong></p>\n<p>作用其实就是删除一个key值和键</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123; <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;MinJie&quot;</span> &#125;, &#123; <span class=\"attr\">$unset</span>: &#123; <span class=\"string\">&quot;age&quot;</span>: <span class=\"string\">&#x27;&#x27;</span> &#125; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接用set进行添加</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong><code>$inc</code>对数字进行计算</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123; <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;MinJie&quot;</span> &#125;, &#123; <span class=\"attr\">$inc</span>: &#123; <span class=\"string\">&quot;age&quot;</span>: -<span class=\"number\">2</span> &#125; &#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong><code>multi</code>选项</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;&#125;, &#123; <span class=\"attr\">$set</span>: &#123; <span class=\"attr\">interset</span>: [<span class=\"string\">&#x27;basketball&#x27;</span>] &#125; &#125;, &#123; <span class=\"attr\">multi</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//每个数据都发生了改变，multi是有ture和false两个值，true代表全部修改，false代表只修改一个（默认值）</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong><code>upsert</code>选项</strong></p>\n<p>upsert是在找不到值的情况下，直接插入这条数据</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;xiaoWang&#x27;</span> &#125;, &#123; <span class=\"attr\">$set</span>: &#123; <span class=\"attr\">age</span>: <span class=\"number\">20</span> &#125; &#125;, &#123; <span class=\"attr\">upsert</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// upsert也有两个值：true代表没有就添加，false代表没有不添加(默认值)</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第08节：修改：update数组修改器\"><a href=\"#第08节：修改：update数组修改器\" class=\"headerlink\" title=\"#第08节：修改：update数组修改器\"></a><a href=\"http://www.jspang.com/posts/2017/12/16/mongodb.html#%E7%AC%AC08%E8%8A%82%EF%BC%9A%E4%BF%AE%E6%94%B9%EF%BC%9Aupdate%E6%95%B0%E7%BB%84%E4%BF%AE%E6%94%B9%E5%99%A8\">#</a>第08节：修改：update数组修改器</h2><ul>\n<li><p><strong><code>$push</code>追加数组/内嵌文档值</strong></p>\n<p><code>$push</code>的功能是追加数组中的值，但我们也经常用它操作内嵌稳文档，就是{}对象型的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// $push追加数组/内嵌文档值</span></span><br><span class=\"line\">db.workmate.update(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;xiaoWang&#x27;</span> &#125;, &#123; <span class=\"attr\">$push</span>: &#123; <span class=\"attr\">interest</span>: <span class=\"string\">&#x27;draw&#x27;</span> &#125; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $push修饰符还可以为内嵌文档增加值</span></span><br><span class=\"line\">db.workmate.update(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;MinJie&#x27;</span> &#125;, &#123; <span class=\"attr\">$push</span>: &#123; <span class=\"string\">&quot;skill.skillFour&quot;</span>: <span class=\"string\">&#x27;draw&#x27;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong><code>$push</code>修饰符还可以为内嵌文档增加值</strong></p>\n</li>\n<li><p><strong><code>$ne</code>查找是否存在</strong></p>\n<p><strong>检查一个值是否存在，如果不存在再执行操作，存在就不执行</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;xiaoWang&#x27;</span>, <span class=\"string\">&quot;interest&quot;</span>: &#123; <span class=\"attr\">$ne</span>: <span class=\"string\">&#x27;playGame&#x27;</span> &#125; &#125;, &#123; <span class=\"attr\">$push</span>: &#123; <span class=\"attr\">interest</span>: <span class=\"string\">&#x27;playGame&#x27;</span> &#125; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 总结：没有则修改，有则不修改。</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong><code>$addToSet</code> 升级版的<code>$ne</code></strong></p>\n<p><code>$ne</code>的升级版本（查找是否存在，不存在就push上去），操作起来更直观和方便，所以再工作中这个要比<code>$en</code>用的多。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查看小王(xiaoWang)兴趣(interest)中有没有阅读（readBook）这项，没有则加入读书(readBook)的兴趣.</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.workmate.update(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;xiaoWang&quot;</span> &#125;, &#123; <span class=\"attr\">$addToSet</span>: &#123; <span class=\"attr\">interest</span>: <span class=\"string\">&quot;readBook&quot;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong><code>$each</code>批量追加</strong></p>\n<p>可以传入一个数组，一次增加多个值进去，相当于批量操作，性能同样比循环操作要好很多，这个是需要我们注意的，工作中也要先组合成数组，然后用批量的形式进行操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 给xiaoWang,一次加入三个爱好，唱歌（Sing），跳舞（Dance），编码（Code）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> newInterset = [<span class=\"string\">&quot;Sing&quot;</span>, <span class=\"string\">&quot;Dance&quot;</span>, <span class=\"string\">&quot;Code&quot;</span>]</span><br><span class=\"line\">db.workmate.update(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;xiaoWang&quot;</span> &#125;, &#123; <span class=\"attr\">$addToSet</span>: &#123; <span class=\"attr\">interest</span>: &#123; <span class=\"attr\">$each</span>: newInterset &#125; &#125; &#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong><code>$pop</code> 删除数组值</strong></p>\n<p><code>$pop</code>只删除一次，并不是删除所有数组中的值。而且它有两个选项，一个是1和-1。</p>\n<p>  1：从数组末端进行删除；  -1：从数组开端进行删除</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;xiaoWang&#x27;</span> &#125;, &#123; <span class=\"attr\">$pop</span>: &#123; <span class=\"attr\">interest</span>: <span class=\"number\">1</span> &#125; &#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong><code>interest.int</code> 数组定位修改</strong></p>\n<p>修改数组的第几位，但并不知道是什么，这时候我们可以使用<code>interest.int</code> 的形式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 修改xiaoWang的第三个兴趣为编码（Code），注意这里的计数是从0开始的</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.workmate.update(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;xiaoWang&#x27;</span> &#125;, &#123; <span class=\"attr\">$set</span>: &#123; <span class=\"string\">&quot;interest.2&quot;</span>: <span class=\"string\">&quot;Code&quot;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第09节：修改：状态返回与安全\"><a href=\"#第09节：修改：状态返回与安全\" class=\"headerlink\" title=\"第09节：修改：状态返回与安全\"></a>第09节：修改：状态返回与安全</h2><p>在修改时我们都会用<code>findAndModify</code>，它可以给我们返回来一些必要的参数，让我们对修改多了很多控制力，控制力的加强也就是对安全的强化能力加强。</p>\n<ul>\n<li><p><strong>应答式写入</strong></p>\n<p>在之前的操作都是非应答式写入，就是在操作完数据库后，它并没有给我们任何的回应和返回值，而是我们自己安慰自己写了一句话 <code>print(‘[update]:The data was updated successfully’)</code>。这在工作中是不允许的，因为根本不能提现我们修改的结果。应答式写入就会给我们直接返回结果（报表），结果里边的包含项会很多，这样我们就可以很好的进行程序的控制和安全机制的处理。有点像前端调用后端接口，无论作什么，后端都要给我一些状态字一样。</p>\n</li>\n<li><p><strong><code>db.runCommand( )</code></strong></p>\n<p>它是数据库运行命令的执行器，执行命令首选就要使用它，因为它在Shell和驱动程序间提供了一致的接口。（几乎操作数据库的所有操作，都可以使用<code>runCommand来执行</code>）现在我们试着用<code>runCommand</code>来修改数据库，看看结果和直接用<code>db.collections.update</code>有什么不同。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 修改了所有男士的数据，每个人增加了1000元钱(money)，然后用db.runCommand()执行</span></span><br><span class=\"line\">db.workmate.update(&#123; <span class=\"attr\">sex</span>: <span class=\"number\">1</span> &#125;, &#123; <span class=\"attr\">$set</span>: &#123; <span class=\"attr\">money</span>: <span class=\"number\">1000</span> &#125; &#125;, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> resultMessage = db.runCommand(&#123; <span class=\"attr\">getLastError</span>: <span class=\"number\">1</span> &#125;)</span><br><span class=\"line\">printjson(resultMessage)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">false：第一句末尾的false是upsert的简写，代表没有此条数据时不增加;</span></span><br><span class=\"line\"><span class=\"comment\">true：true是multi的简写，代表修改所有，这两个我们在前边课程已经学过。</span></span><br><span class=\"line\"><span class=\"comment\">getLastError:1 :表示返回功能错误，这里的参数很多，如果有兴趣请自行查找学习，</span></span><br><span class=\"line\"><span class=\"comment\">printjson：表示以json对象的格式输出到控制台。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行返回结果</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;connectionId&quot;</span> : <span class=\"number\">9</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;updatedExisting&quot;</span> : <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;n&quot;</span> : <span class=\"number\">3</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;syncMillis&quot;</span> : <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;writtenTo&quot;</span> : <span class=\"literal\">null</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;err&quot;</span> : <span class=\"literal\">null</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;ok&quot;</span> : <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>查看是否和数据库链接成功</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.runCommand(&#123; <span class=\"attr\">ping</span>: <span class=\"number\">1</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回ok：1就代表链接正常</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">connecting to: mongodb://127.0.0.1:27017/company</span></span><br><span class=\"line\"><span class=\"comment\">Implicit session: session &#123; &quot;id&quot; : UUID(&quot;f8e213c6-c27b-4282-be47-df5a76eb72ae&quot;) &#125;</span></span><br><span class=\"line\"><span class=\"comment\">MongoDB server version: 4.0.10</span></span><br><span class=\"line\"><span class=\"comment\">true</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>findAndModify</strong></p>\n<ul>\n<li><p><code>findAndModify</code>是查找并修改的意思。配置它可以在修改后给我们返回修改的结果</p>\n</li>\n<li><p><strong><code>findAndModify</code>属性值：</strong></p>\n<ul>\n<li><code>query</code>：需要查询的条件/文档</li>\n<li><code>sort</code>: 进行排序</li>\n<li><code>remove：[boolean]</code>是否删除查找到的文档，值填写true，可以删除。</li>\n<li><code>new:[boolean]</code>返回更新前的文档还是更新后的文档。</li>\n<li><code>fields</code>：需要返回的字段</li>\n<li><code>upsert</code>：没有这个值是否增加。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// findAndModify是查找并修改的意思。配置它可以在修改后给我们返回修改的结果</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myModify = &#123;</span><br><span class=\"line\">  <span class=\"attr\">findAndModify</span>: <span class=\"string\">&quot;workmate&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">query</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;JSPang&#x27;</span> &#125;,</span><br><span class=\"line\">  <span class=\"attr\">update</span>: &#123; <span class=\"attr\">$set</span>: &#123; <span class=\"attr\">age</span>: <span class=\"number\">18</span> &#125; &#125;,</span><br><span class=\"line\">  <span class=\"attr\">new</span>: <span class=\"literal\">true</span>    <span class=\"comment\">// 更新完成，需要查看结果，如果为false不进行查看结果</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ResultMessage = db.runCommand(myModify)</span><br><span class=\"line\">printjson(ResultMessage)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回结果  是最新的JSPang 数据</span></span><br></pre></td></tr></table></figure></li>\n<li><p><code>findAndModify</code>的性能是没有直接使用<code>db.collections.update</code>的性能好，但是在实际工作中都是使用它，毕竟要商用的程序安全性还是比较重要的。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第10节：查询：find的不等修饰符\"><a href=\"#第10节：查询：find的不等修饰符\" class=\"headerlink\" title=\"第10节：查询：find的不等修饰符\"></a>第10节：查询：find的不等修饰符</h2><ul>\n<li><p>基础查找</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简单查找</span></span><br><span class=\"line\">db.workmate.find(&#123; <span class=\"string\">&quot;skill.skillOne&quot;</span>: <span class=\"string\">&quot;HTML + CSS&quot;</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 筛选字段</span></span><br><span class=\"line\">db.workmate.find(</span><br><span class=\"line\">  &#123; <span class=\"string\">&quot;skill.skillOne&quot;</span>: <span class=\"string\">&quot;HTML+CSS&quot;</span> &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;skill.skillOne&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: <span class=\"literal\">false</span>  <span class=\"comment\">// 不显示_id</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>不等修饰符</strong></p>\n<ul>\n<li><code>小于($lt)</code> : 英文全称less-than</li>\n<li><code>小于等于($lte)</code> ： 英文全称less-than-equal</li>\n<li><code>大于($gt)</code> : 英文全称greater-than</li>\n<li><code>大于等于($gte)</code>: 英文全称greater-than-equal</li>\n<li><code>不等于($ne)</code>: 英文全称not-equal</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不等查找  年龄小于30大于25岁的人</span></span><br><span class=\"line\">db.workmate.find(</span><br><span class=\"line\">  &#123; <span class=\"attr\">age</span>: &#123; <span class=\"attr\">$lte</span>: <span class=\"number\">30</span>, <span class=\"attr\">$gte</span>: <span class=\"number\">25</span> &#125; &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"literal\">true</span>, <span class=\"attr\">age</span>: <span class=\"literal\">true</span>, <span class=\"string\">&quot;skill.skillOne&quot;</span>: <span class=\"literal\">true</span>, <span class=\"attr\">_id</span>: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>日期查找</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> startDate = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"string\">&#x27;01/01/2018&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">db.workmate.find(</span><br><span class=\"line\">  &#123; <span class=\"attr\">regeditTime</span>: &#123; <span class=\"attr\">$gt</span>: startDate &#125; &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"literal\">true</span>, <span class=\"attr\">age</span>: <span class=\"literal\">true</span>, <span class=\"string\">&quot;skill.skillOne&quot;</span>: <span class=\"literal\">true</span>, <span class=\"attr\">_id</span>: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></li>\n<li><p>vscode清屏 <code>cls</code></p>\n</li>\n</ul>\n<h2 id=\"第11节：查询：find的多条件查询\"><a href=\"#第11节：查询：find的多条件查询\" class=\"headerlink\" title=\"第11节：查询：find的多条件查询\"></a>第11节：查询：find的多条件查询</h2><ul>\n<li><p><strong><code>$in</code>修饰符</strong> ：in修饰符可以轻松解决一键多值的查询情况</p>\n</li>\n<li><p><strong><code>$in</code>相对的修饰符是<code>$nin</code>修饰符</strong></p>\n</li>\n<li><p><strong><code>$or</code>修饰符</strong>：用来查询多个键值的情况</p>\n</li>\n<li><p><strong><code>$nor</code>修饰符</strong></p>\n</li>\n<li><p><strong><code>$and</code>修饰符</strong>：用来查找几个key值都满足的情况  </p>\n</li>\n<li><p><strong><code>$not</code>修饰符</strong>： 用来查询除条件之外的值</p>\n</li>\n<li><p>查询演示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> db = connect(<span class=\"string\">&#x27;company&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $in 修饰符</span></span><br><span class=\"line\">db.workmate.find(&#123;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">$in</span>: [<span class=\"number\">25</span>, <span class=\"number\">33</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;skill.skillOne&quot;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $or修饰符  查出年龄大于30岁的，或者会做PHP的信息</span></span><br><span class=\"line\">db.workmate.find(&#123;</span><br><span class=\"line\">  <span class=\"attr\">$or</span>: [</span><br><span class=\"line\">    &#123; <span class=\"attr\">age</span>: &#123; <span class=\"attr\">$gt3</span>: <span class=\"number\">30</span> &#125; &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;skill.skillThree&quot;</span>: <span class=\"string\">&#x27;PHP&#x27;</span> &#125;</span><br><span class=\"line\">]&#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;skill.skillThree&quot;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $and用来查找几个key值都满足 查询同事中大于30岁并且会做PHP的信息</span></span><br><span class=\"line\">db.workmate.find(&#123;</span><br><span class=\"line\">  <span class=\"attr\">$and</span>: [</span><br><span class=\"line\">    &#123; <span class=\"attr\">age</span>: &#123; <span class=\"attr\">$gte</span>: <span class=\"number\">30</span> &#125; &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;skill.skillThree&quot;</span>: <span class=\"string\">&#x27;PHP&#x27;</span> &#125;</span><br><span class=\"line\">]&#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;skill.skillThree&quot;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $not修饰符  用来查询除条件之外的值，比如我们现在要查找除年龄大于20岁，小于30岁的人员信息</span></span><br><span class=\"line\">db.workmate.find(&#123;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">$not</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">$lte</span>: <span class=\"number\">30</span>,</span><br><span class=\"line\">      <span class=\"attr\">$gte</span>: <span class=\"number\">20</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;skill.skillOne&quot;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第12节：查询：find的数组查询\"><a href=\"#第12节：查询：find的数组查询\" class=\"headerlink\" title=\"第12节：查询：find的数组查询\"></a>第12节：查询：find的数组查询</h2><ul>\n<li><p><strong>基本数组查询</strong></p>\n</li>\n<li><p><strong><code>$all</code>数组多项查询</strong> ： 对数组中的对象进行查询，是需要满足所有条件的</p>\n</li>\n<li><p><strong><code>$in</code>数组的或者查询</strong> ： 满足数组中的一项就可以被查出来</p>\n</li>\n<li><p><strong><code>$size</code>数组个数查询</strong> : 根据数组的数量查询出结果</p>\n</li>\n<li><p><strong><code>$slice</code>显示选项</strong>: 并不需要显示出数组中的所有值，而是只显示前两项</p>\n</li>\n<li><p>查询演示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本数组查询</span></span><br><span class=\"line\"><span class=\"comment\">// 查询一个人的爱好是’画画’,’聚会’,’看电影’</span></span><br><span class=\"line\">db.workmate.find(</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">interest</span>: [<span class=\"string\">&#x27;画画&#x27;</span>, <span class=\"string\">&#x27;聚会&#x27;</span>, <span class=\"string\">&#x27;看电影&#x27;</span>]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">interest</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查出看兴趣中有看电影的员工信息</span></span><br><span class=\"line\">db.workmate.find(&#123;</span><br><span class=\"line\">  <span class=\"attr\">interest</span>: <span class=\"string\">&#x27;看电影&#x27;</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">interest</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $all-数组多项查询  查询出喜欢看电影和看书的人员信息</span></span><br><span class=\"line\">db.workmate.find(&#123;</span><br><span class=\"line\">  <span class=\"attr\">interest</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">$all</span>: [<span class=\"string\">&#x27;看电影&#x27;</span>, <span class=\"string\">&#x27;看书&#x27;</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">interest</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $in-数组的或者查询</span></span><br><span class=\"line\"><span class=\"comment\">// 用$all修饰符，是需要满足所有条件的，</span></span><br><span class=\"line\"><span class=\"comment\">// $in主要满足数组中的一项就可以被查出来（有时候会跟$or弄混）</span></span><br><span class=\"line\"><span class=\"comment\">// 查询爱好中有看电影的或者看书的员工信息</span></span><br><span class=\"line\">db.workmate.find(&#123;</span><br><span class=\"line\">  <span class=\"attr\">interest</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">$in</span>: [<span class=\"string\">&#x27;看电影&#x27;</span>, <span class=\"string\">&#x27;看书&#x27;</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">interest</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $size-数组个数查询</span></span><br><span class=\"line\"><span class=\"comment\">// $size修饰符可以根据数组的数量查询出结果。</span></span><br><span class=\"line\"><span class=\"comment\">// 查找兴趣的数量是5个人员信息</span></span><br><span class=\"line\">db.workmate.find(&#123;</span><br><span class=\"line\">  <span class=\"attr\">interest</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">$size</span>: <span class=\"number\">5</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">interest</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $slice-显示选项</span></span><br><span class=\"line\"><span class=\"comment\">// 有时候我并不需要显示出数组中的所有值，而是只显示前两项，</span></span><br><span class=\"line\"><span class=\"comment\">// 比如我们现在想显示每个人兴趣的前两项，而不是把每个人所有的兴趣都显示出来</span></span><br><span class=\"line\">db.workmate.find(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// interest: &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//   $size: 5</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">interest</span>: &#123;<span class=\"attr\">$slice</span>: <span class=\"number\">2</span>&#125;,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// 想显示兴趣的最后一项，可以直接使用slice:-1，来进行查询</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第13节：查询：find的参数使用方法\"><a href=\"#第13节：查询：find的参数使用方法\" class=\"headerlink\" title=\"第13节：查询：find的参数使用方法\"></a>第13节：查询：find的参数使用方法</h2><p><strong>在操作<code>find方法</code>的<code>第一个参数（query）</code>和<code>第二个参数（fields）</code>。<code>find</code>还有几个常用的参数，这些参数多用在分页和排序上</strong></p>\n<ul>\n<li><p><code>find</code>参数：</p>\n<ul>\n<li><code>query</code>：这个就是查询条件，MongoDB默认的第一个参数。</li>\n<li><code>fields</code>：（返回内容）查询出来后显示的结果样式，可以用true和false控制是否显示。</li>\n<li><code>limit</code>：返回的数量，后边跟数字，控制每次查询返回的结果数量。</li>\n<li><code>skip</code>: 跳过多少个显示，和limit结合可以实现分页。</li>\n<li><code>sort</code>：排序方式，从小到大排序使用1，从大到小排序使用-1</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 分页展示</span></span><br><span class=\"line\">db.workmate.find(</span><br><span class=\"line\">    &#123;&#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">name</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">age</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">_id</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;).limit(<span class=\"number\">0</span>).skip(<span class=\"number\">2</span>).sort(&#123; <span class=\"attr\">age</span>: <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong><code>$where</code>修饰符</strong></p>\n<p>它是一个非常强大的修饰符，但强大的背后也意味着有风险存在。它可以让我们在条件里使用javascript的方法来进行复杂查询。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查询年龄大于30岁的人员</span></span><br><span class=\"line\">db.workmate.find(</span><br><span class=\"line\">    &#123; <span class=\"attr\">$where</span>: <span class=\"string\">&quot;this.age&gt;30&quot;</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">name</span>: <span class=\"literal\">true</span>, <span class=\"attr\">age</span>: <span class=\"literal\">true</span>, <span class=\"attr\">_id</span>: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// this指向的是workmate（查询集合）本身。</span></span><br><span class=\"line\"><span class=\"comment\">// 这样我们就可以在程序中随意调用。</span></span><br><span class=\"line\"><span class=\"comment\">// 虽然强大和灵活，但是这种查询对于数据库的压力和安全性都会变重，</span></span><br><span class=\"line\"><span class=\"comment\">// 所以在工作中尽量减少$where修饰符的使用。</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第14节：查询：find如何在js文本中使用\"><a href=\"#第14节：查询：find如何在js文本中使用\" class=\"headerlink\" title=\"第14节：查询：find如何在js文本中使用\"></a>第14节：查询：find如何在js文本中使用</h2><ul>\n<li><p><code>find</code>查询如何才终端中<code>load()</code>执行</p>\n</li>\n<li><p><strong>hasNext循环结果</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// hasNext循环结果</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = connect(<span class=\"string\">&quot;company&quot;</span>)  <span class=\"comment\">// 进行链接对应的集合collections</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = db.workmate.find() <span class=\"comment\">// 声明变量result，并把查询结果赋值给result</span></span><br><span class=\"line\"><span class=\"comment\">// 利用游标的hasNext()进行循环输出结果。</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (result.hasNext()) &#123;</span><br><span class=\"line\">  printjson(result.next())  <span class=\"comment\">//用json格式打印结果</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong><code>forEach</code>循环</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// forEach循环</span></span><br><span class=\"line\"><span class=\"comment\">// 利用hasNext循环结果，需要借助while的帮助，</span></span><br><span class=\"line\"><span class=\"comment\">// MongoDB也为我们提供了forEach循环，现在修改上边的代码，使用forEach循环来输出结果。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = connect(<span class=\"string\">&quot;company&quot;</span>)  <span class=\"comment\">// 进行链接对应的集合collections</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = db.workmate.find() <span class=\"comment\">// 声明变量result，并把查询结果赋值给result</span></span><br><span class=\"line\"><span class=\"comment\">// 利用forEach循环</span></span><br><span class=\"line\">result.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  printjson(result)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><code>forEach</code>循环更为优雅。这两种方法都是非常不错的,凭借自己爱好进行选择吧</p>\n</li>\n</ul>\n<h2 id=\"第15节：索引-构造百万级数据\"><a href=\"#第15节：索引-构造百万级数据\" class=\"headerlink\" title=\"第15节：索引:构造百万级数据\"></a>第15节：索引:构造百万级数据</h2><ul>\n<li><p>构造百万级的数据集合</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造百万级的数据集合</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成随机数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">GetRandomNum</span>(<span class=\"params\">min, max</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> range = max - min  <span class=\"comment\">//得到随机数区间</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> rand = <span class=\"built_in\">Math</span>.random() <span class=\"comment\">//得到随机值</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (min + <span class=\"built_in\">Math</span>.round(rand * range)) <span class=\"comment\">//最小值+随机数取整 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// console.log(GetRandomNum(10000, 99999))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成随机用户名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">GetRadomUserName</span>(<span class=\"params\">min, max</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> tempStringArray = <span class=\"string\">&quot;123456789qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&quot;</span>.split(<span class=\"string\">&quot;&quot;</span>) <span class=\"comment\">//构造生成时的字母库数组</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> outPuttext = <span class=\"string\">&quot;&quot;</span> <span class=\"comment\">// 最后输出的变量</span></span><br><span class=\"line\">  <span class=\"comment\">// 进行循环，随机生产用户名的长度，这里需要生成随机数方法的配合</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; GetRandomNum(min, max); i++)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 随机抽取字母，拼装成需要的用户名</span></span><br><span class=\"line\">    outPuttext = outPuttext + tempStringArray[GetRandomNum(<span class=\"number\">0</span>, tempStringArray.length)]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> outPuttext</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// console.log(GetRadomUserName(7, 16))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插入200万数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> startTime = (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()).getTime()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = connect(<span class=\"string\">&#x27;company&#x27;</span>)</span><br><span class=\"line\">db.randomInfo.drop()</span><br><span class=\"line\"><span class=\"keyword\">var</span> tempInfo = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2000000</span>; i++)&#123;</span><br><span class=\"line\">  tempInfo.push(&#123;</span><br><span class=\"line\">    <span class=\"attr\">username</span>: GetRadomUserName(<span class=\"number\">7</span>, <span class=\"number\">16</span>),</span><br><span class=\"line\">    <span class=\"attr\">regeditTime</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(),</span><br><span class=\"line\">    <span class=\"attr\">randNum0</span>: GetRandomNum(<span class=\"number\">100000</span>, <span class=\"number\">999999</span>),</span><br><span class=\"line\">    <span class=\"attr\">randNum1</span>: GetRandomNum(<span class=\"number\">100000</span>, <span class=\"number\">999999</span>),</span><br><span class=\"line\">    <span class=\"attr\">randNum2</span>: GetRandomNum(<span class=\"number\">100000</span>, <span class=\"number\">999999</span>),</span><br><span class=\"line\">    <span class=\"attr\">randNum3</span>: GetRandomNum(<span class=\"number\">100000</span>, <span class=\"number\">999999</span>),</span><br><span class=\"line\">    <span class=\"attr\">randNum4</span>: GetRandomNum(<span class=\"number\">100000</span>, <span class=\"number\">999999</span>),</span><br><span class=\"line\">    <span class=\"attr\">randNum5</span>: GetRandomNum(<span class=\"number\">100000</span>, <span class=\"number\">999999</span>),</span><br><span class=\"line\">    <span class=\"attr\">randNum6</span>: GetRandomNum(<span class=\"number\">100000</span>, <span class=\"number\">999999</span>),</span><br><span class=\"line\">    <span class=\"attr\">randNum7</span>: GetRandomNum(<span class=\"number\">100000</span>, <span class=\"number\">999999</span>),</span><br><span class=\"line\">    <span class=\"attr\">randNum8</span>: GetRandomNum(<span class=\"number\">100000</span>, <span class=\"number\">999999</span>),</span><br><span class=\"line\">    <span class=\"attr\">randNum8</span>: GetRandomNum(<span class=\"number\">100000</span>, <span class=\"number\">999999</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">db.randomInfo.insert(tempInfo)</span><br><span class=\"line\"><span class=\"keyword\">var</span> endTime = (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()).getTime()</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">&quot;[demo]:------&quot;</span> + (endTime - startTime) + <span class=\"string\">&quot;ms&quot;</span>)</span><br></pre></td></tr></table></figure></li>\n<li><p>使用 <code>db.randomInfo.stats()</code>这个命令查看数据中的数据条数</p>\n</li>\n</ul>\n<h2 id=\"第16节：索引：索引入门\"><a href=\"#第16节：索引：索引入门\" class=\"headerlink\" title=\"第16节：索引：索引入门\"></a>第16节：索引：索引入门</h2><ul>\n<li><p><strong>索引查询</strong> — 普通查询性能</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 索引查询 --- 普通查询性能</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> startTime = (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()).getTime()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = connect(<span class=\"string\">&#x27;company&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 跳过 5000 查询  db.randomInfo.find().skip(50000)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = db.randomInfo.find(&#123;</span><br><span class=\"line\">  <span class=\"attr\">username</span>:<span class=\"string\">&quot;undefined4pi4n&quot;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">result.forEach(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">  printjson(result)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> endTime = (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()).getTime()</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">&quot;[SUCCESS]:THIS RUN TIME IS:&quot;</span> + (endTime - startTime) + <span class=\"string\">&quot;ms&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询时间 875ms左右</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>建立索引</strong> <code>createIndex()</code></p>\n<blockquote>\n<p><em>注意在 3.0.0 版本前创建索引方法为 db.collection.ensureIndex()，之后的版本使用了 db.collection.createIndex() 方法，ensureIndex() 还能用，但只是 createIndex() 的别名。</em></p>\n</blockquote>\n<ul>\n<li><p>语法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.createIndex(keys, options)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 语法中 Key 值为你要创建的索引字段，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。</span></span><br></pre></td></tr></table></figure></li>\n<li><p>用法实例：</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 建立索引  --- 试着为用户名（username）建立索引</span></span><br><span class=\"line\">db.randomInfo.createIndex(&#123; <span class=\"attr\">username</span>: <span class=\"number\">1</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// or</span></span><br><span class=\"line\">db.randomInfo.ensureIndex(&#123; <span class=\"attr\">username</span>: <span class=\"number\">1</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 复合索引</span></span><br><span class=\"line\">db.col.createIndex(&#123;<span class=\"string\">&quot;title&quot;</span>:<span class=\"number\">1</span>,<span class=\"string\">&quot;description&quot;</span>:-<span class=\"number\">1</span>&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>查看现有索引</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查看现有索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.randomInfo.getIndexes()</span><br></pre></td></tr></table></figure></li>\n<li><p>建立索引后再次执行查询 <code>load(&#39;./index_demo2.js&#39;)</code>，时间下降到 7ms了，随机波动，不超过20ms</p>\n</li>\n<li><p>无论是在关系型数据库还是文档数据库，建立索引都是非常重要的。索引这东西是要消耗硬盘和内存资源的，所以还是要根据程序需要进行建立了。<strong>MongoDB也给我们进行了限制，只允许我们建立64个索引值</strong>。</p>\n</li>\n</ul>\n<h2 id=\"第17节：索引：复合索引\"><a href=\"#第17节：索引：复合索引\" class=\"headerlink\" title=\"第17节：索引：复合索引\"></a>第17节：索引：复合索引</h2><ul>\n<li><p><strong>索引中的小坑</strong></p>\n<ul>\n<li><p>通过实际开发和性能对比，总结了几条不用索引的情况（不一定对，但是自己的经验之谈）。</p>\n</li>\n<li><p>数据不超万条时，不需要使用索引。性能的提升并不明显，而大大增加了内存和硬盘的消耗。</p>\n</li>\n<li><p>查询数据超过表数据量30%时，不要使用索引字段查询。实际证明会比不使用索引更慢，因为它大量检索了索引表和我们原表。（如查询员工的性别）</p>\n</li>\n<li><p>数字索引，要比字符串索引快的多，在百万级甚至千万级数据量面前，使用数字索引是个明确的选择。</p>\n</li>\n<li><p>把你经常查询的数据做成一个内嵌数据（对象型的数据），然后集体进行索引。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>复合索引</strong> : 复合索引就是两条以上的索引</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// db.randomInfo.ensureIndex(&#123; username: 1 &#125;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 增加建立randNum0 的索引</span></span><br><span class=\"line\">db.randomInfo.ensureIndex(&#123;<span class=\"attr\">randNum0</span>:<span class=\"number\">1</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 查看现有索引</span></span><br><span class=\"line\">db.randomInfo.getIndexes()</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>两个索引同时查询</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> startTime = (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()).getTime()</span><br><span class=\"line\"><span class=\"keyword\">var</span> db = connect(<span class=\"string\">&#x27;company&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = db.randomInfo.find(&#123;</span><br><span class=\"line\">  <span class=\"attr\">username</span>: <span class=\"string\">&quot;undefined4pi4n&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">randNum0</span>: <span class=\"number\">565509</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">result.forEach(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">  printjson(result)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> endTime = (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()).getTime()</span><br><span class=\"line\">print(<span class=\"string\">&quot;[SUCCESS]:THIS RUN TIME IS:&quot;</span> + (endTime - startTime) + <span class=\"string\">&quot;ms&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询时间 8ms</span></span><br><span class=\"line\"><span class=\"comment\">// 从性能上看并没有什么特殊的变化，查询时间还是在8ms左右。</span></span><br><span class=\"line\"><span class=\"comment\">// MongoDB的复合查询是按照我们的索引顺序进行查询的</span></span><br></pre></td></tr></table></figure></li>\n<li><p>执行查询 <code>load(&#39;./index_demo3.js&#39;)</code></p>\n</li>\n<li><p><strong>指定索引查询（<code>hint</code>）</strong></p>\n<p>数字的索引要比字符串的索引快，这就需要一个方法来打破索引表的查询顺序，用我们自己指定的索引优先查询，这个方法就是<code>hint()</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 打破索引表的查询顺序</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = db.randomInfo.find(&#123;</span><br><span class=\"line\">  <span class=\"attr\">username</span>: <span class=\"string\">&quot;undefined4pi4n&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">randNum0</span>: <span class=\"number\">565509</span></span><br><span class=\"line\">&#125;).hint(&#123; <span class=\"attr\">randNum0</span>: <span class=\"number\">1</span> &#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>删除索引</strong></p>\n<p>当索引性能不佳或起不到作用时，我们需要删除索引，删除索引的命令是<code>dropIndex()</code>. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.randomInfo.dropIndex(<span class=\"string\">&#x27;randNum0_1&#x27;</span>) <span class=\"comment\">//索引的唯一ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除时填写的值，并不是我们的字段名称（key），而是我们索引查询表中的name值</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第18节：索引：全文索引\"><a href=\"#第18节：索引：全文索引\" class=\"headerlink\" title=\"第18节：索引：全文索引\"></a>第18节：索引：全文索引</h2><ul>\n<li><p>准备数据</p>\n</li>\n<li><p><strong>建立全文索引</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 建立全文索引</span></span><br><span class=\"line\">db.info.ensureIndex(&#123; <span class=\"attr\">contextInfo</span>: <span class=\"string\">&#x27;text&#x27;</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 需要注意的是这里使用text关键词来代表全文索引，我们在这里就不建立数据模型了</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>全文索引查找</strong></p>\n<ul>\n<li><p>建立好了全文索引就可以查找了，查找时需要两个关键修饰符:</p>\n</li>\n<li><p><code>$text</code>: 表示要在全文索引中查东西。</p>\n</li>\n<li><p><code>$search</code>:后边跟查找的内容。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.info.find(&#123;<span class=\"attr\">$text</span>:&#123;<span class=\"attr\">$search</span>:<span class=\"string\">&quot;programmer&quot;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>查找多个词</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全文索引是支持多个次查找的，</span></span><br><span class=\"line\"><span class=\"comment\">// 查找数据中有programmer，family，diary，drink的数据（这是或的关系），所以两条数据都会出现</span></span><br><span class=\"line\">db.info.find(&#123; <span class=\"attr\">$text</span>: &#123; <span class=\"attr\">$search</span>: <span class=\"string\">&quot;programmer family diary drink&quot;</span> &#125; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 希望不查找出来有drink这个单词的记录，我们可以使用“-”减号来取消。</span></span><br><span class=\"line\">db.info.find(&#123; <span class=\"attr\">$text</span>: &#123; <span class=\"attr\">$search</span>: <span class=\"string\">&quot;programmer family diary -drink&quot;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>转义符：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全文搜索中是支持转义符的，比如我们想搜索的是两个词（love PlayGame和drink），这时候需要使用\\斜杠来转意。</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.info.find(&#123; <span class=\"attr\">$text</span>: &#123; <span class=\"attr\">$search</span>: <span class=\"string\">&quot;\\&quot;love PlayGame\\&quot; drink&quot;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第19节：管理-用户的创建、删除与修改\"><a href=\"#第19节：管理-用户的创建、删除与修改\" class=\"headerlink\" title=\"第19节：管理:用户的创建、删除与修改\"></a>第19节：管理:用户的创建、删除与修改</h2><ul>\n<li><p><strong>创建用户：</strong></p>\n<p>首先要进入我们的<code>admin</code>库中，进入方法是直接使用<code>use admin </code>就可以。进入后可以使用<code>show collections</code>来查看数据库中的集合。默认是只有一个集合的<code>（system.version）</code>。</p>\n<ul>\n<li>语法： <code>db.createUser()</code></li>\n<li>展示代码：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建用户权限</span></span><br><span class=\"line\">db.createUser(&#123;  </span><br><span class=\"line\">  <span class=\"attr\">user</span>: <span class=\"string\">&quot;marlon&quot;</span>,  </span><br><span class=\"line\">  <span class=\"attr\">pwd</span>: <span class=\"string\">&quot;123456&quot;</span>,  </span><br><span class=\"line\">  <span class=\"attr\">customData</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;marlon&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">email</span>: <span class=\"string\">&#x27;marlon@126.com&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">roles</span>: [<span class=\"string\">&#x27;read&#x27;</span>]  </span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// or</span></span><br><span class=\"line\"><span class=\"comment\">// 单独配置一个数据库的权限，比如我们现在要配置compay数据库的权限为读写</span></span><br><span class=\"line\">db.createUser(&#123;  </span><br><span class=\"line\">  <span class=\"attr\">user</span>: <span class=\"string\">&quot;jspang&quot;</span>,  </span><br><span class=\"line\">  <span class=\"attr\">pwd</span>: <span class=\"string\">&quot;123456&quot;</span>,  </span><br><span class=\"line\">  <span class=\"attr\">customData</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;技术胖&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">email</span>: <span class=\"string\">&#x27;web0432@126.com&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">roles</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">role</span>: <span class=\"string\">&quot;readWrite&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">db</span>: <span class=\"string\">&quot;company&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">&#x27;read&#x27;</span></span><br><span class=\"line\">  ]  </span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">内置角色：</span></span><br><span class=\"line\"><span class=\"comment\">  数据库用户角色：read、readWrite；</span></span><br><span class=\"line\"><span class=\"comment\">  数据库管理角色：dbAdmin、dbOwner、userAdmin;</span></span><br><span class=\"line\"><span class=\"comment\">  集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManage；</span></span><br><span class=\"line\"><span class=\"comment\">  备份恢复角色：backup、restore；</span></span><br><span class=\"line\"><span class=\"comment\">  所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase</span></span><br><span class=\"line\"><span class=\"comment\">  超级用户角色：root</span></span><br><span class=\"line\"><span class=\"comment\">  内部角色：__system</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>数据库内置角色配置说明：<ol>\n<li>数据库用户角色：read、readWrite；</li>\n<li>数据库管理角色：dbAdmin、dbOwner、userAdmin;</li>\n<li>集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManage；</li>\n<li>备份恢复角色：backup、restore；</li>\n<li>所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase</li>\n<li>超级用户角色：root</li>\n<li>内部角色：__system</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p><strong>查找用户信息</strong> <code>db.system.users.find()</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查找用户信息</span></span><br><span class=\"line\">db.system.users.find()</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>删除用户</strong> <code>db.system.users.remove(&#123; user: &quot;marlon&quot; &#125;)</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除用户</span></span><br><span class=\"line\">db.system.users.remove(&#123; <span class=\"attr\">user</span>: <span class=\"string\">&quot;marlon&quot;</span> &#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>鉴权</strong> <code>db.auth(name, pwd)</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 验证用户的用户名密码是否正确，就需要用到MongoDB提供的鉴权操作。也算是一种登录操作</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.auth(<span class=\"string\">&quot;jspang&quot;</span>, <span class=\"string\">&quot;123456&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 正确返回1，如果错误返回0。（Error：Authentication failed。）</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>启动建权</strong> <code>mongod --auth</code></p>\n<p>重启MongoDB服务器，然后设置必须使用鉴权登录。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// cmd 重新启动</span></span><br><span class=\"line\"></span><br><span class=\"line\">mongod --auth</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>登录</strong> <code>mongo  -u jspang -p 123456 127.0.0.1:27017/admin</code></p>\n<p>如果在配置用户之后，用户想登录，可以使用mongo的形式，不过需要配置用户名密码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongo  -u jspang -p <span class=\"number\">123456</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">27017</span>/admin</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第20节：管理：备份和还原\"><a href=\"#第20节：管理：备份和还原\" class=\"headerlink\" title=\"第20节：管理：备份和还原\"></a>第20节：管理：备份和还原</h2><ul>\n<li><p>对数据库的备份和还原: <code>mongodump</code>和<code>mongorestore</code>两个命令</p>\n</li>\n<li><p><strong>备份<code>mongodump</code></strong></p>\n<ul>\n<li><p>mongodump备份的基本格式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongodump</span><br><span class=\"line\">    --host <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br><span class=\"line\">    --port <span class=\"number\">27017</span></span><br><span class=\"line\">    --out D:<span class=\"regexp\">/databack/</span>backup   <span class=\"comment\">// 备份地址</span></span><br><span class=\"line\">    --collection myCollections</span><br><span class=\"line\">    --db test</span><br><span class=\"line\">    --username username</span><br><span class=\"line\">    --password password</span><br></pre></td></tr></table></figure></li>\n<li><p>备份演示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongodump --host <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> --port <span class=\"number\">27017</span> --out D:<span class=\"regexp\">/databack/</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>数据恢复<code>mongorestore</code></strong></p>\n<ul>\n<li><p>mongorestore恢复基本格式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongorestore</span><br><span class=\"line\">    --host <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br><span class=\"line\">    --port <span class=\"number\">27017</span></span><br><span class=\"line\">    --username username</span><br><span class=\"line\">    --password password</span><br><span class=\"line\">    &lt;path to the backup&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>恢复演示</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongorestore --host <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> --port <span class=\"number\">27017</span> D:<span class=\"regexp\">/databack/</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>两个命令很简单，甚至你可以写成脚本和定时任务，让他每天自己执行。但是如果你真的使用了MongoDB数据库，这是一个最基本的操作。</p>\n</li>\n</ul>\n<h2 id=\"第21节：管理：图形界面管理（完结）\"><a href=\"#第21节：管理：图形界面管理（完结）\" class=\"headerlink\" title=\"第21节：管理：图形界面管理（完结）\"></a>第21节：管理：图形界面管理（完结）</h2><ul>\n<li><code>NoSQL Manager for MongoDB</code></li>\n<li><code>Studio 3T</code></li>\n<li><code>MongoDB Compass</code></li>\n</ul>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h1 id=\"MongoDB基础入门\"><a href=\"#MongoDB基础入门\" class=\"headerlink\" title=\"MongoDB基础入门\"></a>MongoDB基础入门</h1><p>学习指导：<a href=\"http://www.jspang.com/posts/2017/12/16/mongodb.html\">挑战全栈 MongoDB基础视频教程 (共21集)</a></p>\n<p>参考：<a href=\"https://www.runoob.com/mongodb/mongodb-tutorial.html\">MongoDB 教程 | 菜鸟教程</a></p>\n<h2 id=\"第01节：认识和安装MongoDB\"><a href=\"#第01节：认识和安装MongoDB\" class=\"headerlink\" title=\"第01节：认识和安装MongoDB\"></a>第01节：认识和安装MongoDB</h2><ul>\n<li><p><strong>MongoDB是非关系型数据库</strong>，要了解非关系型数据库就必须先了解关系型数据库，关系数据库，是建立在关系模型基础上的数据库。比较有名气的关系型数据库，比如Oracle、DB2、MSSQL、Mysql。</p>\n</li>\n<li><p>非关系数据库和关系型数据库的区别是什么？</p>\n<ul>\n<li>实质：非关系型数据库的实质：非关系型数据库产品是传统关系型数据库的功能阉割版，通过减少用不到或很少用的功能，来大幅度提高产品性能。</li>\n<li>价格：目前的非关系型数据库基本都是免费的，而比较有名气的关系型数据库都是收费的，比如：Oracle、DB2、MSSQL。MySql虽然是免费的，但是处理大型数据还是要提前作很多工作的。</li>\n<li>功能：实际开发中，很多业务需求，其实并不需要完整的关系型数据库功能，非关系型数据库的功能就足够使用了。这种情况下，使用性能更高、成本更低的非关系型数据库当然是更明智的选择。</li>\n</ul>\n</li>\n<li><p>了解关系型数据库和非关系型数据库的区别后，需要有一点的取舍，<strong>比较复杂和大型的项目不建议使用非关系型数据库</strong>，但是如果你想作个博客，CMS系统这类业务逻辑不复杂的程序，MongoDB是完全可以胜任的。</p>\n</li>\n<li><p>MongoDB简介：</p>\n<ul>\n<li>MongoDB是一个基于分布式文件存储的数据库，由C++语言编写。目的是为WEB应用提供扩展的高性能的数据存储解决方案。</li>\n<li>MongoDB是一个介于关系型数据库和非关系型数据库之间的产品，是非关系型数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。</li>\n<li>Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</li>\n</ul>\n</li>\n<li><p>安装忽略</p>\n</li>\n<li><p><strong>运行MongoDB服务端：</strong></p>\n<ul>\n<li>安装好MongoDB数据库后，我们需要启用服务端才能使用。启用服务的命令是：Mongod。</li>\n<li>打开命令行: 先打开运行（快捷键win+R），然后输入cmd后回车，就可以打开命令行工具。</li>\n<li>执行mongod: 在命令中直接输入mongod，但是你会发现服务并没有启动，报了一个exception，服务停止了。</li>\n<li>新建文件夹:出现上边的错误，是因为我们没有简历Mongodb需要的文件夹，<code>一般是安装盘的根目录，建立data/db,这两个文件夹</code>。</li>\n<li>运行mongod：这时候服务就可以开启了，链接默认端口是27017。</li>\n</ul>\n</li>\n<li><p><strong>链接服务：</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># cmd 输入 mongo</span></span><br><span class=\"line\">mongo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#查看存在数据库命令：</span></span><br><span class=\"line\">show dbs</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 查看数据库版本命令：</span></span><br><span class=\"line\">db.version()</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第02节：Mongo基本命令-1\"><a href=\"#第02节：Mongo基本命令-1\" class=\"headerlink\" title=\"第02节：Mongo基本命令-1\"></a>第02节：Mongo基本命令-1</h2><ul>\n<li><p><strong>MongoDB的存储结构</strong> 以前我们的关系型数据库的数据结构都是顶层是库，库下面是表，表下面是数据。但是MongoDB有所不同，库下面是集合，集合下面是文件。</p>\n</li>\n<li><p><strong>基础Shell命令：</strong></p>\n<ul>\n<li><code>show dbs</code> :显示已有数据库，如果你刚安装好，会默认有<code>local、admin、config</code>，这是MongoDB的默认数据库，我们在新建库时是不允许起这些名称的。</li>\n<li><code>use admin</code>： 进入数据，也可以理解成为使用数据库。成功会显示：switched to db admin。</li>\n<li><code>show collections</code>: 显示数据库中的集合（关系型中叫表，我们要逐渐熟悉）。</li>\n<li><code>db</code>:显示当前位置，也就是你当前使用的数据库名称，这个命令算是最常用的，因为你在作任何操作的时候都要先查看一下自己所在的库，以免造成操作错误。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第03节：Mongo基本命令-2\"><a href=\"#第03节：Mongo基本命令-2\" class=\"headerlink\" title=\"第03节：Mongo基本命令-2\"></a>第03节：Mongo基本命令-2</h2><ul>\n<li><p><strong>数据操作基础命令：</strong></p>\n<ul>\n<li><p><code>use db（建立数据库）</code>：use不仅可以进入一个数据库，如果你敲入的库不存在，它还可以帮你建立一个库。但是在没有集合前，它还是默认为空。</p>\n</li>\n<li><p><code>db.集合.insert( )</code>:新建数据集合和插入文件（数据），当集合没有时，这时候就可以新建一个集合，并向里边插入数据。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.insert(&#123;“name”:”jspang”&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><code>db.集合.find( )</code>:查询所有数据，这条命令会列出集合下的所有数据，可以看到MongoDB是自动给我们加入了索引值的。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.find()</span><br></pre></td></tr></table></figure></li>\n<li><p><code>db.集合.findOne( )</code>:查询第一个文件数据，这里需要注意的，所有MongoDB的组合单词都使用首字母小写的驼峰式写法。</p>\n</li>\n<li><p><code>db.集合.update(&#123;查询&#125;,&#123;修改&#125;)</code>:修改文件数据，第一个是查询条件，第二个是要修改成的值。这里注意的是可以多加文件数据项的，比如下面的例子。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.jspang.update(&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;jspang&quot;</span>&#125;,&#123;<span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;jspang&quot;</span>,<span class=\"string\">&quot;age&quot;</span>:<span class=\"string\">&quot;32&quot;</span>&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><code>db.集合.remove(条件)</code>：删除文件数据，注意的是要跟一个条件。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.user.remove(&#123;“name”:”jspang”&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><code>db.集合.drop()</code>:删除整个集合，这个在实际工作中一定要谨慎使用，如果是程序，一定要二次确认。</p>\n</li>\n<li><p><code>db.dropDatabase()</code>: 删除整个数据库，在删除库时，一定要先进入数据库，然后再删除。实际工作中这个基本不用，实际工作可定需要保留数据和痕迹的。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第04节：用js文件写mongo命令\"><a href=\"#第04节：用js文件写mongo命令\" class=\"headerlink\" title=\"第04节：用js文件写mongo命令\"></a>第04节：用js文件写mongo命令</h2><ul>\n<li><p>编写执行代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./mongoShell/goTask.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> userName = <span class=\"string\">&#x27;jspang&#x27;</span>  <span class=\"comment\">// 声明一个登录名  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> timeStamp = <span class=\"built_in\">Date</span>.parse(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()) <span class=\"comment\">// 声明登录时的时间戳  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> jsonDdatabase = &#123;  <span class=\"comment\">// 组成JSON字符串</span></span><br><span class=\"line\">  <span class=\"string\">&quot;loginUnser&quot;</span>: userName,</span><br><span class=\"line\">  <span class=\"string\">&quot;loginTime&quot;</span>: timeStamp</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> db = connect(<span class=\"string\">&#x27;log&#x27;</span>)  <span class=\"comment\">//链接数据库</span></span><br><span class=\"line\">db.login.insert(jsonDdatabase) <span class=\"comment\">//插入数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">&#x27;[demo]log  print success&#x27;</span>)  <span class=\"comment\">//没有错误显示成功</span></span><br></pre></td></tr></table></figure></li>\n<li><p>执行</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 链接数据库(cmd)</span></span><br><span class=\"line\">mongo</span><br><span class=\"line\"></span><br><span class=\"line\">mongo goTask.js</span><br><span class=\"line\"></span><br><span class=\"line\">show dbs</span><br><span class=\"line\">use <span class=\"built_in\">log</span></span><br><span class=\"line\">show collections</span><br><span class=\"line\">db.login.find()</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第05节：批量插入的正确方法\"><a href=\"#第05节：批量插入的正确方法\" class=\"headerlink\" title=\"第05节：批量插入的正确方法\"></a>第05节：批量插入的正确方法</h2><ul>\n<li><p>在操作数据库时要注意两个能力：</p>\n<ul>\n<li>第一个是快速存储能力。</li>\n<li>第二个是方便迅速查询能力。</li>\n</ul>\n</li>\n<li><p><strong>批量插入</strong></p>\n<ul>\n<li><p>批量数据插入是以数组的方式进行的（如果写错，可以3个回车可以切出来）</p>\n</li>\n<li><p>插入数据测试</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.test.insert([</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;_id&quot;</span>:1&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;_id&quot;</span>:2&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;_id&quot;</span>:3&#125;</span><br><span class=\"line\">])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 3.2版本以前的用法</span></span><br><span class=\"line\">db.test.batchInsert([</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;_id&quot;</span>:1&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;_id&quot;</span>:2&#125;,</span><br><span class=\"line\">    &#123;<span class=\"string\">&quot;_id&quot;</span>:3&#125;</span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure></li>\n<li><p>注意一次插入不要超过48M，向.zip和大图片什么的尽量用静态存储，MongoDB存储静态路径就好。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>批量插入性能测试</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 一个个插入  执行insertTest1.js  耗时622ms</span></span><br><span class=\"line\">mongo insertTest1.js</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 批量插入  执行insertTest2.js  耗时15ms</span></span><br><span class=\"line\">mongo insertTest2.js</span><br></pre></td></tr></table></figure></li>\n<li><p>总结：在工作中一定要照顾数据库性能，这也是你水平的提现，一个技术会了很简单，但是要作精通不那么简单。学完这节，记得在工作中如果在循环插入和批量插入举起不定，那就选批量插入吧，它会给我们更优的性能体验。</p>\n</li>\n<li><p>范式流程：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> db = connect(<span class=\"string\">&#x27;company&#x27;</span>)  <span class=\"comment\">// 连接数据库</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> workmateArray = [workmate1, workmate2, workmate3]</span><br><span class=\"line\">db.workmate.insert(workmateArray)  <span class=\"comment\">// 数据库插入集合</span></span><br><span class=\"line\">print(<span class=\"string\">&#x27;[SUCCESS]: The data was inserted successfully.&#x27;</span>);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第06节：修改：Update常见错误\"><a href=\"#第06节：修改：Update常见错误\" class=\"headerlink\" title=\"第06节：修改：Update常见错误\"></a>第06节：修改：Update常见错误</h2><p>了解常见的错误操作</p>\n<h2 id=\"第07节：修改：初识update修改器\"><a href=\"#第07节：修改：初识update修改器\" class=\"headerlink\" title=\"第07节：修改：初识update修改器\"></a>第07节：修改：初识update修改器</h2><ul>\n<li><p><strong><code>$set</code>修改器</strong></p>\n<p>用来修改一个指定的键值(key)，这时候我们要修改上节课的sex和age就非常方便了，只要一句话就可以搞定。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123; <span class=\"string\">&quot;name&quot;</span>:<span class=\"string\">&quot;MinJie&quot;</span> &#125;, &#123; <span class=\"string\">&quot;$set&quot;</span>: &#123;<span class=\"attr\">sex</span>:<span class=\"number\">2</span>,<span class=\"attr\">age</span>:<span class=\"number\">21</span>&#125; &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>修改好后，我们可以用db.workmate.find()来进行查看</p>\n</li>\n<li><p><strong>修改嵌套内容(内嵌文档)</strong></p>\n<p>skill数据是内嵌的，这时候我们可以属性的形式进行修改，skill.skillThree</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123; <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;MinJie&quot;</span> &#125;, &#123; <span class=\"attr\">$set</span>: &#123; <span class=\"string\">&quot;skill.skillThree&quot;</span>: <span class=\"string\">&#x27;word&#x27;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong><code>$unset</code>用于将key删除</strong></p>\n<p>作用其实就是删除一个key值和键</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123; <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;MinJie&quot;</span> &#125;, &#123; <span class=\"attr\">$unset</span>: &#123; <span class=\"string\">&quot;age&quot;</span>: <span class=\"string\">&#x27;&#x27;</span> &#125; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接用set进行添加</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong><code>$inc</code>对数字进行计算</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123; <span class=\"string\">&quot;name&quot;</span>: <span class=\"string\">&quot;MinJie&quot;</span> &#125;, &#123; <span class=\"attr\">$inc</span>: &#123; <span class=\"string\">&quot;age&quot;</span>: -<span class=\"number\">2</span> &#125; &#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong><code>multi</code>选项</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123;&#125;, &#123; <span class=\"attr\">$set</span>: &#123; <span class=\"attr\">interset</span>: [<span class=\"string\">&#x27;basketball&#x27;</span>] &#125; &#125;, &#123; <span class=\"attr\">multi</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//每个数据都发生了改变，multi是有ture和false两个值，true代表全部修改，false代表只修改一个（默认值）</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong><code>upsert</code>选项</strong></p>\n<p>upsert是在找不到值的情况下，直接插入这条数据</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;xiaoWang&#x27;</span> &#125;, &#123; <span class=\"attr\">$set</span>: &#123; <span class=\"attr\">age</span>: <span class=\"number\">20</span> &#125; &#125;, &#123; <span class=\"attr\">upsert</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// upsert也有两个值：true代表没有就添加，false代表没有不添加(默认值)</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第08节：修改：update数组修改器\"><a href=\"#第08节：修改：update数组修改器\" class=\"headerlink\" title=\"#第08节：修改：update数组修改器\"></a><a href=\"http://www.jspang.com/posts/2017/12/16/mongodb.html#%E7%AC%AC08%E8%8A%82%EF%BC%9A%E4%BF%AE%E6%94%B9%EF%BC%9Aupdate%E6%95%B0%E7%BB%84%E4%BF%AE%E6%94%B9%E5%99%A8\">#</a>第08节：修改：update数组修改器</h2><ul>\n<li><p><strong><code>$push</code>追加数组/内嵌文档值</strong></p>\n<p><code>$push</code>的功能是追加数组中的值，但我们也经常用它操作内嵌稳文档，就是{}对象型的值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// $push追加数组/内嵌文档值</span></span><br><span class=\"line\">db.workmate.update(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;xiaoWang&#x27;</span> &#125;, &#123; <span class=\"attr\">$push</span>: &#123; <span class=\"attr\">interest</span>: <span class=\"string\">&#x27;draw&#x27;</span> &#125; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $push修饰符还可以为内嵌文档增加值</span></span><br><span class=\"line\">db.workmate.update(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;MinJie&#x27;</span> &#125;, &#123; <span class=\"attr\">$push</span>: &#123; <span class=\"string\">&quot;skill.skillFour&quot;</span>: <span class=\"string\">&#x27;draw&#x27;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure>\n\n<p><strong><code>$push</code>修饰符还可以为内嵌文档增加值</strong></p>\n</li>\n<li><p><strong><code>$ne</code>查找是否存在</strong></p>\n<p><strong>检查一个值是否存在，如果不存在再执行操作，存在就不执行</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;xiaoWang&#x27;</span>, <span class=\"string\">&quot;interest&quot;</span>: &#123; <span class=\"attr\">$ne</span>: <span class=\"string\">&#x27;playGame&#x27;</span> &#125; &#125;, &#123; <span class=\"attr\">$push</span>: &#123; <span class=\"attr\">interest</span>: <span class=\"string\">&#x27;playGame&#x27;</span> &#125; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 总结：没有则修改，有则不修改。</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong><code>$addToSet</code> 升级版的<code>$ne</code></strong></p>\n<p><code>$ne</code>的升级版本（查找是否存在，不存在就push上去），操作起来更直观和方便，所以再工作中这个要比<code>$en</code>用的多。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查看小王(xiaoWang)兴趣(interest)中有没有阅读（readBook）这项，没有则加入读书(readBook)的兴趣.</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.workmate.update(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;xiaoWang&quot;</span> &#125;, &#123; <span class=\"attr\">$addToSet</span>: &#123; <span class=\"attr\">interest</span>: <span class=\"string\">&quot;readBook&quot;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong><code>$each</code>批量追加</strong></p>\n<p>可以传入一个数组，一次增加多个值进去，相当于批量操作，性能同样比循环操作要好很多，这个是需要我们注意的，工作中也要先组合成数组，然后用批量的形式进行操作。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 给xiaoWang,一次加入三个爱好，唱歌（Sing），跳舞（Dance），编码（Code）</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> newInterset = [<span class=\"string\">&quot;Sing&quot;</span>, <span class=\"string\">&quot;Dance&quot;</span>, <span class=\"string\">&quot;Code&quot;</span>]</span><br><span class=\"line\">db.workmate.update(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&quot;xiaoWang&quot;</span> &#125;, &#123; <span class=\"attr\">$addToSet</span>: &#123; <span class=\"attr\">interest</span>: &#123; <span class=\"attr\">$each</span>: newInterset &#125; &#125; &#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong><code>$pop</code> 删除数组值</strong></p>\n<p><code>$pop</code>只删除一次，并不是删除所有数组中的值。而且它有两个选项，一个是1和-1。</p>\n<p>  1：从数组末端进行删除；  -1：从数组开端进行删除</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.workmate.update(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;xiaoWang&#x27;</span> &#125;, &#123; <span class=\"attr\">$pop</span>: &#123; <span class=\"attr\">interest</span>: <span class=\"number\">1</span> &#125; &#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong><code>interest.int</code> 数组定位修改</strong></p>\n<p>修改数组的第几位，但并不知道是什么，这时候我们可以使用<code>interest.int</code> 的形式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 修改xiaoWang的第三个兴趣为编码（Code），注意这里的计数是从0开始的</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.workmate.update(&#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;xiaoWang&#x27;</span> &#125;, &#123; <span class=\"attr\">$set</span>: &#123; <span class=\"string\">&quot;interest.2&quot;</span>: <span class=\"string\">&quot;Code&quot;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第09节：修改：状态返回与安全\"><a href=\"#第09节：修改：状态返回与安全\" class=\"headerlink\" title=\"第09节：修改：状态返回与安全\"></a>第09节：修改：状态返回与安全</h2><p>在修改时我们都会用<code>findAndModify</code>，它可以给我们返回来一些必要的参数，让我们对修改多了很多控制力，控制力的加强也就是对安全的强化能力加强。</p>\n<ul>\n<li><p><strong>应答式写入</strong></p>\n<p>在之前的操作都是非应答式写入，就是在操作完数据库后，它并没有给我们任何的回应和返回值，而是我们自己安慰自己写了一句话 <code>print(‘[update]:The data was updated successfully’)</code>。这在工作中是不允许的，因为根本不能提现我们修改的结果。应答式写入就会给我们直接返回结果（报表），结果里边的包含项会很多，这样我们就可以很好的进行程序的控制和安全机制的处理。有点像前端调用后端接口，无论作什么，后端都要给我一些状态字一样。</p>\n</li>\n<li><p><strong><code>db.runCommand( )</code></strong></p>\n<p>它是数据库运行命令的执行器，执行命令首选就要使用它，因为它在Shell和驱动程序间提供了一致的接口。（几乎操作数据库的所有操作，都可以使用<code>runCommand来执行</code>）现在我们试着用<code>runCommand</code>来修改数据库，看看结果和直接用<code>db.collections.update</code>有什么不同。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 修改了所有男士的数据，每个人增加了1000元钱(money)，然后用db.runCommand()执行</span></span><br><span class=\"line\">db.workmate.update(&#123; <span class=\"attr\">sex</span>: <span class=\"number\">1</span> &#125;, &#123; <span class=\"attr\">$set</span>: &#123; <span class=\"attr\">money</span>: <span class=\"number\">1000</span> &#125; &#125;, <span class=\"literal\">false</span>, <span class=\"literal\">true</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> resultMessage = db.runCommand(&#123; <span class=\"attr\">getLastError</span>: <span class=\"number\">1</span> &#125;)</span><br><span class=\"line\">printjson(resultMessage)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">false：第一句末尾的false是upsert的简写，代表没有此条数据时不增加;</span></span><br><span class=\"line\"><span class=\"comment\">true：true是multi的简写，代表修改所有，这两个我们在前边课程已经学过。</span></span><br><span class=\"line\"><span class=\"comment\">getLastError:1 :表示返回功能错误，这里的参数很多，如果有兴趣请自行查找学习，</span></span><br><span class=\"line\"><span class=\"comment\">printjson：表示以json对象的格式输出到控制台。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行返回结果</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;connectionId&quot;</span> : <span class=\"number\">9</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;updatedExisting&quot;</span> : <span class=\"literal\">true</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;n&quot;</span> : <span class=\"number\">3</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;syncMillis&quot;</span> : <span class=\"number\">0</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;writtenTo&quot;</span> : <span class=\"literal\">null</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;err&quot;</span> : <span class=\"literal\">null</span>,</span><br><span class=\"line\">  <span class=\"string\">&quot;ok&quot;</span> : <span class=\"number\">1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>查看是否和数据库链接成功</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.runCommand(&#123; <span class=\"attr\">ping</span>: <span class=\"number\">1</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回ok：1就代表链接正常</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">connecting to: mongodb://127.0.0.1:27017/company</span></span><br><span class=\"line\"><span class=\"comment\">Implicit session: session &#123; &quot;id&quot; : UUID(&quot;f8e213c6-c27b-4282-be47-df5a76eb72ae&quot;) &#125;</span></span><br><span class=\"line\"><span class=\"comment\">MongoDB server version: 4.0.10</span></span><br><span class=\"line\"><span class=\"comment\">true</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>findAndModify</strong></p>\n<ul>\n<li><p><code>findAndModify</code>是查找并修改的意思。配置它可以在修改后给我们返回修改的结果</p>\n</li>\n<li><p><strong><code>findAndModify</code>属性值：</strong></p>\n<ul>\n<li><code>query</code>：需要查询的条件/文档</li>\n<li><code>sort</code>: 进行排序</li>\n<li><code>remove：[boolean]</code>是否删除查找到的文档，值填写true，可以删除。</li>\n<li><code>new:[boolean]</code>返回更新前的文档还是更新后的文档。</li>\n<li><code>fields</code>：需要返回的字段</li>\n<li><code>upsert</code>：没有这个值是否增加。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// findAndModify是查找并修改的意思。配置它可以在修改后给我们返回修改的结果</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myModify = &#123;</span><br><span class=\"line\">  <span class=\"attr\">findAndModify</span>: <span class=\"string\">&quot;workmate&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">query</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;JSPang&#x27;</span> &#125;,</span><br><span class=\"line\">  <span class=\"attr\">update</span>: &#123; <span class=\"attr\">$set</span>: &#123; <span class=\"attr\">age</span>: <span class=\"number\">18</span> &#125; &#125;,</span><br><span class=\"line\">  <span class=\"attr\">new</span>: <span class=\"literal\">true</span>    <span class=\"comment\">// 更新完成，需要查看结果，如果为false不进行查看结果</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> ResultMessage = db.runCommand(myModify)</span><br><span class=\"line\">printjson(ResultMessage)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 返回结果  是最新的JSPang 数据</span></span><br></pre></td></tr></table></figure></li>\n<li><p><code>findAndModify</code>的性能是没有直接使用<code>db.collections.update</code>的性能好，但是在实际工作中都是使用它，毕竟要商用的程序安全性还是比较重要的。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"第10节：查询：find的不等修饰符\"><a href=\"#第10节：查询：find的不等修饰符\" class=\"headerlink\" title=\"第10节：查询：find的不等修饰符\"></a>第10节：查询：find的不等修饰符</h2><ul>\n<li><p>基础查找</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简单查找</span></span><br><span class=\"line\">db.workmate.find(&#123; <span class=\"string\">&quot;skill.skillOne&quot;</span>: <span class=\"string\">&quot;HTML + CSS&quot;</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 筛选字段</span></span><br><span class=\"line\">db.workmate.find(</span><br><span class=\"line\">  &#123; <span class=\"string\">&quot;skill.skillOne&quot;</span>: <span class=\"string\">&quot;HTML+CSS&quot;</span> &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;skill.skillOne&quot;</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: <span class=\"literal\">false</span>  <span class=\"comment\">// 不显示_id</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>不等修饰符</strong></p>\n<ul>\n<li><code>小于($lt)</code> : 英文全称less-than</li>\n<li><code>小于等于($lte)</code> ： 英文全称less-than-equal</li>\n<li><code>大于($gt)</code> : 英文全称greater-than</li>\n<li><code>大于等于($gte)</code>: 英文全称greater-than-equal</li>\n<li><code>不等于($ne)</code>: 英文全称not-equal</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不等查找  年龄小于30大于25岁的人</span></span><br><span class=\"line\">db.workmate.find(</span><br><span class=\"line\">  &#123; <span class=\"attr\">age</span>: &#123; <span class=\"attr\">$lte</span>: <span class=\"number\">30</span>, <span class=\"attr\">$gte</span>: <span class=\"number\">25</span> &#125; &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"literal\">true</span>, <span class=\"attr\">age</span>: <span class=\"literal\">true</span>, <span class=\"string\">&quot;skill.skillOne&quot;</span>: <span class=\"literal\">true</span>, <span class=\"attr\">_id</span>: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>日期查找</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> startDate = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(<span class=\"string\">&#x27;01/01/2018&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">db.workmate.find(</span><br><span class=\"line\">  &#123; <span class=\"attr\">regeditTime</span>: &#123; <span class=\"attr\">$gt</span>: startDate &#125; &#125;,</span><br><span class=\"line\">  &#123; <span class=\"attr\">name</span>: <span class=\"literal\">true</span>, <span class=\"attr\">age</span>: <span class=\"literal\">true</span>, <span class=\"string\">&quot;skill.skillOne&quot;</span>: <span class=\"literal\">true</span>, <span class=\"attr\">_id</span>: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></li>\n<li><p>vscode清屏 <code>cls</code></p>\n</li>\n</ul>\n<h2 id=\"第11节：查询：find的多条件查询\"><a href=\"#第11节：查询：find的多条件查询\" class=\"headerlink\" title=\"第11节：查询：find的多条件查询\"></a>第11节：查询：find的多条件查询</h2><ul>\n<li><p><strong><code>$in</code>修饰符</strong> ：in修饰符可以轻松解决一键多值的查询情况</p>\n</li>\n<li><p><strong><code>$in</code>相对的修饰符是<code>$nin</code>修饰符</strong></p>\n</li>\n<li><p><strong><code>$or</code>修饰符</strong>：用来查询多个键值的情况</p>\n</li>\n<li><p><strong><code>$nor</code>修饰符</strong></p>\n</li>\n<li><p><strong><code>$and</code>修饰符</strong>：用来查找几个key值都满足的情况  </p>\n</li>\n<li><p><strong><code>$not</code>修饰符</strong>： 用来查询除条件之外的值</p>\n</li>\n<li><p>查询演示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> db = connect(<span class=\"string\">&#x27;company&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $in 修饰符</span></span><br><span class=\"line\">db.workmate.find(&#123;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">$in</span>: [<span class=\"number\">25</span>, <span class=\"number\">33</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;skill.skillOne&quot;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $or修饰符  查出年龄大于30岁的，或者会做PHP的信息</span></span><br><span class=\"line\">db.workmate.find(&#123;</span><br><span class=\"line\">  <span class=\"attr\">$or</span>: [</span><br><span class=\"line\">    &#123; <span class=\"attr\">age</span>: &#123; <span class=\"attr\">$gt3</span>: <span class=\"number\">30</span> &#125; &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;skill.skillThree&quot;</span>: <span class=\"string\">&#x27;PHP&#x27;</span> &#125;</span><br><span class=\"line\">]&#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;skill.skillThree&quot;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $and用来查找几个key值都满足 查询同事中大于30岁并且会做PHP的信息</span></span><br><span class=\"line\">db.workmate.find(&#123;</span><br><span class=\"line\">  <span class=\"attr\">$and</span>: [</span><br><span class=\"line\">    &#123; <span class=\"attr\">age</span>: &#123; <span class=\"attr\">$gte</span>: <span class=\"number\">30</span> &#125; &#125;,</span><br><span class=\"line\">    &#123; <span class=\"string\">&quot;skill.skillThree&quot;</span>: <span class=\"string\">&#x27;PHP&#x27;</span> &#125;</span><br><span class=\"line\">]&#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;skill.skillThree&quot;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $not修饰符  用来查询除条件之外的值，比如我们现在要查找除年龄大于20岁，小于30岁的人员信息</span></span><br><span class=\"line\">db.workmate.find(&#123;</span><br><span class=\"line\">  <span class=\"attr\">age</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">$not</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">$lte</span>: <span class=\"number\">30</span>,</span><br><span class=\"line\">      <span class=\"attr\">$gte</span>: <span class=\"number\">20</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;skill.skillOne&quot;</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第12节：查询：find的数组查询\"><a href=\"#第12节：查询：find的数组查询\" class=\"headerlink\" title=\"第12节：查询：find的数组查询\"></a>第12节：查询：find的数组查询</h2><ul>\n<li><p><strong>基本数组查询</strong></p>\n</li>\n<li><p><strong><code>$all</code>数组多项查询</strong> ： 对数组中的对象进行查询，是需要满足所有条件的</p>\n</li>\n<li><p><strong><code>$in</code>数组的或者查询</strong> ： 满足数组中的一项就可以被查出来</p>\n</li>\n<li><p><strong><code>$size</code>数组个数查询</strong> : 根据数组的数量查询出结果</p>\n</li>\n<li><p><strong><code>$slice</code>显示选项</strong>: 并不需要显示出数组中的所有值，而是只显示前两项</p>\n</li>\n<li><p>查询演示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本数组查询</span></span><br><span class=\"line\"><span class=\"comment\">// 查询一个人的爱好是’画画’,’聚会’,’看电影’</span></span><br><span class=\"line\">db.workmate.find(</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">interest</span>: [<span class=\"string\">&#x27;画画&#x27;</span>, <span class=\"string\">&#x27;聚会&#x27;</span>, <span class=\"string\">&#x27;看电影&#x27;</span>]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">interest</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查出看兴趣中有看电影的员工信息</span></span><br><span class=\"line\">db.workmate.find(&#123;</span><br><span class=\"line\">  <span class=\"attr\">interest</span>: <span class=\"string\">&#x27;看电影&#x27;</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">interest</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $all-数组多项查询  查询出喜欢看电影和看书的人员信息</span></span><br><span class=\"line\">db.workmate.find(&#123;</span><br><span class=\"line\">  <span class=\"attr\">interest</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">$all</span>: [<span class=\"string\">&#x27;看电影&#x27;</span>, <span class=\"string\">&#x27;看书&#x27;</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">interest</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $in-数组的或者查询</span></span><br><span class=\"line\"><span class=\"comment\">// 用$all修饰符，是需要满足所有条件的，</span></span><br><span class=\"line\"><span class=\"comment\">// $in主要满足数组中的一项就可以被查出来（有时候会跟$or弄混）</span></span><br><span class=\"line\"><span class=\"comment\">// 查询爱好中有看电影的或者看书的员工信息</span></span><br><span class=\"line\">db.workmate.find(&#123;</span><br><span class=\"line\">  <span class=\"attr\">interest</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">$in</span>: [<span class=\"string\">&#x27;看电影&#x27;</span>, <span class=\"string\">&#x27;看书&#x27;</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">interest</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $size-数组个数查询</span></span><br><span class=\"line\"><span class=\"comment\">// $size修饰符可以根据数组的数量查询出结果。</span></span><br><span class=\"line\"><span class=\"comment\">// 查找兴趣的数量是5个人员信息</span></span><br><span class=\"line\">db.workmate.find(&#123;</span><br><span class=\"line\">  <span class=\"attr\">interest</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">$size</span>: <span class=\"number\">5</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">interest</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// $slice-显示选项</span></span><br><span class=\"line\"><span class=\"comment\">// 有时候我并不需要显示出数组中的所有值，而是只显示前两项，</span></span><br><span class=\"line\"><span class=\"comment\">// 比如我们现在想显示每个人兴趣的前两项，而不是把每个人所有的兴趣都显示出来</span></span><br><span class=\"line\">db.workmate.find(&#123;</span><br><span class=\"line\">  <span class=\"comment\">// interest: &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//   $size: 5</span></span><br><span class=\"line\">  <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">interest</span>: &#123;<span class=\"attr\">$slice</span>: <span class=\"number\">2</span>&#125;,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">_id</span>: <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// 想显示兴趣的最后一项，可以直接使用slice:-1，来进行查询</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第13节：查询：find的参数使用方法\"><a href=\"#第13节：查询：find的参数使用方法\" class=\"headerlink\" title=\"第13节：查询：find的参数使用方法\"></a>第13节：查询：find的参数使用方法</h2><p><strong>在操作<code>find方法</code>的<code>第一个参数（query）</code>和<code>第二个参数（fields）</code>。<code>find</code>还有几个常用的参数，这些参数多用在分页和排序上</strong></p>\n<ul>\n<li><p><code>find</code>参数：</p>\n<ul>\n<li><code>query</code>：这个就是查询条件，MongoDB默认的第一个参数。</li>\n<li><code>fields</code>：（返回内容）查询出来后显示的结果样式，可以用true和false控制是否显示。</li>\n<li><code>limit</code>：返回的数量，后边跟数字，控制每次查询返回的结果数量。</li>\n<li><code>skip</code>: 跳过多少个显示，和limit结合可以实现分页。</li>\n<li><code>sort</code>：排序方式，从小到大排序使用1，从大到小排序使用-1</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 分页展示</span></span><br><span class=\"line\">db.workmate.find(</span><br><span class=\"line\">    &#123;&#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"attr\">name</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">age</span>: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        <span class=\"attr\">_id</span>: <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;).limit(<span class=\"number\">0</span>).skip(<span class=\"number\">2</span>).sort(&#123; <span class=\"attr\">age</span>: <span class=\"number\">1</span> &#125;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong><code>$where</code>修饰符</strong></p>\n<p>它是一个非常强大的修饰符，但强大的背后也意味着有风险存在。它可以让我们在条件里使用javascript的方法来进行复杂查询。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查询年龄大于30岁的人员</span></span><br><span class=\"line\">db.workmate.find(</span><br><span class=\"line\">    &#123; <span class=\"attr\">$where</span>: <span class=\"string\">&quot;this.age&gt;30&quot;</span> &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">name</span>: <span class=\"literal\">true</span>, <span class=\"attr\">age</span>: <span class=\"literal\">true</span>, <span class=\"attr\">_id</span>: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// this指向的是workmate（查询集合）本身。</span></span><br><span class=\"line\"><span class=\"comment\">// 这样我们就可以在程序中随意调用。</span></span><br><span class=\"line\"><span class=\"comment\">// 虽然强大和灵活，但是这种查询对于数据库的压力和安全性都会变重，</span></span><br><span class=\"line\"><span class=\"comment\">// 所以在工作中尽量减少$where修饰符的使用。</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第14节：查询：find如何在js文本中使用\"><a href=\"#第14节：查询：find如何在js文本中使用\" class=\"headerlink\" title=\"第14节：查询：find如何在js文本中使用\"></a>第14节：查询：find如何在js文本中使用</h2><ul>\n<li><p><code>find</code>查询如何才终端中<code>load()</code>执行</p>\n</li>\n<li><p><strong>hasNext循环结果</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// hasNext循环结果</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = connect(<span class=\"string\">&quot;company&quot;</span>)  <span class=\"comment\">// 进行链接对应的集合collections</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = db.workmate.find() <span class=\"comment\">// 声明变量result，并把查询结果赋值给result</span></span><br><span class=\"line\"><span class=\"comment\">// 利用游标的hasNext()进行循环输出结果。</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (result.hasNext()) &#123;</span><br><span class=\"line\">  printjson(result.next())  <span class=\"comment\">//用json格式打印结果</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong><code>forEach</code>循环</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// forEach循环</span></span><br><span class=\"line\"><span class=\"comment\">// 利用hasNext循环结果，需要借助while的帮助，</span></span><br><span class=\"line\"><span class=\"comment\">// MongoDB也为我们提供了forEach循环，现在修改上边的代码，使用forEach循环来输出结果。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = connect(<span class=\"string\">&quot;company&quot;</span>)  <span class=\"comment\">// 进行链接对应的集合collections</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = db.workmate.find() <span class=\"comment\">// 声明变量result，并把查询结果赋值给result</span></span><br><span class=\"line\"><span class=\"comment\">// 利用forEach循环</span></span><br><span class=\"line\">result.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">result</span>) </span>&#123;</span><br><span class=\"line\">  printjson(result)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><code>forEach</code>循环更为优雅。这两种方法都是非常不错的,凭借自己爱好进行选择吧</p>\n</li>\n</ul>\n<h2 id=\"第15节：索引-构造百万级数据\"><a href=\"#第15节：索引-构造百万级数据\" class=\"headerlink\" title=\"第15节：索引:构造百万级数据\"></a>第15节：索引:构造百万级数据</h2><ul>\n<li><p>构造百万级的数据集合</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造百万级的数据集合</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成随机数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">GetRandomNum</span>(<span class=\"params\">min, max</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> range = max - min  <span class=\"comment\">//得到随机数区间</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> rand = <span class=\"built_in\">Math</span>.random() <span class=\"comment\">//得到随机值</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (min + <span class=\"built_in\">Math</span>.round(rand * range)) <span class=\"comment\">//最小值+随机数取整 </span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// console.log(GetRandomNum(10000, 99999))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 生成随机用户名</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">GetRadomUserName</span>(<span class=\"params\">min, max</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> tempStringArray = <span class=\"string\">&quot;123456789qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&quot;</span>.split(<span class=\"string\">&quot;&quot;</span>) <span class=\"comment\">//构造生成时的字母库数组</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> outPuttext = <span class=\"string\">&quot;&quot;</span> <span class=\"comment\">// 最后输出的变量</span></span><br><span class=\"line\">  <span class=\"comment\">// 进行循环，随机生产用户名的长度，这里需要生成随机数方法的配合</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; GetRandomNum(min, max); i++)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 随机抽取字母，拼装成需要的用户名</span></span><br><span class=\"line\">    outPuttext = outPuttext + tempStringArray[GetRandomNum(<span class=\"number\">0</span>, tempStringArray.length)]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> outPuttext</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// console.log(GetRadomUserName(7, 16))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插入200万数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> startTime = (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()).getTime()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = connect(<span class=\"string\">&#x27;company&#x27;</span>)</span><br><span class=\"line\">db.randomInfo.drop()</span><br><span class=\"line\"><span class=\"keyword\">var</span> tempInfo = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2000000</span>; i++)&#123;</span><br><span class=\"line\">  tempInfo.push(&#123;</span><br><span class=\"line\">    <span class=\"attr\">username</span>: GetRadomUserName(<span class=\"number\">7</span>, <span class=\"number\">16</span>),</span><br><span class=\"line\">    <span class=\"attr\">regeditTime</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(),</span><br><span class=\"line\">    <span class=\"attr\">randNum0</span>: GetRandomNum(<span class=\"number\">100000</span>, <span class=\"number\">999999</span>),</span><br><span class=\"line\">    <span class=\"attr\">randNum1</span>: GetRandomNum(<span class=\"number\">100000</span>, <span class=\"number\">999999</span>),</span><br><span class=\"line\">    <span class=\"attr\">randNum2</span>: GetRandomNum(<span class=\"number\">100000</span>, <span class=\"number\">999999</span>),</span><br><span class=\"line\">    <span class=\"attr\">randNum3</span>: GetRandomNum(<span class=\"number\">100000</span>, <span class=\"number\">999999</span>),</span><br><span class=\"line\">    <span class=\"attr\">randNum4</span>: GetRandomNum(<span class=\"number\">100000</span>, <span class=\"number\">999999</span>),</span><br><span class=\"line\">    <span class=\"attr\">randNum5</span>: GetRandomNum(<span class=\"number\">100000</span>, <span class=\"number\">999999</span>),</span><br><span class=\"line\">    <span class=\"attr\">randNum6</span>: GetRandomNum(<span class=\"number\">100000</span>, <span class=\"number\">999999</span>),</span><br><span class=\"line\">    <span class=\"attr\">randNum7</span>: GetRandomNum(<span class=\"number\">100000</span>, <span class=\"number\">999999</span>),</span><br><span class=\"line\">    <span class=\"attr\">randNum8</span>: GetRandomNum(<span class=\"number\">100000</span>, <span class=\"number\">999999</span>),</span><br><span class=\"line\">    <span class=\"attr\">randNum8</span>: GetRandomNum(<span class=\"number\">100000</span>, <span class=\"number\">999999</span>)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">db.randomInfo.insert(tempInfo)</span><br><span class=\"line\"><span class=\"keyword\">var</span> endTime = (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()).getTime()</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">&quot;[demo]:------&quot;</span> + (endTime - startTime) + <span class=\"string\">&quot;ms&quot;</span>)</span><br></pre></td></tr></table></figure></li>\n<li><p>使用 <code>db.randomInfo.stats()</code>这个命令查看数据中的数据条数</p>\n</li>\n</ul>\n<h2 id=\"第16节：索引：索引入门\"><a href=\"#第16节：索引：索引入门\" class=\"headerlink\" title=\"第16节：索引：索引入门\"></a>第16节：索引：索引入门</h2><ul>\n<li><p><strong>索引查询</strong> — 普通查询性能</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 索引查询 --- 普通查询性能</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> startTime = (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()).getTime()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> db = connect(<span class=\"string\">&#x27;company&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 跳过 5000 查询  db.randomInfo.find().skip(50000)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = db.randomInfo.find(&#123;</span><br><span class=\"line\">  <span class=\"attr\">username</span>:<span class=\"string\">&quot;undefined4pi4n&quot;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">result.forEach(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">  printjson(result)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> endTime = (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()).getTime()</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">&quot;[SUCCESS]:THIS RUN TIME IS:&quot;</span> + (endTime - startTime) + <span class=\"string\">&quot;ms&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询时间 875ms左右</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>建立索引</strong> <code>createIndex()</code></p>\n<blockquote>\n<p><em>注意在 3.0.0 版本前创建索引方法为 db.collection.ensureIndex()，之后的版本使用了 db.collection.createIndex() 方法，ensureIndex() 还能用，但只是 createIndex() 的别名。</em></p>\n</blockquote>\n<ul>\n<li><p>语法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.collection.createIndex(keys, options)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 语法中 Key 值为你要创建的索引字段，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。</span></span><br></pre></td></tr></table></figure></li>\n<li><p>用法实例：</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 建立索引  --- 试着为用户名（username）建立索引</span></span><br><span class=\"line\">db.randomInfo.createIndex(&#123; <span class=\"attr\">username</span>: <span class=\"number\">1</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// or</span></span><br><span class=\"line\">db.randomInfo.ensureIndex(&#123; <span class=\"attr\">username</span>: <span class=\"number\">1</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 复合索引</span></span><br><span class=\"line\">db.col.createIndex(&#123;<span class=\"string\">&quot;title&quot;</span>:<span class=\"number\">1</span>,<span class=\"string\">&quot;description&quot;</span>:-<span class=\"number\">1</span>&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>查看现有索引</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查看现有索引</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.randomInfo.getIndexes()</span><br></pre></td></tr></table></figure></li>\n<li><p>建立索引后再次执行查询 <code>load(&#39;./index_demo2.js&#39;)</code>，时间下降到 7ms了，随机波动，不超过20ms</p>\n</li>\n<li><p>无论是在关系型数据库还是文档数据库，建立索引都是非常重要的。索引这东西是要消耗硬盘和内存资源的，所以还是要根据程序需要进行建立了。<strong>MongoDB也给我们进行了限制，只允许我们建立64个索引值</strong>。</p>\n</li>\n</ul>\n<h2 id=\"第17节：索引：复合索引\"><a href=\"#第17节：索引：复合索引\" class=\"headerlink\" title=\"第17节：索引：复合索引\"></a>第17节：索引：复合索引</h2><ul>\n<li><p><strong>索引中的小坑</strong></p>\n<ul>\n<li><p>通过实际开发和性能对比，总结了几条不用索引的情况（不一定对，但是自己的经验之谈）。</p>\n</li>\n<li><p>数据不超万条时，不需要使用索引。性能的提升并不明显，而大大增加了内存和硬盘的消耗。</p>\n</li>\n<li><p>查询数据超过表数据量30%时，不要使用索引字段查询。实际证明会比不使用索引更慢，因为它大量检索了索引表和我们原表。（如查询员工的性别）</p>\n</li>\n<li><p>数字索引，要比字符串索引快的多，在百万级甚至千万级数据量面前，使用数字索引是个明确的选择。</p>\n</li>\n<li><p>把你经常查询的数据做成一个内嵌数据（对象型的数据），然后集体进行索引。</p>\n</li>\n</ul>\n</li>\n<li><p><strong>复合索引</strong> : 复合索引就是两条以上的索引</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// db.randomInfo.ensureIndex(&#123; username: 1 &#125;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 增加建立randNum0 的索引</span></span><br><span class=\"line\">db.randomInfo.ensureIndex(&#123;<span class=\"attr\">randNum0</span>:<span class=\"number\">1</span>&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 查看现有索引</span></span><br><span class=\"line\">db.randomInfo.getIndexes()</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>两个索引同时查询</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> startTime = (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()).getTime()</span><br><span class=\"line\"><span class=\"keyword\">var</span> db = connect(<span class=\"string\">&#x27;company&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = db.randomInfo.find(&#123;</span><br><span class=\"line\">  <span class=\"attr\">username</span>: <span class=\"string\">&quot;undefined4pi4n&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">randNum0</span>: <span class=\"number\">565509</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">result.forEach(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> &#123;</span><br><span class=\"line\">  printjson(result)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> endTime = (<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()).getTime()</span><br><span class=\"line\">print(<span class=\"string\">&quot;[SUCCESS]:THIS RUN TIME IS:&quot;</span> + (endTime - startTime) + <span class=\"string\">&quot;ms&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 查询时间 8ms</span></span><br><span class=\"line\"><span class=\"comment\">// 从性能上看并没有什么特殊的变化，查询时间还是在8ms左右。</span></span><br><span class=\"line\"><span class=\"comment\">// MongoDB的复合查询是按照我们的索引顺序进行查询的</span></span><br></pre></td></tr></table></figure></li>\n<li><p>执行查询 <code>load(&#39;./index_demo3.js&#39;)</code></p>\n</li>\n<li><p><strong>指定索引查询（<code>hint</code>）</strong></p>\n<p>数字的索引要比字符串的索引快，这就需要一个方法来打破索引表的查询顺序，用我们自己指定的索引优先查询，这个方法就是<code>hint()</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 打破索引表的查询顺序</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = db.randomInfo.find(&#123;</span><br><span class=\"line\">  <span class=\"attr\">username</span>: <span class=\"string\">&quot;undefined4pi4n&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">randNum0</span>: <span class=\"number\">565509</span></span><br><span class=\"line\">&#125;).hint(&#123; <span class=\"attr\">randNum0</span>: <span class=\"number\">1</span> &#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>删除索引</strong></p>\n<p>当索引性能不佳或起不到作用时，我们需要删除索引，删除索引的命令是<code>dropIndex()</code>. </p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.randomInfo.dropIndex(<span class=\"string\">&#x27;randNum0_1&#x27;</span>) <span class=\"comment\">//索引的唯一ID</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除时填写的值，并不是我们的字段名称（key），而是我们索引查询表中的name值</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第18节：索引：全文索引\"><a href=\"#第18节：索引：全文索引\" class=\"headerlink\" title=\"第18节：索引：全文索引\"></a>第18节：索引：全文索引</h2><ul>\n<li><p>准备数据</p>\n</li>\n<li><p><strong>建立全文索引</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 建立全文索引</span></span><br><span class=\"line\">db.info.ensureIndex(&#123; <span class=\"attr\">contextInfo</span>: <span class=\"string\">&#x27;text&#x27;</span> &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 需要注意的是这里使用text关键词来代表全文索引，我们在这里就不建立数据模型了</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>全文索引查找</strong></p>\n<ul>\n<li><p>建立好了全文索引就可以查找了，查找时需要两个关键修饰符:</p>\n</li>\n<li><p><code>$text</code>: 表示要在全文索引中查东西。</p>\n</li>\n<li><p><code>$search</code>:后边跟查找的内容。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db.info.find(&#123;<span class=\"attr\">$text</span>:&#123;<span class=\"attr\">$search</span>:<span class=\"string\">&quot;programmer&quot;</span>&#125;&#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>查找多个词</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全文索引是支持多个次查找的，</span></span><br><span class=\"line\"><span class=\"comment\">// 查找数据中有programmer，family，diary，drink的数据（这是或的关系），所以两条数据都会出现</span></span><br><span class=\"line\">db.info.find(&#123; <span class=\"attr\">$text</span>: &#123; <span class=\"attr\">$search</span>: <span class=\"string\">&quot;programmer family diary drink&quot;</span> &#125; &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 希望不查找出来有drink这个单词的记录，我们可以使用“-”减号来取消。</span></span><br><span class=\"line\">db.info.find(&#123; <span class=\"attr\">$text</span>: &#123; <span class=\"attr\">$search</span>: <span class=\"string\">&quot;programmer family diary -drink&quot;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>转义符：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 全文搜索中是支持转义符的，比如我们想搜索的是两个词（love PlayGame和drink），这时候需要使用\\斜杠来转意。</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.info.find(&#123; <span class=\"attr\">$text</span>: &#123; <span class=\"attr\">$search</span>: <span class=\"string\">&quot;\\&quot;love PlayGame\\&quot; drink&quot;</span> &#125; &#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第19节：管理-用户的创建、删除与修改\"><a href=\"#第19节：管理-用户的创建、删除与修改\" class=\"headerlink\" title=\"第19节：管理:用户的创建、删除与修改\"></a>第19节：管理:用户的创建、删除与修改</h2><ul>\n<li><p><strong>创建用户：</strong></p>\n<p>首先要进入我们的<code>admin</code>库中，进入方法是直接使用<code>use admin </code>就可以。进入后可以使用<code>show collections</code>来查看数据库中的集合。默认是只有一个集合的<code>（system.version）</code>。</p>\n<ul>\n<li>语法： <code>db.createUser()</code></li>\n<li>展示代码：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建用户权限</span></span><br><span class=\"line\">db.createUser(&#123;  </span><br><span class=\"line\">  <span class=\"attr\">user</span>: <span class=\"string\">&quot;marlon&quot;</span>,  </span><br><span class=\"line\">  <span class=\"attr\">pwd</span>: <span class=\"string\">&quot;123456&quot;</span>,  </span><br><span class=\"line\">  <span class=\"attr\">customData</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;marlon&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">email</span>: <span class=\"string\">&#x27;marlon@126.com&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">roles</span>: [<span class=\"string\">&#x27;read&#x27;</span>]  </span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// or</span></span><br><span class=\"line\"><span class=\"comment\">// 单独配置一个数据库的权限，比如我们现在要配置compay数据库的权限为读写</span></span><br><span class=\"line\">db.createUser(&#123;  </span><br><span class=\"line\">  <span class=\"attr\">user</span>: <span class=\"string\">&quot;jspang&quot;</span>,  </span><br><span class=\"line\">  <span class=\"attr\">pwd</span>: <span class=\"string\">&quot;123456&quot;</span>,  </span><br><span class=\"line\">  <span class=\"attr\">customData</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">name</span>: <span class=\"string\">&#x27;技术胖&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">email</span>: <span class=\"string\">&#x27;web0432@126.com&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">age</span>: <span class=\"number\">18</span>,</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">roles</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">role</span>: <span class=\"string\">&quot;readWrite&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">db</span>: <span class=\"string\">&quot;company&quot;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">&#x27;read&#x27;</span></span><br><span class=\"line\">  ]  </span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">内置角色：</span></span><br><span class=\"line\"><span class=\"comment\">  数据库用户角色：read、readWrite；</span></span><br><span class=\"line\"><span class=\"comment\">  数据库管理角色：dbAdmin、dbOwner、userAdmin;</span></span><br><span class=\"line\"><span class=\"comment\">  集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManage；</span></span><br><span class=\"line\"><span class=\"comment\">  备份恢复角色：backup、restore；</span></span><br><span class=\"line\"><span class=\"comment\">  所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase</span></span><br><span class=\"line\"><span class=\"comment\">  超级用户角色：root</span></span><br><span class=\"line\"><span class=\"comment\">  内部角色：__system</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>数据库内置角色配置说明：<ol>\n<li>数据库用户角色：read、readWrite；</li>\n<li>数据库管理角色：dbAdmin、dbOwner、userAdmin;</li>\n<li>集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManage；</li>\n<li>备份恢复角色：backup、restore；</li>\n<li>所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase</li>\n<li>超级用户角色：root</li>\n<li>内部角色：__system</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><p><strong>查找用户信息</strong> <code>db.system.users.find()</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 查找用户信息</span></span><br><span class=\"line\">db.system.users.find()</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>删除用户</strong> <code>db.system.users.remove(&#123; user: &quot;marlon&quot; &#125;)</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除用户</span></span><br><span class=\"line\">db.system.users.remove(&#123; <span class=\"attr\">user</span>: <span class=\"string\">&quot;marlon&quot;</span> &#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>鉴权</strong> <code>db.auth(name, pwd)</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 验证用户的用户名密码是否正确，就需要用到MongoDB提供的鉴权操作。也算是一种登录操作</span></span><br><span class=\"line\"></span><br><span class=\"line\">db.auth(<span class=\"string\">&quot;jspang&quot;</span>, <span class=\"string\">&quot;123456&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 正确返回1，如果错误返回0。（Error：Authentication failed。）</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>启动建权</strong> <code>mongod --auth</code></p>\n<p>重启MongoDB服务器，然后设置必须使用鉴权登录。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// cmd 重新启动</span></span><br><span class=\"line\"></span><br><span class=\"line\">mongod --auth</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>登录</strong> <code>mongo  -u jspang -p 123456 127.0.0.1:27017/admin</code></p>\n<p>如果在配置用户之后，用户想登录，可以使用mongo的形式，不过需要配置用户名密码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongo  -u jspang -p <span class=\"number\">123456</span> <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span>:<span class=\"number\">27017</span>/admin</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第20节：管理：备份和还原\"><a href=\"#第20节：管理：备份和还原\" class=\"headerlink\" title=\"第20节：管理：备份和还原\"></a>第20节：管理：备份和还原</h2><ul>\n<li><p>对数据库的备份和还原: <code>mongodump</code>和<code>mongorestore</code>两个命令</p>\n</li>\n<li><p><strong>备份<code>mongodump</code></strong></p>\n<ul>\n<li><p>mongodump备份的基本格式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongodump</span><br><span class=\"line\">    --host <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br><span class=\"line\">    --port <span class=\"number\">27017</span></span><br><span class=\"line\">    --out D:<span class=\"regexp\">/databack/</span>backup   <span class=\"comment\">// 备份地址</span></span><br><span class=\"line\">    --collection myCollections</span><br><span class=\"line\">    --db test</span><br><span class=\"line\">    --username username</span><br><span class=\"line\">    --password password</span><br></pre></td></tr></table></figure></li>\n<li><p>备份演示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongodump --host <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> --port <span class=\"number\">27017</span> --out D:<span class=\"regexp\">/databack/</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><strong>数据恢复<code>mongorestore</code></strong></p>\n<ul>\n<li><p>mongorestore恢复基本格式</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongorestore</span><br><span class=\"line\">    --host <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span></span><br><span class=\"line\">    --port <span class=\"number\">27017</span></span><br><span class=\"line\">    --username username</span><br><span class=\"line\">    --password password</span><br><span class=\"line\">    &lt;path to the backup&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p>恢复演示</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mongorestore --host <span class=\"number\">127.0</span><span class=\"number\">.0</span><span class=\"number\">.1</span> --port <span class=\"number\">27017</span> D:<span class=\"regexp\">/databack/</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>两个命令很简单，甚至你可以写成脚本和定时任务，让他每天自己执行。但是如果你真的使用了MongoDB数据库，这是一个最基本的操作。</p>\n</li>\n</ul>\n<h2 id=\"第21节：管理：图形界面管理（完结）\"><a href=\"#第21节：管理：图形界面管理（完结）\" class=\"headerlink\" title=\"第21节：管理：图形界面管理（完结）\"></a>第21节：管理：图形界面管理（完结）</h2><ul>\n<li><code>NoSQL Manager for MongoDB</code></li>\n<li><code>Studio 3T</code></li>\n<li><code>MongoDB Compass</code></li>\n</ul>\n"},{"title":"Hexo 入门初级指南","date":"2021-03-18T04:07:33.000Z","type":"其他","note":"使用GitHub搭建Hexo博客完整操作手册","_content":"\n## 写在前边\n使用github pages服务搭建博客的好处有：\n\n1. 全是静态文件，访问速度快；\n2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；\n3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；\n\n<!--more-->\n\n4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；\n5. 博客内容可以轻松打包、转移、发布到其它平台；\n\n## 准备工作\n### 安装 Node.js\n\n### 安装 Git\n\n## 安装 Hexo\n* 打开命令行，在命令行中输入以下命令:\n  `npm install -g hexo-cli` \n* 安装Hexo的Git插件（如果不安装这个插件，会导致Hexo博客内容无法发布）\n  `npm install hexo-deployer-git --save`\n\n## 本地搭建Hexo博客\n* 打开命令行，输入以下命令，用于创建Hexo博客目录。\n    ```\n    // 指的是用于创建Hexo博客的目录，例如 e:/hexo  hexo init <folder>\n    hexo init e:/Hexo \n    ```\n* 进入创建的项目，打开命令行，输入如下命令\n    ```\n    npm install\n    ```\n\n* 初始化完毕后，可以在命令行中输入以下命令，启动本地Hexo博客程序。 \n    ```\n    npm server\n    ```\n\n* 命令行出现如下信息，打开浏览器，访问 http://localhost:4000 就可以访问本地的Hexo博客程序了。\n    ```\n    $ hexo s\n    INFO  Start processing\n    INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.\n    ```\n\n## **发布博客到GitHub**\n* 注册GitHub账户\n* 创建GitHub工程\n* 配置Hexo程序\n```\n// 进入Hexo的安装目录，打开_config.yml配置文件。\n\n# Site\ntitle: 网站名称\nsubtitle: 网站简介\ndescription:\nauthor: 作者\nlanguage:\ntimezone:\n\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: 网站域名  (例如：https://mengjie0611.github.io/)\nroot: /\npermalink: :category/:title.html\npermalink_defaults:\n\n...\n\n# Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: GitHub新建工程的地址（例如 git@github.com:mengjie0611/mengjie0611.github.io.git）\n  branch: master\n```\n\n## 发布Hexo到GitHub\n* 在Hexo的安装目录中，鼠标右键选择”Git Bash Here”选项。\n* 在Git命令行中，输入以下命令。\n    ```\n    // 生成hexo本地目录结构\n    hexo generate\n\n    // 将hexo本地目录上传至GitCafe\n    hexo deploy\n    ```","source":"_posts/hexo入门.md","raw":"---\ntitle: Hexo 入门初级指南\ndate: 2021-03-18 12:07:33\ntype: 其他\ntags: Hexo\nnote: 使用GitHub搭建Hexo博客完整操作手册\n---\n\n## 写在前边\n使用github pages服务搭建博客的好处有：\n\n1. 全是静态文件，访问速度快；\n2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；\n3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；\n\n<!--more-->\n\n4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；\n5. 博客内容可以轻松打包、转移、发布到其它平台；\n\n## 准备工作\n### 安装 Node.js\n\n### 安装 Git\n\n## 安装 Hexo\n* 打开命令行，在命令行中输入以下命令:\n  `npm install -g hexo-cli` \n* 安装Hexo的Git插件（如果不安装这个插件，会导致Hexo博客内容无法发布）\n  `npm install hexo-deployer-git --save`\n\n## 本地搭建Hexo博客\n* 打开命令行，输入以下命令，用于创建Hexo博客目录。\n    ```\n    // 指的是用于创建Hexo博客的目录，例如 e:/hexo  hexo init <folder>\n    hexo init e:/Hexo \n    ```\n* 进入创建的项目，打开命令行，输入如下命令\n    ```\n    npm install\n    ```\n\n* 初始化完毕后，可以在命令行中输入以下命令，启动本地Hexo博客程序。 \n    ```\n    npm server\n    ```\n\n* 命令行出现如下信息，打开浏览器，访问 http://localhost:4000 就可以访问本地的Hexo博客程序了。\n    ```\n    $ hexo s\n    INFO  Start processing\n    INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.\n    ```\n\n## **发布博客到GitHub**\n* 注册GitHub账户\n* 创建GitHub工程\n* 配置Hexo程序\n```\n// 进入Hexo的安装目录，打开_config.yml配置文件。\n\n# Site\ntitle: 网站名称\nsubtitle: 网站简介\ndescription:\nauthor: 作者\nlanguage:\ntimezone:\n\n# URL\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: 网站域名  (例如：https://mengjie0611.github.io/)\nroot: /\npermalink: :category/:title.html\npermalink_defaults:\n\n...\n\n# Deployment\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repository: GitHub新建工程的地址（例如 git@github.com:mengjie0611/mengjie0611.github.io.git）\n  branch: master\n```\n\n## 发布Hexo到GitHub\n* 在Hexo的安装目录中，鼠标右键选择”Git Bash Here”选项。\n* 在Git命令行中，输入以下命令。\n    ```\n    // 生成hexo本地目录结构\n    hexo generate\n\n    // 将hexo本地目录上传至GitCafe\n    hexo deploy\n    ```","slug":"hexo入门","published":1,"updated":"2021-07-19T03:13:28.201Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrd8jv160001kwzt797a4gyu","content":"<h2 id=\"写在前边\"><a href=\"#写在前边\" class=\"headerlink\" title=\"写在前边\"></a>写在前边</h2><p>使用github pages服务搭建博客的好处有：</p>\n<ol>\n<li>全是静态文件，访问速度快；</li>\n<li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li>\n<li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li>\n</ol>\n<span id=\"more\"></span>\n\n<ol start=\"4\">\n<li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li>\n<li>博客内容可以轻松打包、转移、发布到其它平台；</li>\n</ol>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"安装-Node-js\"><a href=\"#安装-Node-js\" class=\"headerlink\" title=\"安装 Node.js\"></a>安装 Node.js</h3><h3 id=\"安装-Git\"><a href=\"#安装-Git\" class=\"headerlink\" title=\"安装 Git\"></a>安装 Git</h3><h2 id=\"安装-Hexo\"><a href=\"#安装-Hexo\" class=\"headerlink\" title=\"安装 Hexo\"></a>安装 Hexo</h2><ul>\n<li>打开命令行，在命令行中输入以下命令:<br><code>npm install -g hexo-cli</code> </li>\n<li>安装Hexo的Git插件（如果不安装这个插件，会导致Hexo博客内容无法发布）<br><code>npm install hexo-deployer-git --save</code></li>\n</ul>\n<h2 id=\"本地搭建Hexo博客\"><a href=\"#本地搭建Hexo博客\" class=\"headerlink\" title=\"本地搭建Hexo博客\"></a>本地搭建Hexo博客</h2><ul>\n<li><p>打开命令行，输入以下命令，用于创建Hexo博客目录。</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 指的是用于创建Hexo博客的目录，例如 e:/hexo  hexo init &lt;folder&gt;</span><br><span class=\"line\">hexo init e:/Hexo </span><br></pre></td></tr></table></figure></li>\n<li><p>进入创建的项目，打开命令行，输入如下命令</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure></li>\n<li><p>初始化完毕后，可以在命令行中输入以下命令，启动本地Hexo博客程序。 </p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm server</span><br></pre></td></tr></table></figure></li>\n<li><p>命令行出现如下信息，打开浏览器，访问 <a href=\"http://localhost:4000/\">http://localhost:4000</a> 就可以访问本地的Hexo博客程序了。</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s</span><br><span class=\"line\">INFO  Start processing</span><br><span class=\"line\">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"发布博客到GitHub\"><a href=\"#发布博客到GitHub\" class=\"headerlink\" title=\"发布博客到GitHub\"></a><strong>发布博客到GitHub</strong></h2><ul>\n<li>注册GitHub账户</li>\n<li>创建GitHub工程</li>\n<li>配置Hexo程序<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 进入Hexo的安装目录，打开_config.yml配置文件。</span><br><span class=\"line\"></span><br><span class=\"line\"># Site</span><br><span class=\"line\">title: 网站名称</span><br><span class=\"line\">subtitle: 网站简介</span><br><span class=\"line\">description:</span><br><span class=\"line\">author: 作者</span><br><span class=\"line\">language:</span><br><span class=\"line\">timezone:</span><br><span class=\"line\"></span><br><span class=\"line\"># URL</span><br><span class=\"line\">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class=\"line\">url: 网站域名  (例如：https://mengjie0611.github.io/)</span><br><span class=\"line\">root: /</span><br><span class=\"line\">permalink: :category/:title.html</span><br><span class=\"line\">permalink_defaults:</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: http://hexo.io/docs/deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: GitHub新建工程的地址（例如 git@github.com:mengjie0611/mengjie0611.github.io.git）</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"发布Hexo到GitHub\"><a href=\"#发布Hexo到GitHub\" class=\"headerlink\" title=\"发布Hexo到GitHub\"></a>发布Hexo到GitHub</h2><ul>\n<li>在Hexo的安装目录中，鼠标右键选择”Git Bash Here”选项。</li>\n<li>在Git命令行中，输入以下命令。  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 生成hexo本地目录结构</span><br><span class=\"line\">hexo generate</span><br><span class=\"line\"></span><br><span class=\"line\">// 将hexo本地目录上传至GitCafe</span><br><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"<h2 id=\"写在前边\"><a href=\"#写在前边\" class=\"headerlink\" title=\"写在前边\"></a>写在前边</h2><p>使用github pages服务搭建博客的好处有：</p>\n<ol>\n<li>全是静态文件，访问速度快；</li>\n<li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li>\n<li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li>\n</ol>","more":"<ol start=\"4\">\n<li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li>\n<li>博客内容可以轻松打包、转移、发布到其它平台；</li>\n</ol>\n<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><h3 id=\"安装-Node-js\"><a href=\"#安装-Node-js\" class=\"headerlink\" title=\"安装 Node.js\"></a>安装 Node.js</h3><h3 id=\"安装-Git\"><a href=\"#安装-Git\" class=\"headerlink\" title=\"安装 Git\"></a>安装 Git</h3><h2 id=\"安装-Hexo\"><a href=\"#安装-Hexo\" class=\"headerlink\" title=\"安装 Hexo\"></a>安装 Hexo</h2><ul>\n<li>打开命令行，在命令行中输入以下命令:<br><code>npm install -g hexo-cli</code> </li>\n<li>安装Hexo的Git插件（如果不安装这个插件，会导致Hexo博客内容无法发布）<br><code>npm install hexo-deployer-git --save</code></li>\n</ul>\n<h2 id=\"本地搭建Hexo博客\"><a href=\"#本地搭建Hexo博客\" class=\"headerlink\" title=\"本地搭建Hexo博客\"></a>本地搭建Hexo博客</h2><ul>\n<li><p>打开命令行，输入以下命令，用于创建Hexo博客目录。</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 指的是用于创建Hexo博客的目录，例如 e:/hexo  hexo init &lt;folder&gt;</span><br><span class=\"line\">hexo init e:/Hexo </span><br></pre></td></tr></table></figure></li>\n<li><p>进入创建的项目，打开命令行，输入如下命令</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure></li>\n<li><p>初始化完毕后，可以在命令行中输入以下命令，启动本地Hexo博客程序。 </p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm server</span><br></pre></td></tr></table></figure></li>\n<li><p>命令行出现如下信息，打开浏览器，访问 <a href=\"http://localhost:4000/\">http://localhost:4000</a> 就可以访问本地的Hexo博客程序了。</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s</span><br><span class=\"line\">INFO  Start processing</span><br><span class=\"line\">INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"发布博客到GitHub\"><a href=\"#发布博客到GitHub\" class=\"headerlink\" title=\"发布博客到GitHub\"></a><strong>发布博客到GitHub</strong></h2><ul>\n<li>注册GitHub账户</li>\n<li>创建GitHub工程</li>\n<li>配置Hexo程序<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 进入Hexo的安装目录，打开_config.yml配置文件。</span><br><span class=\"line\"></span><br><span class=\"line\"># Site</span><br><span class=\"line\">title: 网站名称</span><br><span class=\"line\">subtitle: 网站简介</span><br><span class=\"line\">description:</span><br><span class=\"line\">author: 作者</span><br><span class=\"line\">language:</span><br><span class=\"line\">timezone:</span><br><span class=\"line\"></span><br><span class=\"line\"># URL</span><br><span class=\"line\">## If your site is put in a subdirectory, set url as &#x27;http://yoursite.com/child&#x27; and root as &#x27;/child/&#x27;</span><br><span class=\"line\">url: 网站域名  (例如：https://mengjie0611.github.io/)</span><br><span class=\"line\">root: /</span><br><span class=\"line\">permalink: :category/:title.html</span><br><span class=\"line\">permalink_defaults:</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"># Deployment</span><br><span class=\"line\">## Docs: http://hexo.io/docs/deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repository: GitHub新建工程的地址（例如 git@github.com:mengjie0611/mengjie0611.github.io.git）</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"发布Hexo到GitHub\"><a href=\"#发布Hexo到GitHub\" class=\"headerlink\" title=\"发布Hexo到GitHub\"></a>发布Hexo到GitHub</h2><ul>\n<li>在Hexo的安装目录中，鼠标右键选择”Git Bash Here”选项。</li>\n<li>在Git命令行中，输入以下命令。  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 生成hexo本地目录结构</span><br><span class=\"line\">hexo generate</span><br><span class=\"line\"></span><br><span class=\"line\">// 将hexo本地目录上传至GitCafe</span><br><span class=\"line\">hexo deploy</span><br></pre></td></tr></table></figure></li>\n</ul>"},{"title":"butterfly博客主题的详细配置","date":"2021-07-19T03:14:48.355Z","type":"其他","note":"修改主题篇 --> 推荐二 --> hexo-theme-butterfly","_content":"\n## 1. 安装\n### 1.1 安装主题\n```\ngit clone https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly\n```\n### 1.2 启用主题\n打开根`_config.yml`配置文件，找到theme字段，将其值改为butterfly(先确认主题文件夹名称是否为butterfly)。\n\n```\n// 根 _config.yml\ntheme: butterfly\n```\n修改后在根目录文件夹下执行以下代码\n\n```\nnpm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive\n```\n### 1.4 验证\n首先启动 Hexo 本地站点，并开启调试模式：\n```\nhexo s --debug\n```\n在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：\n```\nINFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.\n此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。\n```\n### 1.5 更新主题\n今后若主题添加了新功能正是您需要的，您可以直接git pull来更新主题。\n```\ncd themes/butterfly\ngit pull\n```\n\n## 2. 配置\n### 2.1 设置语言\n该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在根_config.yml配置如下：\n```\n// 根 _config.yml\nlanguage: zh-CN\n```\n### 2.2 设置菜单\n```\n// 打开主题找到， themes/butterfly/_config.yml\nmenu:\n  - page: home\n    directory: .\n    icon: fa-home\n  - page: archive\n    directory: archives/\n    icon: fa-archive\n  # - page: about\n  #   directory: about/\n  #   icon: fa-user\n  - page: rss\n    directory: atom.xml\n    icon: fa-rss\n```\n#### 2.2.1 添加about页面\n```\n// 此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：\nhexo new page 'about'\n\n// 打开主题找到， themes/butterfly/_config.yml\n# About page\nabout:\n  photo_url: ## 头像的链接地址 https://avatars0.githubusercontent.com/u/29102045?s=460&v=4\n  items:\n  - label: email\n    url: ## 个人邮箱\n    title: ## 邮箱用户名\n  - label: github\n    url: ## github主页\n    title: ## github用户名\n  - label: weibo\n    url: ## weibo主页\n    title: ## weibo用户名\n# - label: twitter\n#   url: \n#   title:\n# - label: facebook\n#   url:\n#   title:\n```\n\n#### 2.2.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件\n* 在根目录下打开命令行窗口：\n```\nnpm install hexo-generator-feed --save\nnpm install hexo-generator-sitemap --save\nnpm install hexo-generator-baidu-sitemap --save\n```\n\n* 添加主题_config.yml配置：\n```\n//  themes/butterfly/_config.yml \n\nPlugins:\n  hexo-generator-feed\n  hexo-generator-sitemap\n  hexo-generator-baidu-sitemap\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\nsitemap:\n  path: sitemap.xml\nbaidusitemap:\n  path: baidusitemap.xml\n```\n\n### 2.3 添加本地搜索\n安装插件`hexo-generator-json-content`来创建JSON数据文件：\n\n ```\n npm install hexo-generator-json-content@2.2.0 --save\n ```\n\n然后在根_config.yml添加配置：\n```\n// 根_config.yml\n\njsonContent:\n  meta: false\n  pages: false\n  posts:\n    title: true\n    date: true\n    path: true\n    text: true\n    raw: false\n    content: false\n    slug: false\n    updated: false\n    comments: false\n    link: false\n    permalink: false\n    excerpt: false\n    categories: false\n    tags: true\n```\n\n最后在主题themes/butterfly/_config.yml添加配置：\n```\n//  themes/butterfly/_config.yml   \nlocal_search: true\n```\n\n### 2.4 其他配置\n主题themes/butterfly/_config.yml添加其他配置：\n\n```\n//  themes/butterfly/_config.yml  \n// show_category_count——是否显示分类下的文章数。\n// widgets_on_small_screens——是否在小屏显示侧边栏，若true,则侧边栏挂件将显示在底部。\n\nshow_category_count: true \nwidgets_on_small_screens: true\n```","source":"_posts/butterfly.md","raw":"---\ntitle: butterfly博客主题的详细配置\ndate: 2021-03-18 2021-03-18\ntype: 其他\ntags: Hexo\nnote: 修改主题篇 --> 推荐二 --> hexo-theme-butterfly\n---\n\n## 1. 安装\n### 1.1 安装主题\n```\ngit clone https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly\n```\n### 1.2 启用主题\n打开根`_config.yml`配置文件，找到theme字段，将其值改为butterfly(先确认主题文件夹名称是否为butterfly)。\n\n```\n// 根 _config.yml\ntheme: butterfly\n```\n修改后在根目录文件夹下执行以下代码\n\n```\nnpm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive\n```\n### 1.4 验证\n首先启动 Hexo 本地站点，并开启调试模式：\n```\nhexo s --debug\n```\n在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：\n```\nINFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.\n此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。\n```\n### 1.5 更新主题\n今后若主题添加了新功能正是您需要的，您可以直接git pull来更新主题。\n```\ncd themes/butterfly\ngit pull\n```\n\n## 2. 配置\n### 2.1 设置语言\n该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在根_config.yml配置如下：\n```\n// 根 _config.yml\nlanguage: zh-CN\n```\n### 2.2 设置菜单\n```\n// 打开主题找到， themes/butterfly/_config.yml\nmenu:\n  - page: home\n    directory: .\n    icon: fa-home\n  - page: archive\n    directory: archives/\n    icon: fa-archive\n  # - page: about\n  #   directory: about/\n  #   icon: fa-user\n  - page: rss\n    directory: atom.xml\n    icon: fa-rss\n```\n#### 2.2.1 添加about页面\n```\n// 此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：\nhexo new page 'about'\n\n// 打开主题找到， themes/butterfly/_config.yml\n# About page\nabout:\n  photo_url: ## 头像的链接地址 https://avatars0.githubusercontent.com/u/29102045?s=460&v=4\n  items:\n  - label: email\n    url: ## 个人邮箱\n    title: ## 邮箱用户名\n  - label: github\n    url: ## github主页\n    title: ## github用户名\n  - label: weibo\n    url: ## weibo主页\n    title: ## weibo用户名\n# - label: twitter\n#   url: \n#   title:\n# - label: facebook\n#   url:\n#   title:\n```\n\n#### 2.2.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件\n* 在根目录下打开命令行窗口：\n```\nnpm install hexo-generator-feed --save\nnpm install hexo-generator-sitemap --save\nnpm install hexo-generator-baidu-sitemap --save\n```\n\n* 添加主题_config.yml配置：\n```\n//  themes/butterfly/_config.yml \n\nPlugins:\n  hexo-generator-feed\n  hexo-generator-sitemap\n  hexo-generator-baidu-sitemap\nfeed:\n  type: atom\n  path: atom.xml\n  limit: 20\nsitemap:\n  path: sitemap.xml\nbaidusitemap:\n  path: baidusitemap.xml\n```\n\n### 2.3 添加本地搜索\n安装插件`hexo-generator-json-content`来创建JSON数据文件：\n\n ```\n npm install hexo-generator-json-content@2.2.0 --save\n ```\n\n然后在根_config.yml添加配置：\n```\n// 根_config.yml\n\njsonContent:\n  meta: false\n  pages: false\n  posts:\n    title: true\n    date: true\n    path: true\n    text: true\n    raw: false\n    content: false\n    slug: false\n    updated: false\n    comments: false\n    link: false\n    permalink: false\n    excerpt: false\n    categories: false\n    tags: true\n```\n\n最后在主题themes/butterfly/_config.yml添加配置：\n```\n//  themes/butterfly/_config.yml   \nlocal_search: true\n```\n\n### 2.4 其他配置\n主题themes/butterfly/_config.yml添加其他配置：\n\n```\n//  themes/butterfly/_config.yml  \n// show_category_count——是否显示分类下的文章数。\n// widgets_on_small_screens——是否在小屏显示侧边栏，若true,则侧边栏挂件将显示在底部。\n\nshow_category_count: true \nwidgets_on_small_screens: true\n```","slug":"butterfly","published":1,"updated":"2021-07-19T03:22:01.366Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrd8jv180003kwzt3m5n5zy7","content":"<h2 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h2><h3 id=\"1-1-安装主题\"><a href=\"#1-1-安装主题\" class=\"headerlink\" title=\"1.1 安装主题\"></a>1.1 安装主题</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-2-启用主题\"><a href=\"#1-2-启用主题\" class=\"headerlink\" title=\"1.2 启用主题\"></a>1.2 启用主题</h3><p>打开根<code>_config.yml</code>配置文件，找到theme字段，将其值改为butterfly(先确认主题文件夹名称是否为butterfly)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 根 _config.yml</span><br><span class=\"line\">theme: butterfly</span><br></pre></td></tr></table></figure>\n<p>修改后在根目录文件夹下执行以下代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-4-验证\"><a href=\"#1-4-验证\" class=\"headerlink\" title=\"1.4 验证\"></a>1.4 验证</h3><p>首先启动 Hexo 本地站点，并开启调试模式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s --debug</span><br></pre></td></tr></table></figure>\n<p>在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</span><br><span class=\"line\">此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-5-更新主题\"><a href=\"#1-5-更新主题\" class=\"headerlink\" title=\"1.5 更新主题\"></a>1.5 更新主题</h3><p>今后若主题添加了新功能正是您需要的，您可以直接git pull来更新主题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd themes/butterfly</span><br><span class=\"line\">git pull</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2. 配置\"></a>2. 配置</h2><h3 id=\"2-1-设置语言\"><a href=\"#2-1-设置语言\" class=\"headerlink\" title=\"2.1 设置语言\"></a>2.1 设置语言</h3><p>该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在根_config.yml配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 根 _config.yml</span><br><span class=\"line\">language: zh-CN</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-设置菜单\"><a href=\"#2-2-设置菜单\" class=\"headerlink\" title=\"2.2 设置菜单\"></a>2.2 设置菜单</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 打开主题找到， themes/butterfly/_config.yml</span><br><span class=\"line\">menu:</span><br><span class=\"line\">  - page: home</span><br><span class=\"line\">    directory: .</span><br><span class=\"line\">    icon: fa-home</span><br><span class=\"line\">  - page: archive</span><br><span class=\"line\">    directory: archives/</span><br><span class=\"line\">    icon: fa-archive</span><br><span class=\"line\">  # - page: about</span><br><span class=\"line\">  #   directory: about/</span><br><span class=\"line\">  #   icon: fa-user</span><br><span class=\"line\">  - page: rss</span><br><span class=\"line\">    directory: atom.xml</span><br><span class=\"line\">    icon: fa-rss</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2-1-添加about页面\"><a href=\"#2-2-1-添加about页面\" class=\"headerlink\" title=\"2.2.1 添加about页面\"></a>2.2.1 添加about页面</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：</span><br><span class=\"line\">hexo new page &#x27;about&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">// 打开主题找到， themes/butterfly/_config.yml</span><br><span class=\"line\"># About page</span><br><span class=\"line\">about:</span><br><span class=\"line\">  photo_url: ## 头像的链接地址 https://avatars0.githubusercontent.com/u/29102045?s=460&amp;v=4</span><br><span class=\"line\">  items:</span><br><span class=\"line\">  - label: email</span><br><span class=\"line\">    url: ## 个人邮箱</span><br><span class=\"line\">    title: ## 邮箱用户名</span><br><span class=\"line\">  - label: github</span><br><span class=\"line\">    url: ## github主页</span><br><span class=\"line\">    title: ## github用户名</span><br><span class=\"line\">  - label: weibo</span><br><span class=\"line\">    url: ## weibo主页</span><br><span class=\"line\">    title: ## weibo用户名</span><br><span class=\"line\"># - label: twitter</span><br><span class=\"line\">#   url: </span><br><span class=\"line\">#   title:</span><br><span class=\"line\"># - label: facebook</span><br><span class=\"line\">#   url:</span><br><span class=\"line\">#   title:</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-2-安装-RSS-订阅-和-sitemap-网站地图-插件\"><a href=\"#2-2-2-安装-RSS-订阅-和-sitemap-网站地图-插件\" class=\"headerlink\" title=\"2.2.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件\"></a>2.2.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件</h4><ul>\n<li><p>在根目录下打开命令行窗口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-feed --save</span><br><span class=\"line\">npm install hexo-generator-sitemap --save</span><br><span class=\"line\">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure></li>\n<li><p>添加主题_config.yml配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  themes/butterfly/_config.yml </span><br><span class=\"line\"></span><br><span class=\"line\">Plugins:</span><br><span class=\"line\">  hexo-generator-feed</span><br><span class=\"line\">  hexo-generator-sitemap</span><br><span class=\"line\">  hexo-generator-baidu-sitemap</span><br><span class=\"line\">feed:</span><br><span class=\"line\">  type: atom</span><br><span class=\"line\">  path: atom.xml</span><br><span class=\"line\">  limit: 20</span><br><span class=\"line\">sitemap:</span><br><span class=\"line\">  path: sitemap.xml</span><br><span class=\"line\">baidusitemap:</span><br><span class=\"line\">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"2-3-添加本地搜索\"><a href=\"#2-3-添加本地搜索\" class=\"headerlink\" title=\"2.3 添加本地搜索\"></a>2.3 添加本地搜索</h3><p>安装插件<code>hexo-generator-json-content</code>来创建JSON数据文件：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-json-content@2.2.0 --save</span><br></pre></td></tr></table></figure>\n\n<p>然后在根_config.yml添加配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 根_config.yml</span><br><span class=\"line\"></span><br><span class=\"line\">jsonContent:</span><br><span class=\"line\">  meta: false</span><br><span class=\"line\">  pages: false</span><br><span class=\"line\">  posts:</span><br><span class=\"line\">    title: true</span><br><span class=\"line\">    date: true</span><br><span class=\"line\">    path: true</span><br><span class=\"line\">    text: true</span><br><span class=\"line\">    raw: false</span><br><span class=\"line\">    content: false</span><br><span class=\"line\">    slug: false</span><br><span class=\"line\">    updated: false</span><br><span class=\"line\">    comments: false</span><br><span class=\"line\">    link: false</span><br><span class=\"line\">    permalink: false</span><br><span class=\"line\">    excerpt: false</span><br><span class=\"line\">    categories: false</span><br><span class=\"line\">    tags: true</span><br></pre></td></tr></table></figure>\n\n<p>最后在主题themes/butterfly/_config.yml添加配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  themes/butterfly/_config.yml   </span><br><span class=\"line\">local_search: true</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-其他配置\"><a href=\"#2-4-其他配置\" class=\"headerlink\" title=\"2.4 其他配置\"></a>2.4 其他配置</h3><p>主题themes/butterfly/_config.yml添加其他配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  themes/butterfly/_config.yml  </span><br><span class=\"line\">// show_category_count——是否显示分类下的文章数。</span><br><span class=\"line\">// widgets_on_small_screens——是否在小屏显示侧边栏，若true,则侧边栏挂件将显示在底部。</span><br><span class=\"line\"></span><br><span class=\"line\">show_category_count: true </span><br><span class=\"line\">widgets_on_small_screens: true</span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h2><h3 id=\"1-1-安装主题\"><a href=\"#1-1-安装主题\" class=\"headerlink\" title=\"1.1 安装主题\"></a>1.1 安装主题</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-2-启用主题\"><a href=\"#1-2-启用主题\" class=\"headerlink\" title=\"1.2 启用主题\"></a>1.2 启用主题</h3><p>打开根<code>_config.yml</code>配置文件，找到theme字段，将其值改为butterfly(先确认主题文件夹名称是否为butterfly)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 根 _config.yml</span><br><span class=\"line\">theme: butterfly</span><br></pre></td></tr></table></figure>\n<p>修改后在根目录文件夹下执行以下代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-4-验证\"><a href=\"#1-4-验证\" class=\"headerlink\" title=\"1.4 验证\"></a>1.4 验证</h3><p>首先启动 Hexo 本地站点，并开启调试模式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s --debug</span><br></pre></td></tr></table></figure>\n<p>在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</span><br><span class=\"line\">此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。</span><br></pre></td></tr></table></figure>\n<h3 id=\"1-5-更新主题\"><a href=\"#1-5-更新主题\" class=\"headerlink\" title=\"1.5 更新主题\"></a>1.5 更新主题</h3><p>今后若主题添加了新功能正是您需要的，您可以直接git pull来更新主题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd themes/butterfly</span><br><span class=\"line\">git pull</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-配置\"><a href=\"#2-配置\" class=\"headerlink\" title=\"2. 配置\"></a>2. 配置</h2><h3 id=\"2-1-设置语言\"><a href=\"#2-1-设置语言\" class=\"headerlink\" title=\"2.1 设置语言\"></a>2.1 设置语言</h3><p>该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在根_config.yml配置如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 根 _config.yml</span><br><span class=\"line\">language: zh-CN</span><br></pre></td></tr></table></figure>\n<h3 id=\"2-2-设置菜单\"><a href=\"#2-2-设置菜单\" class=\"headerlink\" title=\"2.2 设置菜单\"></a>2.2 设置菜单</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 打开主题找到， themes/butterfly/_config.yml</span><br><span class=\"line\">menu:</span><br><span class=\"line\">  - page: home</span><br><span class=\"line\">    directory: .</span><br><span class=\"line\">    icon: fa-home</span><br><span class=\"line\">  - page: archive</span><br><span class=\"line\">    directory: archives/</span><br><span class=\"line\">    icon: fa-archive</span><br><span class=\"line\">  # - page: about</span><br><span class=\"line\">  #   directory: about/</span><br><span class=\"line\">  #   icon: fa-user</span><br><span class=\"line\">  - page: rss</span><br><span class=\"line\">    directory: atom.xml</span><br><span class=\"line\">    icon: fa-rss</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-2-1-添加about页面\"><a href=\"#2-2-1-添加about页面\" class=\"headerlink\" title=\"2.2.1 添加about页面\"></a>2.2.1 添加about页面</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：</span><br><span class=\"line\">hexo new page &#x27;about&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">// 打开主题找到， themes/butterfly/_config.yml</span><br><span class=\"line\"># About page</span><br><span class=\"line\">about:</span><br><span class=\"line\">  photo_url: ## 头像的链接地址 https://avatars0.githubusercontent.com/u/29102045?s=460&amp;v=4</span><br><span class=\"line\">  items:</span><br><span class=\"line\">  - label: email</span><br><span class=\"line\">    url: ## 个人邮箱</span><br><span class=\"line\">    title: ## 邮箱用户名</span><br><span class=\"line\">  - label: github</span><br><span class=\"line\">    url: ## github主页</span><br><span class=\"line\">    title: ## github用户名</span><br><span class=\"line\">  - label: weibo</span><br><span class=\"line\">    url: ## weibo主页</span><br><span class=\"line\">    title: ## weibo用户名</span><br><span class=\"line\"># - label: twitter</span><br><span class=\"line\">#   url: </span><br><span class=\"line\">#   title:</span><br><span class=\"line\"># - label: facebook</span><br><span class=\"line\">#   url:</span><br><span class=\"line\">#   title:</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-2-2-安装-RSS-订阅-和-sitemap-网站地图-插件\"><a href=\"#2-2-2-安装-RSS-订阅-和-sitemap-网站地图-插件\" class=\"headerlink\" title=\"2.2.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件\"></a>2.2.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件</h4><ul>\n<li><p>在根目录下打开命令行窗口：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-feed --save</span><br><span class=\"line\">npm install hexo-generator-sitemap --save</span><br><span class=\"line\">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure></li>\n<li><p>添加主题_config.yml配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  themes/butterfly/_config.yml </span><br><span class=\"line\"></span><br><span class=\"line\">Plugins:</span><br><span class=\"line\">  hexo-generator-feed</span><br><span class=\"line\">  hexo-generator-sitemap</span><br><span class=\"line\">  hexo-generator-baidu-sitemap</span><br><span class=\"line\">feed:</span><br><span class=\"line\">  type: atom</span><br><span class=\"line\">  path: atom.xml</span><br><span class=\"line\">  limit: 20</span><br><span class=\"line\">sitemap:</span><br><span class=\"line\">  path: sitemap.xml</span><br><span class=\"line\">baidusitemap:</span><br><span class=\"line\">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"2-3-添加本地搜索\"><a href=\"#2-3-添加本地搜索\" class=\"headerlink\" title=\"2.3 添加本地搜索\"></a>2.3 添加本地搜索</h3><p>安装插件<code>hexo-generator-json-content</code>来创建JSON数据文件：</p>\n <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-json-content@2.2.0 --save</span><br></pre></td></tr></table></figure>\n\n<p>然后在根_config.yml添加配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 根_config.yml</span><br><span class=\"line\"></span><br><span class=\"line\">jsonContent:</span><br><span class=\"line\">  meta: false</span><br><span class=\"line\">  pages: false</span><br><span class=\"line\">  posts:</span><br><span class=\"line\">    title: true</span><br><span class=\"line\">    date: true</span><br><span class=\"line\">    path: true</span><br><span class=\"line\">    text: true</span><br><span class=\"line\">    raw: false</span><br><span class=\"line\">    content: false</span><br><span class=\"line\">    slug: false</span><br><span class=\"line\">    updated: false</span><br><span class=\"line\">    comments: false</span><br><span class=\"line\">    link: false</span><br><span class=\"line\">    permalink: false</span><br><span class=\"line\">    excerpt: false</span><br><span class=\"line\">    categories: false</span><br><span class=\"line\">    tags: true</span><br></pre></td></tr></table></figure>\n\n<p>最后在主题themes/butterfly/_config.yml添加配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  themes/butterfly/_config.yml   </span><br><span class=\"line\">local_search: true</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-4-其他配置\"><a href=\"#2-4-其他配置\" class=\"headerlink\" title=\"2.4 其他配置\"></a>2.4 其他配置</h3><p>主题themes/butterfly/_config.yml添加其他配置：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  themes/butterfly/_config.yml  </span><br><span class=\"line\">// show_category_count——是否显示分类下的文章数。</span><br><span class=\"line\">// widgets_on_small_screens——是否在小屏显示侧边栏，若true,则侧边栏挂件将显示在底部。</span><br><span class=\"line\"></span><br><span class=\"line\">show_category_count: true </span><br><span class=\"line\">widgets_on_small_screens: true</span><br></pre></td></tr></table></figure>"},{"title":"vscode-sync-setting","date":"2021-03-18T07:49:01.000Z","type":"其他","note":"如何将不同设备上处的VSCode配置进行统一管理...","_content":"\n## VSCode配置的同步设置，实现不同设备上的统一\n\n### 写在前面\n\n* 准备工作：电脑上需安装VSCode，拥有一个github账户。实现同步的功能主要依赖于VSCode插件`Settings Sync`\n* **Setting Sync 可同步包含的所有扩展和完整的用户文件夹** \n  * 设置文件\n  * 快捷键设置文件\n  * VSCode扩展设置\n  * Launch File\n\n<!--more-->\n### 同步配置\n\n#### 安装 同步插件\"Settings Sync\"\n\n#### 生成token\n\n* 登录Github账户设置，头像 ---> Settings 在左侧（最后一个） Developer settings ---> Personal access tokens；\n\n![图片观看](https://i.loli.net/2018/05/26/5b096f4978275.png)\n\n* 点击按钮 Generate new token 新增一个token\n\n![流程一](https://i.loli.net/2018/05/26/5b096f6c74ee0.png)\n\n![流程二](https://i.loli.net/2018/05/26/5b096f835206e.png)\n\n\n\n![流程三](https://i.loli.net/2018/05/26/5b096f9a9b3de.png)\n\n\n\n**提示**：记住生成的token值，最好找个笔记保存下来 。\n\n\n\n#### 回到VSCode配置将token配置到本地\n\n(Sync: Update / Uplaod Settings) `Shift + Alt + U` 在弹窗里输入你的token， 回车后会生成`syncSummary.txt`文件\n\n![img](https://i.loli.net/2018/05/26/5b096fb7323ae.png)\n\nsyncSummary.txt文件会存储VSCode的设置及所安装的插件列表\n\n此外可以将自己的token分享到自己的团队里面去，这样团队可以共用一套设置。 \n\n#### 同步与下载\n\n* 设置上同步下载设置\n  * `Shift + Alt + U`，同步本地的配置更新到github；\n  *  `Shift + Alt + D` ，在弹窗里输入你的gist值，稍后片刻便可同步成功\n\n* 要重置同步设置，变更其它token\n  * ` Ctrl+P ` 弹出输入>sync，即可重新配置你的其它token来同步\n  \n### 异端设置\n![VSCode同步方案问题一](https://i.loli.net/2018/05/26/5b096fcdb900c.png)\n","source":"_posts/vscode-sync-setting.md","raw":"---\ntitle: vscode-sync-setting\ndate: 2021-03-18 15:49:01\ntype: 其他\ntags: VSCode\nnote: 如何将不同设备上处的VSCode配置进行统一管理...\n---\n\n## VSCode配置的同步设置，实现不同设备上的统一\n\n### 写在前面\n\n* 准备工作：电脑上需安装VSCode，拥有一个github账户。实现同步的功能主要依赖于VSCode插件`Settings Sync`\n* **Setting Sync 可同步包含的所有扩展和完整的用户文件夹** \n  * 设置文件\n  * 快捷键设置文件\n  * VSCode扩展设置\n  * Launch File\n\n<!--more-->\n### 同步配置\n\n#### 安装 同步插件\"Settings Sync\"\n\n#### 生成token\n\n* 登录Github账户设置，头像 ---> Settings 在左侧（最后一个） Developer settings ---> Personal access tokens；\n\n![图片观看](https://i.loli.net/2018/05/26/5b096f4978275.png)\n\n* 点击按钮 Generate new token 新增一个token\n\n![流程一](https://i.loli.net/2018/05/26/5b096f6c74ee0.png)\n\n![流程二](https://i.loli.net/2018/05/26/5b096f835206e.png)\n\n\n\n![流程三](https://i.loli.net/2018/05/26/5b096f9a9b3de.png)\n\n\n\n**提示**：记住生成的token值，最好找个笔记保存下来 。\n\n\n\n#### 回到VSCode配置将token配置到本地\n\n(Sync: Update / Uplaod Settings) `Shift + Alt + U` 在弹窗里输入你的token， 回车后会生成`syncSummary.txt`文件\n\n![img](https://i.loli.net/2018/05/26/5b096fb7323ae.png)\n\nsyncSummary.txt文件会存储VSCode的设置及所安装的插件列表\n\n此外可以将自己的token分享到自己的团队里面去，这样团队可以共用一套设置。 \n\n#### 同步与下载\n\n* 设置上同步下载设置\n  * `Shift + Alt + U`，同步本地的配置更新到github；\n  *  `Shift + Alt + D` ，在弹窗里输入你的gist值，稍后片刻便可同步成功\n\n* 要重置同步设置，变更其它token\n  * ` Ctrl+P ` 弹出输入>sync，即可重新配置你的其它token来同步\n  \n### 异端设置\n![VSCode同步方案问题一](https://i.loli.net/2018/05/26/5b096fcdb900c.png)\n","slug":"vscode-sync-setting","published":1,"updated":"2021-07-19T05:52:19.386Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrd8jv180004kwzt0tdm78ix","content":"<h2 id=\"VSCode配置的同步设置，实现不同设备上的统一\"><a href=\"#VSCode配置的同步设置，实现不同设备上的统一\" class=\"headerlink\" title=\"VSCode配置的同步设置，实现不同设备上的统一\"></a>VSCode配置的同步设置，实现不同设备上的统一</h2><h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h3><ul>\n<li>准备工作：电脑上需安装VSCode，拥有一个github账户。实现同步的功能主要依赖于VSCode插件<code>Settings Sync</code></li>\n<li><strong>Setting Sync 可同步包含的所有扩展和完整的用户文件夹</strong> <ul>\n<li>设置文件</li>\n<li>快捷键设置文件</li>\n<li>VSCode扩展设置</li>\n<li>Launch File</li>\n</ul>\n</li>\n</ul>\n<span id=\"more\"></span>\n<h3 id=\"同步配置\"><a href=\"#同步配置\" class=\"headerlink\" title=\"同步配置\"></a>同步配置</h3><h4 id=\"安装-同步插件”Settings-Sync”\"><a href=\"#安装-同步插件”Settings-Sync”\" class=\"headerlink\" title=\"安装 同步插件”Settings Sync”\"></a>安装 同步插件”Settings Sync”</h4><h4 id=\"生成token\"><a href=\"#生成token\" class=\"headerlink\" title=\"生成token\"></a>生成token</h4><ul>\n<li>登录Github账户设置，头像 —&gt; Settings 在左侧（最后一个） Developer settings —&gt; Personal access tokens；</li>\n</ul>\n<p><img src=\"https://i.loli.net/2018/05/26/5b096f4978275.png\" alt=\"图片观看\"></p>\n<ul>\n<li>点击按钮 Generate new token 新增一个token</li>\n</ul>\n<p><img src=\"https://i.loli.net/2018/05/26/5b096f6c74ee0.png\" alt=\"流程一\"></p>\n<p><img src=\"https://i.loli.net/2018/05/26/5b096f835206e.png\" alt=\"流程二\"></p>\n<p><img src=\"https://i.loli.net/2018/05/26/5b096f9a9b3de.png\" alt=\"流程三\"></p>\n<p><strong>提示</strong>：记住生成的token值，最好找个笔记保存下来 。</p>\n<h4 id=\"回到VSCode配置将token配置到本地\"><a href=\"#回到VSCode配置将token配置到本地\" class=\"headerlink\" title=\"回到VSCode配置将token配置到本地\"></a>回到VSCode配置将token配置到本地</h4><p>(Sync: Update / Uplaod Settings) <code>Shift + Alt + U</code> 在弹窗里输入你的token， 回车后会生成<code>syncSummary.txt</code>文件</p>\n<p><img src=\"https://i.loli.net/2018/05/26/5b096fb7323ae.png\" alt=\"img\"></p>\n<p>syncSummary.txt文件会存储VSCode的设置及所安装的插件列表</p>\n<p>此外可以将自己的token分享到自己的团队里面去，这样团队可以共用一套设置。 </p>\n<h4 id=\"同步与下载\"><a href=\"#同步与下载\" class=\"headerlink\" title=\"同步与下载\"></a>同步与下载</h4><ul>\n<li><p>设置上同步下载设置</p>\n<ul>\n<li><code>Shift + Alt + U</code>，同步本地的配置更新到github；</li>\n<li> <code>Shift + Alt + D</code> ，在弹窗里输入你的gist值，稍后片刻便可同步成功</li>\n</ul>\n</li>\n<li><p>要重置同步设置，变更其它token</p>\n<ul>\n<li><code>Ctrl+P</code> 弹出输入&gt;sync，即可重新配置你的其它token来同步</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"异端设置\"><a href=\"#异端设置\" class=\"headerlink\" title=\"异端设置\"></a>异端设置</h3><p><img src=\"https://i.loli.net/2018/05/26/5b096fcdb900c.png\" alt=\"VSCode同步方案问题一\"></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"<h2 id=\"VSCode配置的同步设置，实现不同设备上的统一\"><a href=\"#VSCode配置的同步设置，实现不同设备上的统一\" class=\"headerlink\" title=\"VSCode配置的同步设置，实现不同设备上的统一\"></a>VSCode配置的同步设置，实现不同设备上的统一</h2><h3 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h3><ul>\n<li>准备工作：电脑上需安装VSCode，拥有一个github账户。实现同步的功能主要依赖于VSCode插件<code>Settings Sync</code></li>\n<li><strong>Setting Sync 可同步包含的所有扩展和完整的用户文件夹</strong> <ul>\n<li>设置文件</li>\n<li>快捷键设置文件</li>\n<li>VSCode扩展设置</li>\n<li>Launch File</li>\n</ul>\n</li>\n</ul>","more":"<h3 id=\"同步配置\"><a href=\"#同步配置\" class=\"headerlink\" title=\"同步配置\"></a>同步配置</h3><h4 id=\"安装-同步插件”Settings-Sync”\"><a href=\"#安装-同步插件”Settings-Sync”\" class=\"headerlink\" title=\"安装 同步插件”Settings Sync”\"></a>安装 同步插件”Settings Sync”</h4><h4 id=\"生成token\"><a href=\"#生成token\" class=\"headerlink\" title=\"生成token\"></a>生成token</h4><ul>\n<li>登录Github账户设置，头像 —&gt; Settings 在左侧（最后一个） Developer settings —&gt; Personal access tokens；</li>\n</ul>\n<p><img src=\"https://i.loli.net/2018/05/26/5b096f4978275.png\" alt=\"图片观看\"></p>\n<ul>\n<li>点击按钮 Generate new token 新增一个token</li>\n</ul>\n<p><img src=\"https://i.loli.net/2018/05/26/5b096f6c74ee0.png\" alt=\"流程一\"></p>\n<p><img src=\"https://i.loli.net/2018/05/26/5b096f835206e.png\" alt=\"流程二\"></p>\n<p><img src=\"https://i.loli.net/2018/05/26/5b096f9a9b3de.png\" alt=\"流程三\"></p>\n<p><strong>提示</strong>：记住生成的token值，最好找个笔记保存下来 。</p>\n<h4 id=\"回到VSCode配置将token配置到本地\"><a href=\"#回到VSCode配置将token配置到本地\" class=\"headerlink\" title=\"回到VSCode配置将token配置到本地\"></a>回到VSCode配置将token配置到本地</h4><p>(Sync: Update / Uplaod Settings) <code>Shift + Alt + U</code> 在弹窗里输入你的token， 回车后会生成<code>syncSummary.txt</code>文件</p>\n<p><img src=\"https://i.loli.net/2018/05/26/5b096fb7323ae.png\" alt=\"img\"></p>\n<p>syncSummary.txt文件会存储VSCode的设置及所安装的插件列表</p>\n<p>此外可以将自己的token分享到自己的团队里面去，这样团队可以共用一套设置。 </p>\n<h4 id=\"同步与下载\"><a href=\"#同步与下载\" class=\"headerlink\" title=\"同步与下载\"></a>同步与下载</h4><ul>\n<li><p>设置上同步下载设置</p>\n<ul>\n<li><code>Shift + Alt + U</code>，同步本地的配置更新到github；</li>\n<li> <code>Shift + Alt + D</code> ，在弹窗里输入你的gist值，稍后片刻便可同步成功</li>\n</ul>\n</li>\n<li><p>要重置同步设置，变更其它token</p>\n<ul>\n<li><code>Ctrl+P</code> 弹出输入&gt;sync，即可重新配置你的其它token来同步</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"异端设置\"><a href=\"#异端设置\" class=\"headerlink\" title=\"异端设置\"></a>异端设置</h3><p><img src=\"https://i.loli.net/2018/05/26/5b096fcdb900c.png\" alt=\"VSCode同步方案问题一\"></p>"},{"title":"Koa2入门小基础","date":"2021-03-18T00:00:00.000Z","type":"技术","sidebarDepth":3,"sidebar":"auto","note":"Koa2是现在最流行的基于Node.js平台的web开发框架，它很小，但扩展性很强。Koa给人一种干净利落的感觉，体积小、编程方式干净。","_content":"\n# Koa2入门小基础\n\n学习指导：[挑战全栈 Koa2免费视频教程 (共13集)](http://www.jspang.com/posts/2017/11/13/koa2.html)\n\nKoa2是现在最流行的基于Node.js平台的web开发框架，它很小，但扩展性很强。Koa给人一种干净利落的感觉，体积小、编程方式干净。\n\n> 使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。一个Koa应用就是一个对象，包含了一个middleware数组，这个数组由一组Generator函数组成。这些函数负责对HTTP请求进行各种加工，比如生成缓存、指定代理、请求重定向等等。这些中间件函数基于 request 请求以一个类似于栈的结构组成并依次执行。\n\n## 第01节：Koa开发环境搭建\n\n作Koa2的开发，它要求Node.js版本高于V7.6。\n\n> ::: warning 注意事项\n> 请确保你的 Node.js 版本 >= 7.6。\n> :::\n\n### 搭建环境\n\n```bash\ncd code  //进入code文件夹\nmkdir koa2-demo //创建koa2-demo文件夹\ncd koa2-demo  //进入koa2-demo文件夹\n\nnpm init -y // 初始化生产package.json 文件\nnpm install --save koa // 安装koa\n```\n\n### 与君初相识\n\n```javascript\n// 根目录下创建 index.js\n\nconst Koa = require('koa')\n\nconst app = new Koa()\napp.use(async (ctx) => {\n    ctx.body = 'Hello Koa2'\n})\n\napp.listen(3000)\n\nconsole.log('[demo] start-quick is starting at port 3000')\n\n// 运行 node index.js\n// 浏览器中输入：http://127.0.0.1:3000 就可以看到结果了\n```\n\n## 第02节：async/await的使用方法\n\n### 什么是async和await\n\nasync是异步的简写，而await可以堪称async wait的简写。\n\n明白了两个单词，就很好理解了async是声明一个方法是异步的，await是等待异步方法完成。\n\n注意的是await必须在async方法中才可以使用因为await访问本身就会造成程序停止堵塞，所以必须在异步方法中才可以使用。\n\n* **async到底起什么作用**\n\n  ```javascript\n  // async是让方法变成异步，这个很好理解，关键是他的返回值是什么？我们得到后如何处理？\n  \n  // ./demo01.js\n  async function testAsync() {\n      return 'Hello Async'\n  }\n  const result = testAsync()\n  console.log(result)  // Promise { 'Hello Async' }\n  \n  // 输出了Promise { ‘Hello Async’ }，这时候会发现它返回的是Promise\n  ```\n\n* **await在等什么？**\n\n  await一般在等待async方法执行完毕，但是其实await等待的只是一个表达式，这个表达式在官方文档里说的是Promise对象，可是它也可以接受普通值。\n  \n  **await必须在async方法中才可以使用**\n  \n  **await接收Promise对象，也可以接收普通值**\n  \n  ```javascript\n  // ./demo02.js\n  \n  function getSomething(){\n      return 'something'\n  }\n  \n  async function testAsync() {\n      return 'Hello Async'\n  }\n  \n  async function test() {\n      const res1 = await getSomething()\n      const res2 = await testAsync()\n      console.log(res1, res2)\n  }\n  \n  // 执行\n  test()  // something Hello Async\n  ```\n\n### async/await同时使用\n\n```javascript\n// ./demo03.js\n\nfunction takeLongTime(){\n    return new Promise(resolve => {\n        setTimeout(() => {\n            resolve('long_time_value')\n        }, 2000);\n    })\n}\n\nasync function test() {\n    const res = await takeLongTime()\n    console.log(res)\n}\n\ntest()\n\n// 等待2秒钟， 输出 long_time_value\n```\n\n## 第03节：Get请求的接收\n\n* 在koa2中GET请求通过request接收，但是接受的方法有两种：query和querystring。\n  * query：返回的是格式化好的参数对象。\n  * querystring：返回的是请求字符串。\n  \n* 从 `ctx.request` 中获取Get请求\n\n    ```javascript\n    /**\n     *  在koa2中GET请求通过request接收，但是接受的方法有两种：query和querystring。\n     *  query：返回的是格式化好的参数对象。\n     *  querystring：返回的是请求字符串。\n     */\n\n    // ./ get_demo.js\n\n    const Koa = require('koa')\n    const app = new Koa()\n    app.use(async (ctx) => {\n        // 上下文得到url对象\n        let url = ctx.url\n        let request = ctx.request\n        let req_query = request.query\n        let req_querystring = request.querystring\n        ctx.body = {\n            url,\n            req_query,\n            req_querystring\n        }\n    })\n\n    app.listen(3000, () => {\n        console.log('[demo] server is starting at port 3000')\n    })\n\n    // 启动一切正常可在浏览器中使用http://127.0.0.1:3000?user=jspang&age=18来进行访问\n    // {\"url\":\"/?user=jspang&age=18\",\"req_query\":{\"user\":\"jspang\",\"age\":\"18\"},\"req_querystring\":\"user=jspang&age=18\"}\n    // query是一个对象，而querystring就是一个普通的字符串。\n    ```\n\n* 从`ctx`中得到GET请求。`ctx`中也分为query和querystring\n\n  ```javascript\n  // 从ctx中得到GET请求。ctx中也分为query和querystring\n  \n  const Koa = require('koa')\n  const app = new Koa()\n  app.use(async (ctx) => {\n      //从request中获取GET请求\n      // 上下文得到url对象\n      let url = ctx.url\n      let request = ctx.request\n      let req_query = request.query\n      let req_querystring = request.querystring\n  \n      //从上下文中直接获取\n      let ctx_query = ctx.query\n      let ctx_querystring = ctx.querystring\n\n      ctx.body = {\n          url,\n          req_query,\n          req_querystring,\n          ctx_query,\n          ctx_querystring\n      }\n  })\n  \n  app.listen(3000, () => {\n      console.log('[demo] server is starting at port 3000')\n  })\n  \n  /**\n   // 20190813114559\n  // http://127.0.0.1:3000/?user=jspang&age=18\n  \n  {\n    \"url\": \"/?user=jspang&age=18\",\n    \"req_query\": {\n      \"user\": \"jspang\",\n      \"age\": \"18\"\n    },\n    \"req_querystring\": \"user=jspang&age=18\",\n    \"ctx_query\": {\n      \"user\": \"jspang\",\n      \"age\": \"18\"\n    },\n    \"ctx_querystring\": \"user=jspang&age=18\"\n  }\n  \n  * */\n  ```\n\n* 总结：获得GET请求的方式有两种，一种是从request中获得，一种是一直从上下文中获得。\n\n* 获得的格式也有两种：query和querystring。\n\n## 第04节：POST请求如何接收（1）\n\n* 对于POST请求的处理，Koa2没有封装方便的获取参数的方法，需要通过解析上下文context中的原生node.js请求对象req来获取。\n\n* **获取Post请求的步骤：**\n\n1. 解析上下文ctx中的原生nodex.js对象req。\n2. 将POST表单数据解析成query string-字符串.(例如:user=jspang&age=18)\n3. 将字符串转换成JSON格式。\n\n* **ctx.request和ctx.req的区别**\n\n1. ctx.request: 是Koa2中context经过封装的请求对象，它用起来更直观和简单。\n2. ctx.req: 是context提供的node.js原生HTTP请求对象。这个虽然不那么直观，但是可以得到更多的内容，适合我们深度编程。\n\n* **ctx.method 得到请求类型**\n\n  ```javascript\n  // ctx.method 得到请求类型\n  \n  // Koa2中提供了ctx.method属性，可以轻松的得到请求的类型，\n  // 然后根据请求类型编写不同的相应方法\n  \n  // ./post_demo01.js\n  \n  const Koa = require('koa')\n  const app = new Koa()\n  app.use(async (ctx) => {\n    // 当请求是GET请求，显示表单让用户填写\n    if (ctx.url === '/' && ctx.method === 'GET') {\n      let html = `\n        <h1>Koa2 request post demo</h1>\n        <form method='POST' action='/'>\n        <p>userName</p>\n          <input name=\"userName\"/> <br/>\n          <p>age</p>\n          <input name=\"age\"/> <br/>\n          <p>webSite</p>\n          <input name='webSite'/><br/>\n          <button type=\"submit\">submit</button>\n        </form>\n      `\n      ctx.body = html\n    } else if (ctx.url === '/' && ctx.method === 'POST') {  // 当请求时POST请求时\n      ctx.body = '接收到请求'\n    } else {    // 其他请求显示404报错\n      ctx.body = '<h1>404 page!</h1>'\n    }\n  })\n  \n  app.listen(3000, () => {\n      console.log('[demo] server is starting at port 3000')\n  })\n  \n  /**\n  浏览器中输入http://127.0.0.1:3000进行查看，\n    第一次进入时给我们展现的是一个表单页面，\n    我们点击提交后可以看到服务器接收到了我们的信息，但我们并没有做出任何处理。\n    当我们下输入一个地址时，它会提示404错误。\n  * */\n  \n  // **总结：**从理论上讲解了如何获取POST请求参数\n  ```\n\n\n\n## 第05节：POST请求如何接收（2）\n\n* **解析Node原生POST参数**\n\n  ```javascript\n  // ./post_demo2.js\n  \n  // 解析Node原生POST参数\n  // 声明一个方法，然后用Promise对象进行解析。这里我们使用了ctx.req.on来接收事件\n  function parsePostData(ctx) {\n    return new Promise((resolve, reject) => {\n      try {\n        let postdata = ''\n        ctx.req.on('data', (data) => {\n          postdata += data\n        })\n        ctx.req.addListener('end', function () {\n          resolve(postdata)\n        })\n      } catch{\n        reject(error)\n      }\n    })\n  }\n  ```\n\n* 修改在上节课接收POST请求的处理方法里，修改代码如下\n\n  ```javascript\n  // ctx.body = '接收到POST请求'\n  let postdata = await parsePostData(ctx)  // userName=jspang&age=123&webSite=www.douban.com\n  ctx.body = postdata\n  \n  // 页面就输出刚才填的表单  userName=jspang&age=123&webSite=www.douban.com\n  ```\n\n* **POST字符串解析JSON对象**\n\n  ```javascript\n  // ./post_demo2.js\n  \n  // POST字符串解析JSON对象\n  // 字符串封装JSON兑现对象的方法\n  // userName=jspang&age=123&webSite=www.douban.com\n  function parseQueryStr(queryStr) {\n    let queryData = {}\n    // split() 方法使用指定的分隔符字符串将一个String对象分割成字符串数组，\n    // 以将字符串分隔为子字符串，以确定每个拆分的位置。 \n    let queryStrList = queryStr.split('&')\n    // console.log(queryStrList)\n    // entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对\n    for (let [index, queryStrItem] of queryStrList.entries()) {\n      let itemList = queryStrItem.split('=')\n      // console.log(itemList)\n      queryData[itemList[0]] = itemList[1]\n    }\n    return queryData\n  }\n  \n  \n  // 在上述解析Node原生POST参数中修改\n  ctx.req.addListener('end', function () {\n      // resolve(postdata)\n      let parseData = parseQueryStr(postdata)\n      resolve(parseData)\n  })\n  \n  /**\n  使用for…of 循环\n  var arr = [\"a\", \"b\", \"c\"];\n  var iterator = arr.entries();\n  \n  for (let e of iterator) {\n    console.log(e);\n  }\n  \n  // [0, \"a\"] \n  // [1, \"b\"] \n  // [2, \"c\"]\n  */\n  \n  // node运行，浏览器http://127.0.0.1:3000，先填写表单，然后页面就会返回\n  /*\n  {\n    \"userName\": \"jspang\",\n    \"age\": \"123\",\n    \"webSite\": \"www.douban.com\"\n  }\n  */\n  ```\n\n* 完整代码见`post_demo2.js`\n\n## [扩展]Array/entries方法精讲\n\n* 参考：[Array/entries](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/entries)\n\n* `**entries()**` 方法返回一个新的**Array Iterator**对象，该对象包含数组中每个索引的键/值对。\n\n* > arr.entries()\n\n  返回值是 一个新的 [`Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array) 迭代器对象。[Array Iterator](http://www.ecma-international.org/ecma-262/6.0/#sec-createarrayiterator)是对象，它的原型（__proto__:Array Iterator）上有一个[next](http://www.ecma-international.org/ecma-262/6.0/#sec-%arrayiteratorprototype%.next)方法，可用用于遍历迭代器取得原数组的[key,value]。\n\n* `Array Iterator`\n\n  ```javascript\n  var arr = [\"a\", \"b\", \"c\"];\n  var iterator = arr.entries();\n  console.log(iterator);\n  \n  /*Array Iterator {}\n           __proto__:Array Iterator\n           next:ƒ next()\n           Symbol(Symbol.toStringTag):\"Array Iterator\"\n           __proto__:Object\n  */\n  ```\n\n* `iterator.next()`\n\n  ```javascript\n  var arr = [\"a\", \"b\", \"c\"]; \n  var iterator = arr.entries();\n  console.log(iterator.next());\n  \n  /*{value: Array(2), done: false}\n            done:false\n            value:(2) [0, \"a\"]\n             __proto__: Object\n  */\n  // iterator.next()返回一个对象，对于有元素的数组，\n  // 是next{ value: Array(2), done: false }；\n  // next.done 用于指示迭代器是否完成：在每次迭代时进行更新而且都是false，\n  // 直到迭代器结束done才是true。\n  // next.value是一个[\"key\",\"value\"]的数组，是返回的迭代器中的元素值。\n  ```\n\n* `iterator.next方法运行`\n\n  ```javascript\n  var arr = [\"a\", \"b\", \"c\"];\n  var iter = arr.entries();\n  var a = [];\n  \n  // for(var i=0; i< arr.length; i++){   // 实际使用的是这个 \n  for(var i=0; i< arr.length+1; i++){    // 注意，是length+1，比数组的长度大\n      var tem = iter.next();             // 每次迭代时更新next\n      console.log(tem.done);             // 这里可以看到更新后的done都是false\n      if(tem.done !== true){             // 遍历迭代器结束done才是true\n          console.log(tem.value);\n          a[i]=tem.value;\n      }\n  }\n\n  console.log(a);                         // 遍历完毕，输出next.value的数组\n  ```\n\n* `二维数组按行排序`\n\n  ```javascript\n  function sortArr(arr) {\n      var goNext = true;\n      var entries = arr.entries();\n      while (goNext) {\n          var result = entries.next();\n          if (result.done !== true) {\n              result.value[1].sort((a, b) => a - b);\n              goNext = true;\n          } else {\n              goNext = false;\n          }\n      }\n      return arr;\n  }\n  \n  var arr = [[1,34],[456,2,3,44,234],[4567,1,4,5,6],[34,78,23,1]];\n  sortArr(arr);\n  \n  /*(4) [Array(2), Array(5), Array(5), Array(4)]\n      0:(2) [1, 34]\n      1:(5) [2, 3, 44, 234, 456]\n      2:(5) [1, 4, 5, 6, 4567]\n      3:(4) [1, 23, 34, 78]\n      length:4\n      __proto__:Array(0)\n  */\n  ```\n\n* `使用for…of 循环`\n\n  ```javascript\n  var arr = [\"a\", \"b\", \"c\"];\n  var iterator = arr.entries();\n  // undefined\n  \n  for (let e of iterator) {\n      console.log(e);\n  }\n  \n  // [0, \"a\"]\n  // [1, \"b\"]\n  // [2, \"c\"]\n  ```\n\n## 第06节：koa-bodyparser中间件\n\n对于POST请求的处理，koa-bodyparser中间件可以把koa2上下文的formData数据解析到ctx.request.body中。\n\n* **安装中间件**\n\n  ```bash\n  # 使用npm进行安装，需要注意的是我们这里要用–save，因为它在生产环境中需要使用。\n  \n  npm install --save koa-bodyparser@3\n  ```\n\n* **引入使用**\n\n  安装完成后，需要在代码中引入并使用。我们在代码顶部用require进行引入。\n  \n  ```javascript\n  const bodyParser = require('koa-bodyparser')\n  ```\n  \n  然后进行使用，如果不使用是没办法调用的，使用代码如下。\n  \n  ```javascript\n  app.use(bodyParser())\n  ```\n  \n  在代码中使用后，直接可以用`ctx.request.body`进行获取POST请求参数，中间件自动给我们作了解析。\n  \n* 用例：\n\n  ```javascript\n  // Post请求解析中间件   koa-bodyparser\n  \n  // ./bodyparser_demo.js\n  \n  const Koa = require('koa')\n  const bodyParser = require('koa-bodyparser')\n  const app = new Koa()\n  app.use(bodyParser())\n  \n  app.use(async (ctx) => {\n    // 当请求是GET请求，显示表单让用户填写\n    if (ctx.url === '/' && ctx.method === 'GET') {\n      let html = `\n        <h1>Koa2 request post demo</h1>\n        <form method='POST' action='/'>\n        <p>userName</p>\n          <input name=\"userName\"/> <br/>\n          <p>age</p>\n          <input name=\"age\"/> <br/>\n          <p>webSite</p>\n          <input name='webSite'/><br/>\n          <button type=\"submit\">submit</button>\n        </form>\n      `\n      ctx.body = html\n    } else if (ctx.url === '/' && ctx.method === 'POST') {  // 当请求时POST请求时\n      // ctx.body = '接收到POST请求'\n      let postData= ctx.request.body\n      ctx.body = postData\n    } else {    // 其他请求显示404报错\n      ctx.body = '<h1>404 page!</h1>'\n    }\n  })\n  \n  app.listen(3000, () => {\n      console.log('[demo] server is starting at port 3000')\n  })\n  ```\n\n## 第07节：Koa2原生路由实现\n\n* `ctx.request.url`\n\n  ```javascript\n  // ctx.request.url\n  // 地址栏输入的路径，然后根据路径的不同进行跳转\n  \n  const Koa = require('koa')\n  const app = new Koa()\n  app.use(async (ctx) => {\n    let url = ctx.request.url\n    ctx.body = url\n  })\n  \n  app.listen(3000, () => {\n      console.log('[demo] server is starting at port 3000')\n  })\n  \n  // 访问http://127.0.0.1:3000/jspang/18 页面会输出/jspang/18\n  ```\n\n* **Koa2原生路由实现**\n\n  原生路由的实现需要引入fs模块来读取文件。然后再根据路由的路径去读取，最后返回给页面，进行渲染。\n\n  ```javascript\n  // Koa2原生路由实现\n  \n  // ctx.request.url\n  // 地址栏输入的路径，然后根据路径的不同进行跳转\n  \n  function render(page) {\n    return new Promise((resolve, reject) => {\n      let pageUrl = `./page/${page}`\n      // 获取文件地址 读取文件\n      fs.readFile(pageUrl, \"binary\", (error, data) => {\n        if (error) {\n          reject(error)\n        } else {\n          resolve(data)\n        }\n      })\n    })\n  }\n  \n  async function route(url) {\n    let page = '404.html'\n    switch (url) {\n      case '/':\n        page = 'index.html'\n        break\n      case '/index':\n        page = 'index.html'\n        break\n      case '/todo':\n        page = 'todo.html'\n        break\n      case '/404':\n        page = '404.html'\n        break\n      default:\n        break\n    }\n  \n    let html = await render(page)\n    return html\n  }\n  \n  const Koa = require('koa')\n  const app = new Koa()\n  const fs = require('fs')\n  \n  app.use(async (ctx) => {\n    let url = ctx.request.url\n    let html = await route(url)\n    ctx.body = html\n  })\n  \n  app.listen(3000, () => {\n    console.log('[demo] server is starting at port 3000')\n  })\n  ```\n\n## 第08节：Koa-router中间件（1）入门\n\n安装koa-router中间件\n\n```bash\n# 安装koa-router中间件\n\nnpm install --save koa-router\n```\n\n基础案例\n\n```javascript\n// Koa-router\n\n// ./koa-router1.js\n\nconst Koa = require('koa')\nconst Router = require('koa-router')\n\nconst app = new Koa()\nconst router = new Router()\n\nrouter\n  .get('/', (ctx, next) => {\n    ctx.body = 'Hello Koa-router'\n  })\n  .get('/todo', (ctx, next) => {   // 路由多页面配置\n    ctx.body = 'Todo page!'\n  })\n\n// 挂载路由\napp.use(router.routes())\n  .use(router.allowedMethods())\n\napp.listen(3000, () => {\n  console.log('[demo] server is starting at port 3000')\n})\n```\n\n\n\n## 第09节：Koa-router中间件（2）层级\n\n* **设置前缀**\n\n  有时候我们想把所有的路径前面都再加入一个级别，比如原来我们访问的路径是`http://127.0.0.1:3000/todo`，现在我们希望在所有的路径前面都加上一个jspang层级，把路径变成`http://127.0.0.1:3000/jspang/todo.`这时候就可以使用层级来完成这个功能。路由在创建的时候是可以指定一个前缀的，这个前缀会被至于路由的最顶层，也就是说，这个路由的所有请求都是相对于这个前缀的.\n\n  ```javascript\n  const router = new Router({\n      prefix:'/jspang'\n  })\n  ```\n\n* 设置层级\n\n  设置前缀一般都是全局的，并不能实现路由的层级，如果你想为单个页面设置层级，也是很简单的。只要在use时使用路径就可以了。\n\n  例如这种写法装载路由层级，这里的router相当于父级：`router.use(‘/page’, page.routes(), page.allowedMethods())`。\n\n  通过这种写法的好处是并不是全局的，我们可以给不同的路由加层级。\n\n  ```javascript\n  // Koa-router 层级\n  \n  // ./koa-router2.js\n  \n  const Koa = require('koa')\n  const Router = require('koa-router')\n  \n  const app = new Koa()\n  // const router = new Router({\n  //   // prefix: '/jspang'  // 设置前缀\n  // })\n  \n  // 设置路由层级\n  let home = new Router()\n  home\n    .get('/jspang', async (ctx, next) => {\n      ctx.body = 'Home jspang'\n    })\n    .get('/todo', async (ctx, next) => {   // 路由多页面配置\n      ctx.body = 'Home Todo'\n    })\n  \n  let page = new Router()\n  page\n    .get('/jspang',(ctx, next) => {  // async 异步不异步都可以\n      ctx.body = 'Page jspang'\n    })\n    .get('/todo',(ctx, next) => {   // 路由多页面配置\n      ctx.body = 'Page Todo'\n    })\n  \n  // 装载所有子路由  router.use(‘/page’, page.routes(), page.allowedMethods())\n  // 设置父路由\n  let router = new Router()\n  router.use('/home', home.routes(), home.allowedMethods())\n  router.use('/page', page.routes(), page.allowedMethods())\n  \n  // 挂载路由中间件\n  app.use(router.routes())\n    .use(router.allowedMethods())\n  \n  app.listen(3000, () => {\n    console.log('[demo] server is starting at port 3000')\n  })\n  ```\n\n## 第10节：Koa-router中间件（3）参数\n\n* 获取传递参数 `ctx.query来进行接收`\n\n  ```javascript\n  // Koa-router 参数\n  \n  // ./koa-router3.js\n  \n  const Koa = require('koa')\n  const Router = require('koa-router')\n  \n  const app = new Koa()\n  const router = new Router()\n  \n  router\n    .get('/', (ctx, next) => {\n      // 获取 get 请求参数\n      ctx.body = ctx.query\n    })\n  \n  // 挂载路由中间件\n  app.use(router.routes())\n    .use(router.allowedMethods())\n  \n  app.listen(3000, () => {\n    console.log('[demo] server is starting at port 3000')\n  })\n  \n  // 地址栏输出 http://127.0.0.1:3000/?user=jspang&age=18\n  /*\n  {\n    \"user\": \"jspang\",\n    \"age\": \"18\"\n  }\n  */\n  ```\n\n## 第11节：Koa2中使用cookie\n\n* `ctx.cookies.get(name,[optins])`: 读取上下文请求中的cookie。\n* `ctx.cookies.set(name,value,[options])`：在上下文中写入cookie\n\n* **写入`Cookies`**\n\n  ```javascript\n  ctx.cookies.set('name', 'jspang')\n  ```\n\n* **Cookie选项**\n  * 比如我们要存储用户名，保留用户登录状态时，你可以选择7天内不用登录，也可以选择30天内不用登录。这就需要在写入是配置一些选项：\n  * `domain`：写入cookie所在的域名\n  * `path`：写入cookie所在的路径\n  * `maxAge`：Cookie最大有效时长\n  * `expires`：cookie失效时间\n  * `httpOnly`:是否只用http请求中获得\n  * `overwirte`：是否允许重写\n\n* **读取`cookies`**\n\n  ```javascript\n  ctx.cookies.get('name')\n  ```\n\n## 第12节：Koa2的模板初识（ejs）\n\n开发中不可能把所有的html代码全部卸载JS里，这显然不现实，也没办法完成大型web开发。必须借用模板机制来帮助我们开发，这节课我们就简单了解一下Koa2的模板机制，koa2的目标机制要依靠中间件来完成开发。\n\n* **安装中间件**\n\n  ```bash\n  # 安装中间件\n  \n  npm install --save koa-views\n  ```\n\n* **安装ejs模板引擎**\n\n  ```bash\n  # 安装ejs模板引擎\n  \n  npm install --save ejs\n  ```\n\n* **编写模板**\n\n  ```javascript\n  // 为了模板统一管理，我们新建一个view的文件夹，并在它下面新建index.ejs文件。\n  \n  // ./views/index.ejs\n  \n  <!DOCTYPE html>\n  <html lang=\"en\">\n  <head>\n      <meta charset=\"UTF-8\">\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n      <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n      <title><%= title%></title>\n  </head>\n  <body>\n      <h1><%= title %></h1>\n      <p>EJS Welcome to <%= title %></p>\n  </body>\n  </html>\n  ```\n\n* **编写Koa文件**\n\n  ```javascript\n  // ejs模板\n  // ./ejs_demo.js\n  \n  const Koa = require('koa')\n  const views = require('koa-views')\n  const path = require('path')\n  const app = new Koa()\n  \n  // 加载模板引擎\n  app.use(views(path.join(__dirname, './views'), {\n    extension: 'ejs'\n  }))\n  \n  app.use(async (ctx) => {\n    let title = 'HELLO Koa2'\n    await ctx.render('index', {\n      title\n    })\n  })\n  \n  \n  app.listen(3000, () => {\n    console.log('[demo] server is starting at port 3000')\n  })\n  ```\n\n## 第13节：koa-static静态资源中间件\n\n在后台开发中不仅有需要代码处理的业务逻辑请求，也会有很多的静态资源请求。比如请求js，css，jpg，png这些静态资源请求。也非常的多，有些时候还会访问静态资源路径。用koa2自己些这些静态资源访问是完全可以的，但是代码会雍长一些。所以这节课我们利用koa-static中间件来实现静态资源的访问。\n\n* 安装`koa-static`\n\n  ```bash\n  npm install --save koa-static\n  ```\n\n* **新建static文件夹** 然后在static文件中放入图片，css和js文件\n\n* 使用`koa-static`中间件\n\n  ```javascript\n  const Koa = require('koa')\n  const path = require('path')\n  const static = require('koa-static')\n  \n  const app = new Koa()\n  \n  // 声明静态路径\n  const staticPath = './static'\n  \n  app.use(static(\n      path.join(__dirname, staticPath)\n  ))\n  \n  app.use(async (ctx) => {\n      ctx.body = 'hello world'\n  })\n  \n  app.listen(3000, () => {\n      console.log('[demo] server is starting at port 3000')\n  })\n  \n  // 访问图片直接 http://127.0.0.1:3000/koa2.jpg\n  ```\n","source":"_posts/Koa2入门小基础.md","raw":"---\ntitle: Koa2入门小基础\ndate: '2021-03-18'\ntype: 技术\ntags: Koa2\nsidebarDepth: 3\nsidebar: auto\nnote: Koa2是现在最流行的基于Node.js平台的web开发框架，它很小，但扩展性很强。Koa给人一种干净利落的感觉，体积小、编程方式干净。\n---\n\n# Koa2入门小基础\n\n学习指导：[挑战全栈 Koa2免费视频教程 (共13集)](http://www.jspang.com/posts/2017/11/13/koa2.html)\n\nKoa2是现在最流行的基于Node.js平台的web开发框架，它很小，但扩展性很强。Koa给人一种干净利落的感觉，体积小、编程方式干净。\n\n> 使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。一个Koa应用就是一个对象，包含了一个middleware数组，这个数组由一组Generator函数组成。这些函数负责对HTTP请求进行各种加工，比如生成缓存、指定代理、请求重定向等等。这些中间件函数基于 request 请求以一个类似于栈的结构组成并依次执行。\n\n## 第01节：Koa开发环境搭建\n\n作Koa2的开发，它要求Node.js版本高于V7.6。\n\n> ::: warning 注意事项\n> 请确保你的 Node.js 版本 >= 7.6。\n> :::\n\n### 搭建环境\n\n```bash\ncd code  //进入code文件夹\nmkdir koa2-demo //创建koa2-demo文件夹\ncd koa2-demo  //进入koa2-demo文件夹\n\nnpm init -y // 初始化生产package.json 文件\nnpm install --save koa // 安装koa\n```\n\n### 与君初相识\n\n```javascript\n// 根目录下创建 index.js\n\nconst Koa = require('koa')\n\nconst app = new Koa()\napp.use(async (ctx) => {\n    ctx.body = 'Hello Koa2'\n})\n\napp.listen(3000)\n\nconsole.log('[demo] start-quick is starting at port 3000')\n\n// 运行 node index.js\n// 浏览器中输入：http://127.0.0.1:3000 就可以看到结果了\n```\n\n## 第02节：async/await的使用方法\n\n### 什么是async和await\n\nasync是异步的简写，而await可以堪称async wait的简写。\n\n明白了两个单词，就很好理解了async是声明一个方法是异步的，await是等待异步方法完成。\n\n注意的是await必须在async方法中才可以使用因为await访问本身就会造成程序停止堵塞，所以必须在异步方法中才可以使用。\n\n* **async到底起什么作用**\n\n  ```javascript\n  // async是让方法变成异步，这个很好理解，关键是他的返回值是什么？我们得到后如何处理？\n  \n  // ./demo01.js\n  async function testAsync() {\n      return 'Hello Async'\n  }\n  const result = testAsync()\n  console.log(result)  // Promise { 'Hello Async' }\n  \n  // 输出了Promise { ‘Hello Async’ }，这时候会发现它返回的是Promise\n  ```\n\n* **await在等什么？**\n\n  await一般在等待async方法执行完毕，但是其实await等待的只是一个表达式，这个表达式在官方文档里说的是Promise对象，可是它也可以接受普通值。\n  \n  **await必须在async方法中才可以使用**\n  \n  **await接收Promise对象，也可以接收普通值**\n  \n  ```javascript\n  // ./demo02.js\n  \n  function getSomething(){\n      return 'something'\n  }\n  \n  async function testAsync() {\n      return 'Hello Async'\n  }\n  \n  async function test() {\n      const res1 = await getSomething()\n      const res2 = await testAsync()\n      console.log(res1, res2)\n  }\n  \n  // 执行\n  test()  // something Hello Async\n  ```\n\n### async/await同时使用\n\n```javascript\n// ./demo03.js\n\nfunction takeLongTime(){\n    return new Promise(resolve => {\n        setTimeout(() => {\n            resolve('long_time_value')\n        }, 2000);\n    })\n}\n\nasync function test() {\n    const res = await takeLongTime()\n    console.log(res)\n}\n\ntest()\n\n// 等待2秒钟， 输出 long_time_value\n```\n\n## 第03节：Get请求的接收\n\n* 在koa2中GET请求通过request接收，但是接受的方法有两种：query和querystring。\n  * query：返回的是格式化好的参数对象。\n  * querystring：返回的是请求字符串。\n  \n* 从 `ctx.request` 中获取Get请求\n\n    ```javascript\n    /**\n     *  在koa2中GET请求通过request接收，但是接受的方法有两种：query和querystring。\n     *  query：返回的是格式化好的参数对象。\n     *  querystring：返回的是请求字符串。\n     */\n\n    // ./ get_demo.js\n\n    const Koa = require('koa')\n    const app = new Koa()\n    app.use(async (ctx) => {\n        // 上下文得到url对象\n        let url = ctx.url\n        let request = ctx.request\n        let req_query = request.query\n        let req_querystring = request.querystring\n        ctx.body = {\n            url,\n            req_query,\n            req_querystring\n        }\n    })\n\n    app.listen(3000, () => {\n        console.log('[demo] server is starting at port 3000')\n    })\n\n    // 启动一切正常可在浏览器中使用http://127.0.0.1:3000?user=jspang&age=18来进行访问\n    // {\"url\":\"/?user=jspang&age=18\",\"req_query\":{\"user\":\"jspang\",\"age\":\"18\"},\"req_querystring\":\"user=jspang&age=18\"}\n    // query是一个对象，而querystring就是一个普通的字符串。\n    ```\n\n* 从`ctx`中得到GET请求。`ctx`中也分为query和querystring\n\n  ```javascript\n  // 从ctx中得到GET请求。ctx中也分为query和querystring\n  \n  const Koa = require('koa')\n  const app = new Koa()\n  app.use(async (ctx) => {\n      //从request中获取GET请求\n      // 上下文得到url对象\n      let url = ctx.url\n      let request = ctx.request\n      let req_query = request.query\n      let req_querystring = request.querystring\n  \n      //从上下文中直接获取\n      let ctx_query = ctx.query\n      let ctx_querystring = ctx.querystring\n\n      ctx.body = {\n          url,\n          req_query,\n          req_querystring,\n          ctx_query,\n          ctx_querystring\n      }\n  })\n  \n  app.listen(3000, () => {\n      console.log('[demo] server is starting at port 3000')\n  })\n  \n  /**\n   // 20190813114559\n  // http://127.0.0.1:3000/?user=jspang&age=18\n  \n  {\n    \"url\": \"/?user=jspang&age=18\",\n    \"req_query\": {\n      \"user\": \"jspang\",\n      \"age\": \"18\"\n    },\n    \"req_querystring\": \"user=jspang&age=18\",\n    \"ctx_query\": {\n      \"user\": \"jspang\",\n      \"age\": \"18\"\n    },\n    \"ctx_querystring\": \"user=jspang&age=18\"\n  }\n  \n  * */\n  ```\n\n* 总结：获得GET请求的方式有两种，一种是从request中获得，一种是一直从上下文中获得。\n\n* 获得的格式也有两种：query和querystring。\n\n## 第04节：POST请求如何接收（1）\n\n* 对于POST请求的处理，Koa2没有封装方便的获取参数的方法，需要通过解析上下文context中的原生node.js请求对象req来获取。\n\n* **获取Post请求的步骤：**\n\n1. 解析上下文ctx中的原生nodex.js对象req。\n2. 将POST表单数据解析成query string-字符串.(例如:user=jspang&age=18)\n3. 将字符串转换成JSON格式。\n\n* **ctx.request和ctx.req的区别**\n\n1. ctx.request: 是Koa2中context经过封装的请求对象，它用起来更直观和简单。\n2. ctx.req: 是context提供的node.js原生HTTP请求对象。这个虽然不那么直观，但是可以得到更多的内容，适合我们深度编程。\n\n* **ctx.method 得到请求类型**\n\n  ```javascript\n  // ctx.method 得到请求类型\n  \n  // Koa2中提供了ctx.method属性，可以轻松的得到请求的类型，\n  // 然后根据请求类型编写不同的相应方法\n  \n  // ./post_demo01.js\n  \n  const Koa = require('koa')\n  const app = new Koa()\n  app.use(async (ctx) => {\n    // 当请求是GET请求，显示表单让用户填写\n    if (ctx.url === '/' && ctx.method === 'GET') {\n      let html = `\n        <h1>Koa2 request post demo</h1>\n        <form method='POST' action='/'>\n        <p>userName</p>\n          <input name=\"userName\"/> <br/>\n          <p>age</p>\n          <input name=\"age\"/> <br/>\n          <p>webSite</p>\n          <input name='webSite'/><br/>\n          <button type=\"submit\">submit</button>\n        </form>\n      `\n      ctx.body = html\n    } else if (ctx.url === '/' && ctx.method === 'POST') {  // 当请求时POST请求时\n      ctx.body = '接收到请求'\n    } else {    // 其他请求显示404报错\n      ctx.body = '<h1>404 page!</h1>'\n    }\n  })\n  \n  app.listen(3000, () => {\n      console.log('[demo] server is starting at port 3000')\n  })\n  \n  /**\n  浏览器中输入http://127.0.0.1:3000进行查看，\n    第一次进入时给我们展现的是一个表单页面，\n    我们点击提交后可以看到服务器接收到了我们的信息，但我们并没有做出任何处理。\n    当我们下输入一个地址时，它会提示404错误。\n  * */\n  \n  // **总结：**从理论上讲解了如何获取POST请求参数\n  ```\n\n\n\n## 第05节：POST请求如何接收（2）\n\n* **解析Node原生POST参数**\n\n  ```javascript\n  // ./post_demo2.js\n  \n  // 解析Node原生POST参数\n  // 声明一个方法，然后用Promise对象进行解析。这里我们使用了ctx.req.on来接收事件\n  function parsePostData(ctx) {\n    return new Promise((resolve, reject) => {\n      try {\n        let postdata = ''\n        ctx.req.on('data', (data) => {\n          postdata += data\n        })\n        ctx.req.addListener('end', function () {\n          resolve(postdata)\n        })\n      } catch{\n        reject(error)\n      }\n    })\n  }\n  ```\n\n* 修改在上节课接收POST请求的处理方法里，修改代码如下\n\n  ```javascript\n  // ctx.body = '接收到POST请求'\n  let postdata = await parsePostData(ctx)  // userName=jspang&age=123&webSite=www.douban.com\n  ctx.body = postdata\n  \n  // 页面就输出刚才填的表单  userName=jspang&age=123&webSite=www.douban.com\n  ```\n\n* **POST字符串解析JSON对象**\n\n  ```javascript\n  // ./post_demo2.js\n  \n  // POST字符串解析JSON对象\n  // 字符串封装JSON兑现对象的方法\n  // userName=jspang&age=123&webSite=www.douban.com\n  function parseQueryStr(queryStr) {\n    let queryData = {}\n    // split() 方法使用指定的分隔符字符串将一个String对象分割成字符串数组，\n    // 以将字符串分隔为子字符串，以确定每个拆分的位置。 \n    let queryStrList = queryStr.split('&')\n    // console.log(queryStrList)\n    // entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对\n    for (let [index, queryStrItem] of queryStrList.entries()) {\n      let itemList = queryStrItem.split('=')\n      // console.log(itemList)\n      queryData[itemList[0]] = itemList[1]\n    }\n    return queryData\n  }\n  \n  \n  // 在上述解析Node原生POST参数中修改\n  ctx.req.addListener('end', function () {\n      // resolve(postdata)\n      let parseData = parseQueryStr(postdata)\n      resolve(parseData)\n  })\n  \n  /**\n  使用for…of 循环\n  var arr = [\"a\", \"b\", \"c\"];\n  var iterator = arr.entries();\n  \n  for (let e of iterator) {\n    console.log(e);\n  }\n  \n  // [0, \"a\"] \n  // [1, \"b\"] \n  // [2, \"c\"]\n  */\n  \n  // node运行，浏览器http://127.0.0.1:3000，先填写表单，然后页面就会返回\n  /*\n  {\n    \"userName\": \"jspang\",\n    \"age\": \"123\",\n    \"webSite\": \"www.douban.com\"\n  }\n  */\n  ```\n\n* 完整代码见`post_demo2.js`\n\n## [扩展]Array/entries方法精讲\n\n* 参考：[Array/entries](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/entries)\n\n* `**entries()**` 方法返回一个新的**Array Iterator**对象，该对象包含数组中每个索引的键/值对。\n\n* > arr.entries()\n\n  返回值是 一个新的 [`Array`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array) 迭代器对象。[Array Iterator](http://www.ecma-international.org/ecma-262/6.0/#sec-createarrayiterator)是对象，它的原型（__proto__:Array Iterator）上有一个[next](http://www.ecma-international.org/ecma-262/6.0/#sec-%arrayiteratorprototype%.next)方法，可用用于遍历迭代器取得原数组的[key,value]。\n\n* `Array Iterator`\n\n  ```javascript\n  var arr = [\"a\", \"b\", \"c\"];\n  var iterator = arr.entries();\n  console.log(iterator);\n  \n  /*Array Iterator {}\n           __proto__:Array Iterator\n           next:ƒ next()\n           Symbol(Symbol.toStringTag):\"Array Iterator\"\n           __proto__:Object\n  */\n  ```\n\n* `iterator.next()`\n\n  ```javascript\n  var arr = [\"a\", \"b\", \"c\"]; \n  var iterator = arr.entries();\n  console.log(iterator.next());\n  \n  /*{value: Array(2), done: false}\n            done:false\n            value:(2) [0, \"a\"]\n             __proto__: Object\n  */\n  // iterator.next()返回一个对象，对于有元素的数组，\n  // 是next{ value: Array(2), done: false }；\n  // next.done 用于指示迭代器是否完成：在每次迭代时进行更新而且都是false，\n  // 直到迭代器结束done才是true。\n  // next.value是一个[\"key\",\"value\"]的数组，是返回的迭代器中的元素值。\n  ```\n\n* `iterator.next方法运行`\n\n  ```javascript\n  var arr = [\"a\", \"b\", \"c\"];\n  var iter = arr.entries();\n  var a = [];\n  \n  // for(var i=0; i< arr.length; i++){   // 实际使用的是这个 \n  for(var i=0; i< arr.length+1; i++){    // 注意，是length+1，比数组的长度大\n      var tem = iter.next();             // 每次迭代时更新next\n      console.log(tem.done);             // 这里可以看到更新后的done都是false\n      if(tem.done !== true){             // 遍历迭代器结束done才是true\n          console.log(tem.value);\n          a[i]=tem.value;\n      }\n  }\n\n  console.log(a);                         // 遍历完毕，输出next.value的数组\n  ```\n\n* `二维数组按行排序`\n\n  ```javascript\n  function sortArr(arr) {\n      var goNext = true;\n      var entries = arr.entries();\n      while (goNext) {\n          var result = entries.next();\n          if (result.done !== true) {\n              result.value[1].sort((a, b) => a - b);\n              goNext = true;\n          } else {\n              goNext = false;\n          }\n      }\n      return arr;\n  }\n  \n  var arr = [[1,34],[456,2,3,44,234],[4567,1,4,5,6],[34,78,23,1]];\n  sortArr(arr);\n  \n  /*(4) [Array(2), Array(5), Array(5), Array(4)]\n      0:(2) [1, 34]\n      1:(5) [2, 3, 44, 234, 456]\n      2:(5) [1, 4, 5, 6, 4567]\n      3:(4) [1, 23, 34, 78]\n      length:4\n      __proto__:Array(0)\n  */\n  ```\n\n* `使用for…of 循环`\n\n  ```javascript\n  var arr = [\"a\", \"b\", \"c\"];\n  var iterator = arr.entries();\n  // undefined\n  \n  for (let e of iterator) {\n      console.log(e);\n  }\n  \n  // [0, \"a\"]\n  // [1, \"b\"]\n  // [2, \"c\"]\n  ```\n\n## 第06节：koa-bodyparser中间件\n\n对于POST请求的处理，koa-bodyparser中间件可以把koa2上下文的formData数据解析到ctx.request.body中。\n\n* **安装中间件**\n\n  ```bash\n  # 使用npm进行安装，需要注意的是我们这里要用–save，因为它在生产环境中需要使用。\n  \n  npm install --save koa-bodyparser@3\n  ```\n\n* **引入使用**\n\n  安装完成后，需要在代码中引入并使用。我们在代码顶部用require进行引入。\n  \n  ```javascript\n  const bodyParser = require('koa-bodyparser')\n  ```\n  \n  然后进行使用，如果不使用是没办法调用的，使用代码如下。\n  \n  ```javascript\n  app.use(bodyParser())\n  ```\n  \n  在代码中使用后，直接可以用`ctx.request.body`进行获取POST请求参数，中间件自动给我们作了解析。\n  \n* 用例：\n\n  ```javascript\n  // Post请求解析中间件   koa-bodyparser\n  \n  // ./bodyparser_demo.js\n  \n  const Koa = require('koa')\n  const bodyParser = require('koa-bodyparser')\n  const app = new Koa()\n  app.use(bodyParser())\n  \n  app.use(async (ctx) => {\n    // 当请求是GET请求，显示表单让用户填写\n    if (ctx.url === '/' && ctx.method === 'GET') {\n      let html = `\n        <h1>Koa2 request post demo</h1>\n        <form method='POST' action='/'>\n        <p>userName</p>\n          <input name=\"userName\"/> <br/>\n          <p>age</p>\n          <input name=\"age\"/> <br/>\n          <p>webSite</p>\n          <input name='webSite'/><br/>\n          <button type=\"submit\">submit</button>\n        </form>\n      `\n      ctx.body = html\n    } else if (ctx.url === '/' && ctx.method === 'POST') {  // 当请求时POST请求时\n      // ctx.body = '接收到POST请求'\n      let postData= ctx.request.body\n      ctx.body = postData\n    } else {    // 其他请求显示404报错\n      ctx.body = '<h1>404 page!</h1>'\n    }\n  })\n  \n  app.listen(3000, () => {\n      console.log('[demo] server is starting at port 3000')\n  })\n  ```\n\n## 第07节：Koa2原生路由实现\n\n* `ctx.request.url`\n\n  ```javascript\n  // ctx.request.url\n  // 地址栏输入的路径，然后根据路径的不同进行跳转\n  \n  const Koa = require('koa')\n  const app = new Koa()\n  app.use(async (ctx) => {\n    let url = ctx.request.url\n    ctx.body = url\n  })\n  \n  app.listen(3000, () => {\n      console.log('[demo] server is starting at port 3000')\n  })\n  \n  // 访问http://127.0.0.1:3000/jspang/18 页面会输出/jspang/18\n  ```\n\n* **Koa2原生路由实现**\n\n  原生路由的实现需要引入fs模块来读取文件。然后再根据路由的路径去读取，最后返回给页面，进行渲染。\n\n  ```javascript\n  // Koa2原生路由实现\n  \n  // ctx.request.url\n  // 地址栏输入的路径，然后根据路径的不同进行跳转\n  \n  function render(page) {\n    return new Promise((resolve, reject) => {\n      let pageUrl = `./page/${page}`\n      // 获取文件地址 读取文件\n      fs.readFile(pageUrl, \"binary\", (error, data) => {\n        if (error) {\n          reject(error)\n        } else {\n          resolve(data)\n        }\n      })\n    })\n  }\n  \n  async function route(url) {\n    let page = '404.html'\n    switch (url) {\n      case '/':\n        page = 'index.html'\n        break\n      case '/index':\n        page = 'index.html'\n        break\n      case '/todo':\n        page = 'todo.html'\n        break\n      case '/404':\n        page = '404.html'\n        break\n      default:\n        break\n    }\n  \n    let html = await render(page)\n    return html\n  }\n  \n  const Koa = require('koa')\n  const app = new Koa()\n  const fs = require('fs')\n  \n  app.use(async (ctx) => {\n    let url = ctx.request.url\n    let html = await route(url)\n    ctx.body = html\n  })\n  \n  app.listen(3000, () => {\n    console.log('[demo] server is starting at port 3000')\n  })\n  ```\n\n## 第08节：Koa-router中间件（1）入门\n\n安装koa-router中间件\n\n```bash\n# 安装koa-router中间件\n\nnpm install --save koa-router\n```\n\n基础案例\n\n```javascript\n// Koa-router\n\n// ./koa-router1.js\n\nconst Koa = require('koa')\nconst Router = require('koa-router')\n\nconst app = new Koa()\nconst router = new Router()\n\nrouter\n  .get('/', (ctx, next) => {\n    ctx.body = 'Hello Koa-router'\n  })\n  .get('/todo', (ctx, next) => {   // 路由多页面配置\n    ctx.body = 'Todo page!'\n  })\n\n// 挂载路由\napp.use(router.routes())\n  .use(router.allowedMethods())\n\napp.listen(3000, () => {\n  console.log('[demo] server is starting at port 3000')\n})\n```\n\n\n\n## 第09节：Koa-router中间件（2）层级\n\n* **设置前缀**\n\n  有时候我们想把所有的路径前面都再加入一个级别，比如原来我们访问的路径是`http://127.0.0.1:3000/todo`，现在我们希望在所有的路径前面都加上一个jspang层级，把路径变成`http://127.0.0.1:3000/jspang/todo.`这时候就可以使用层级来完成这个功能。路由在创建的时候是可以指定一个前缀的，这个前缀会被至于路由的最顶层，也就是说，这个路由的所有请求都是相对于这个前缀的.\n\n  ```javascript\n  const router = new Router({\n      prefix:'/jspang'\n  })\n  ```\n\n* 设置层级\n\n  设置前缀一般都是全局的，并不能实现路由的层级，如果你想为单个页面设置层级，也是很简单的。只要在use时使用路径就可以了。\n\n  例如这种写法装载路由层级，这里的router相当于父级：`router.use(‘/page’, page.routes(), page.allowedMethods())`。\n\n  通过这种写法的好处是并不是全局的，我们可以给不同的路由加层级。\n\n  ```javascript\n  // Koa-router 层级\n  \n  // ./koa-router2.js\n  \n  const Koa = require('koa')\n  const Router = require('koa-router')\n  \n  const app = new Koa()\n  // const router = new Router({\n  //   // prefix: '/jspang'  // 设置前缀\n  // })\n  \n  // 设置路由层级\n  let home = new Router()\n  home\n    .get('/jspang', async (ctx, next) => {\n      ctx.body = 'Home jspang'\n    })\n    .get('/todo', async (ctx, next) => {   // 路由多页面配置\n      ctx.body = 'Home Todo'\n    })\n  \n  let page = new Router()\n  page\n    .get('/jspang',(ctx, next) => {  // async 异步不异步都可以\n      ctx.body = 'Page jspang'\n    })\n    .get('/todo',(ctx, next) => {   // 路由多页面配置\n      ctx.body = 'Page Todo'\n    })\n  \n  // 装载所有子路由  router.use(‘/page’, page.routes(), page.allowedMethods())\n  // 设置父路由\n  let router = new Router()\n  router.use('/home', home.routes(), home.allowedMethods())\n  router.use('/page', page.routes(), page.allowedMethods())\n  \n  // 挂载路由中间件\n  app.use(router.routes())\n    .use(router.allowedMethods())\n  \n  app.listen(3000, () => {\n    console.log('[demo] server is starting at port 3000')\n  })\n  ```\n\n## 第10节：Koa-router中间件（3）参数\n\n* 获取传递参数 `ctx.query来进行接收`\n\n  ```javascript\n  // Koa-router 参数\n  \n  // ./koa-router3.js\n  \n  const Koa = require('koa')\n  const Router = require('koa-router')\n  \n  const app = new Koa()\n  const router = new Router()\n  \n  router\n    .get('/', (ctx, next) => {\n      // 获取 get 请求参数\n      ctx.body = ctx.query\n    })\n  \n  // 挂载路由中间件\n  app.use(router.routes())\n    .use(router.allowedMethods())\n  \n  app.listen(3000, () => {\n    console.log('[demo] server is starting at port 3000')\n  })\n  \n  // 地址栏输出 http://127.0.0.1:3000/?user=jspang&age=18\n  /*\n  {\n    \"user\": \"jspang\",\n    \"age\": \"18\"\n  }\n  */\n  ```\n\n## 第11节：Koa2中使用cookie\n\n* `ctx.cookies.get(name,[optins])`: 读取上下文请求中的cookie。\n* `ctx.cookies.set(name,value,[options])`：在上下文中写入cookie\n\n* **写入`Cookies`**\n\n  ```javascript\n  ctx.cookies.set('name', 'jspang')\n  ```\n\n* **Cookie选项**\n  * 比如我们要存储用户名，保留用户登录状态时，你可以选择7天内不用登录，也可以选择30天内不用登录。这就需要在写入是配置一些选项：\n  * `domain`：写入cookie所在的域名\n  * `path`：写入cookie所在的路径\n  * `maxAge`：Cookie最大有效时长\n  * `expires`：cookie失效时间\n  * `httpOnly`:是否只用http请求中获得\n  * `overwirte`：是否允许重写\n\n* **读取`cookies`**\n\n  ```javascript\n  ctx.cookies.get('name')\n  ```\n\n## 第12节：Koa2的模板初识（ejs）\n\n开发中不可能把所有的html代码全部卸载JS里，这显然不现实，也没办法完成大型web开发。必须借用模板机制来帮助我们开发，这节课我们就简单了解一下Koa2的模板机制，koa2的目标机制要依靠中间件来完成开发。\n\n* **安装中间件**\n\n  ```bash\n  # 安装中间件\n  \n  npm install --save koa-views\n  ```\n\n* **安装ejs模板引擎**\n\n  ```bash\n  # 安装ejs模板引擎\n  \n  npm install --save ejs\n  ```\n\n* **编写模板**\n\n  ```javascript\n  // 为了模板统一管理，我们新建一个view的文件夹，并在它下面新建index.ejs文件。\n  \n  // ./views/index.ejs\n  \n  <!DOCTYPE html>\n  <html lang=\"en\">\n  <head>\n      <meta charset=\"UTF-8\">\n      <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n      <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n      <title><%= title%></title>\n  </head>\n  <body>\n      <h1><%= title %></h1>\n      <p>EJS Welcome to <%= title %></p>\n  </body>\n  </html>\n  ```\n\n* **编写Koa文件**\n\n  ```javascript\n  // ejs模板\n  // ./ejs_demo.js\n  \n  const Koa = require('koa')\n  const views = require('koa-views')\n  const path = require('path')\n  const app = new Koa()\n  \n  // 加载模板引擎\n  app.use(views(path.join(__dirname, './views'), {\n    extension: 'ejs'\n  }))\n  \n  app.use(async (ctx) => {\n    let title = 'HELLO Koa2'\n    await ctx.render('index', {\n      title\n    })\n  })\n  \n  \n  app.listen(3000, () => {\n    console.log('[demo] server is starting at port 3000')\n  })\n  ```\n\n## 第13节：koa-static静态资源中间件\n\n在后台开发中不仅有需要代码处理的业务逻辑请求，也会有很多的静态资源请求。比如请求js，css，jpg，png这些静态资源请求。也非常的多，有些时候还会访问静态资源路径。用koa2自己些这些静态资源访问是完全可以的，但是代码会雍长一些。所以这节课我们利用koa-static中间件来实现静态资源的访问。\n\n* 安装`koa-static`\n\n  ```bash\n  npm install --save koa-static\n  ```\n\n* **新建static文件夹** 然后在static文件中放入图片，css和js文件\n\n* 使用`koa-static`中间件\n\n  ```javascript\n  const Koa = require('koa')\n  const path = require('path')\n  const static = require('koa-static')\n  \n  const app = new Koa()\n  \n  // 声明静态路径\n  const staticPath = './static'\n  \n  app.use(static(\n      path.join(__dirname, staticPath)\n  ))\n  \n  app.use(async (ctx) => {\n      ctx.body = 'hello world'\n  })\n  \n  app.listen(3000, () => {\n      console.log('[demo] server is starting at port 3000')\n  })\n  \n  // 访问图片直接 http://127.0.0.1:3000/koa2.jpg\n  ```\n","slug":"Koa2入门小基础","published":1,"updated":"2021-07-19T05:53:26.049Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrd8jv190005kwzt2ds09w2y","content":"<h1 id=\"Koa2入门小基础\"><a href=\"#Koa2入门小基础\" class=\"headerlink\" title=\"Koa2入门小基础\"></a>Koa2入门小基础</h1><p>学习指导：<a href=\"http://www.jspang.com/posts/2017/11/13/koa2.html\">挑战全栈 Koa2免费视频教程 (共13集)</a></p>\n<p>Koa2是现在最流行的基于Node.js平台的web开发框架，它很小，但扩展性很强。Koa给人一种干净利落的感觉，体积小、编程方式干净。</p>\n<blockquote>\n<p>使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。一个Koa应用就是一个对象，包含了一个middleware数组，这个数组由一组Generator函数组成。这些函数负责对HTTP请求进行各种加工，比如生成缓存、指定代理、请求重定向等等。这些中间件函数基于 request 请求以一个类似于栈的结构组成并依次执行。</p>\n</blockquote>\n<h2 id=\"第01节：Koa开发环境搭建\"><a href=\"#第01节：Koa开发环境搭建\" class=\"headerlink\" title=\"第01节：Koa开发环境搭建\"></a>第01节：Koa开发环境搭建</h2><p>作Koa2的开发，它要求Node.js版本高于V7.6。</p>\n<blockquote>\n<p>::: warning 注意事项<br>请确保你的 Node.js 版本 &gt;= 7.6。<br>:::</p>\n</blockquote>\n<h3 id=\"搭建环境\"><a href=\"#搭建环境\" class=\"headerlink\" title=\"搭建环境\"></a>搭建环境</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> code  //进入code文件夹</span><br><span class=\"line\">mkdir koa2-demo //创建koa2-demo文件夹</span><br><span class=\"line\"><span class=\"built_in\">cd</span> koa2-demo  //进入koa2-demo文件夹</span><br><span class=\"line\"></span><br><span class=\"line\">npm init -y // 初始化生产package.json 文件</span><br><span class=\"line\">npm install --save koa // 安装koa</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"与君初相识\"><a href=\"#与君初相识\" class=\"headerlink\" title=\"与君初相识\"></a>与君初相识</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根目录下创建 index.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx) =&gt; &#123;</span><br><span class=\"line\">    ctx.body = <span class=\"string\">&#x27;Hello Koa2&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] start-quick is starting at port 3000&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行 node index.js</span></span><br><span class=\"line\"><span class=\"comment\">// 浏览器中输入：http://127.0.0.1:3000 就可以看到结果了</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第02节：async-await的使用方法\"><a href=\"#第02节：async-await的使用方法\" class=\"headerlink\" title=\"第02节：async/await的使用方法\"></a>第02节：async/await的使用方法</h2><h3 id=\"什么是async和await\"><a href=\"#什么是async和await\" class=\"headerlink\" title=\"什么是async和await\"></a>什么是async和await</h3><p>async是异步的简写，而await可以堪称async wait的简写。</p>\n<p>明白了两个单词，就很好理解了async是声明一个方法是异步的，await是等待异步方法完成。</p>\n<p>注意的是await必须在async方法中才可以使用因为await访问本身就会造成程序停止堵塞，所以必须在异步方法中才可以使用。</p>\n<ul>\n<li><p><strong>async到底起什么作用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// async是让方法变成异步，这个很好理解，关键是他的返回值是什么？我们得到后如何处理？</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ./demo01.js</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testAsync</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Hello Async&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> result = testAsync()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result)  <span class=\"comment\">// Promise &#123; &#x27;Hello Async&#x27; &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出了Promise &#123; ‘Hello Async’ &#125;，这时候会发现它返回的是Promise</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>await在等什么？</strong></p>\n<p>await一般在等待async方法执行完毕，但是其实await等待的只是一个表达式，这个表达式在官方文档里说的是Promise对象，可是它也可以接受普通值。</p>\n<p><strong>await必须在async方法中才可以使用</strong></p>\n<p><strong>await接收Promise对象，也可以接收普通值</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./demo02.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSomething</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;something&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testAsync</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Hello Async&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res1 = <span class=\"keyword\">await</span> getSomething()</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res2 = <span class=\"keyword\">await</span> testAsync()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res1, res2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行</span></span><br><span class=\"line\">test()  <span class=\"comment\">// something Hello Async</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"async-await同时使用\"><a href=\"#async-await同时使用\" class=\"headerlink\" title=\"async/await同时使用\"></a>async/await同时使用</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./demo03.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">takeLongTime</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            resolve(<span class=\"string\">&#x27;long_time_value&#x27;</span>)</span><br><span class=\"line\">        &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = <span class=\"keyword\">await</span> takeLongTime()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等待2秒钟， 输出 long_time_value</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第03节：Get请求的接收\"><a href=\"#第03节：Get请求的接收\" class=\"headerlink\" title=\"第03节：Get请求的接收\"></a>第03节：Get请求的接收</h2><ul>\n<li><p>在koa2中GET请求通过request接收，但是接受的方法有两种：query和querystring。</p>\n<ul>\n<li>query：返回的是格式化好的参数对象。</li>\n<li>querystring：返回的是请求字符串。</li>\n</ul>\n</li>\n<li><p>从 <code>ctx.request</code> 中获取Get请求</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  在koa2中GET请求通过request接收，但是接受的方法有两种：query和querystring。</span></span><br><span class=\"line\"><span class=\"comment\"> *  query：返回的是格式化好的参数对象。</span></span><br><span class=\"line\"><span class=\"comment\"> *  querystring：返回的是请求字符串。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ./ get_demo.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 上下文得到url对象</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> url = ctx.url</span><br><span class=\"line\">    <span class=\"keyword\">let</span> request = ctx.request</span><br><span class=\"line\">    <span class=\"keyword\">let</span> req_query = request.query</span><br><span class=\"line\">    <span class=\"keyword\">let</span> req_querystring = request.querystring</span><br><span class=\"line\">    ctx.body = &#123;</span><br><span class=\"line\">        url,</span><br><span class=\"line\">        req_query,</span><br><span class=\"line\">        req_querystring</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动一切正常可在浏览器中使用http://127.0.0.1:3000?user=jspang&amp;age=18来进行访问</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;&quot;url&quot;:&quot;/?user=jspang&amp;age=18&quot;,&quot;req_query&quot;:&#123;&quot;user&quot;:&quot;jspang&quot;,&quot;age&quot;:&quot;18&quot;&#125;,&quot;req_querystring&quot;:&quot;user=jspang&amp;age=18&quot;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// query是一个对象，而querystring就是一个普通的字符串。</span></span><br></pre></td></tr></table></figure></li>\n<li><p>从<code>ctx</code>中得到GET请求。<code>ctx</code>中也分为query和querystring</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从ctx中得到GET请求。ctx中也分为query和querystring</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">//从request中获取GET请求</span></span><br><span class=\"line\">    <span class=\"comment\">// 上下文得到url对象</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> url = ctx.url</span><br><span class=\"line\">    <span class=\"keyword\">let</span> request = ctx.request</span><br><span class=\"line\">    <span class=\"keyword\">let</span> req_query = request.query</span><br><span class=\"line\">    <span class=\"keyword\">let</span> req_querystring = request.querystring</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//从上下文中直接获取</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> ctx_query = ctx.query</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ctx_querystring = ctx.querystring</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.body = &#123;</span><br><span class=\"line\">        url,</span><br><span class=\"line\">        req_query,</span><br><span class=\"line\">        req_querystring,</span><br><span class=\"line\">        ctx_query,</span><br><span class=\"line\">        ctx_querystring</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> // 20190813114559</span></span><br><span class=\"line\"><span class=\"comment\">// http://127.0.0.1:3000/?user=jspang&amp;age=18</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">  &quot;url&quot;: &quot;/?user=jspang&amp;age=18&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">  &quot;req_query&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    &quot;user&quot;: &quot;jspang&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">    &quot;age&quot;: &quot;18&quot;</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;,</span></span><br><span class=\"line\"><span class=\"comment\">  &quot;req_querystring&quot;: &quot;user=jspang&amp;age=18&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">  &quot;ctx_query&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    &quot;user&quot;: &quot;jspang&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">    &quot;age&quot;: &quot;18&quot;</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;,</span></span><br><span class=\"line\"><span class=\"comment\">  &quot;ctx_querystring&quot;: &quot;user=jspang&amp;age=18&quot;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br></pre></td></tr></table></figure></li>\n<li><p>总结：获得GET请求的方式有两种，一种是从request中获得，一种是一直从上下文中获得。</p>\n</li>\n<li><p>获得的格式也有两种：query和querystring。</p>\n</li>\n</ul>\n<h2 id=\"第04节：POST请求如何接收（1）\"><a href=\"#第04节：POST请求如何接收（1）\" class=\"headerlink\" title=\"第04节：POST请求如何接收（1）\"></a>第04节：POST请求如何接收（1）</h2><ul>\n<li><p>对于POST请求的处理，Koa2没有封装方便的获取参数的方法，需要通过解析上下文context中的原生node.js请求对象req来获取。</p>\n</li>\n<li><p><strong>获取Post请求的步骤：</strong></p>\n</li>\n</ul>\n<ol>\n<li>解析上下文ctx中的原生nodex.js对象req。</li>\n<li>将POST表单数据解析成query string-字符串.(例如:user=jspang&amp;age=18)</li>\n<li>将字符串转换成JSON格式。</li>\n</ol>\n<ul>\n<li><strong>ctx.request和ctx.req的区别</strong></li>\n</ul>\n<ol>\n<li>ctx.request: 是Koa2中context经过封装的请求对象，它用起来更直观和简单。</li>\n<li>ctx.req: 是context提供的node.js原生HTTP请求对象。这个虽然不那么直观，但是可以得到更多的内容，适合我们深度编程。</li>\n</ol>\n<ul>\n<li><p><strong>ctx.method 得到请求类型</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ctx.method 得到请求类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Koa2中提供了ctx.method属性，可以轻松的得到请求的类型，</span></span><br><span class=\"line\"><span class=\"comment\">// 然后根据请求类型编写不同的相应方法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ./post_demo01.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 当请求是GET请求，显示表单让用户填写</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ctx.url === <span class=\"string\">&#x27;/&#x27;</span> &amp;&amp; ctx.method === <span class=\"string\">&#x27;GET&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> html = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">      &lt;h1&gt;Koa2 request post demo&lt;/h1&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;form method=&#x27;POST&#x27; action=&#x27;/&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;p&gt;userName&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;input name=&quot;userName&quot;/&gt; &lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;p&gt;age&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;input name=&quot;age&quot;/&gt; &lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;p&gt;webSite&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;input name=&#x27;webSite&#x27;/&gt;&lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/form&gt;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\">    ctx.body = html</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ctx.url === <span class=\"string\">&#x27;/&#x27;</span> &amp;&amp; ctx.method === <span class=\"string\">&#x27;POST&#x27;</span>) &#123;  <span class=\"comment\">// 当请求时POST请求时</span></span><br><span class=\"line\">    ctx.body = <span class=\"string\">&#x27;接收到请求&#x27;</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;    <span class=\"comment\">// 其他请求显示404报错</span></span><br><span class=\"line\">    ctx.body = <span class=\"string\">&#x27;&lt;h1&gt;404 page!&lt;/h1&gt;&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">浏览器中输入http://127.0.0.1:3000进行查看，</span></span><br><span class=\"line\"><span class=\"comment\">  第一次进入时给我们展现的是一个表单页面，</span></span><br><span class=\"line\"><span class=\"comment\">  我们点击提交后可以看到服务器接收到了我们的信息，但我们并没有做出任何处理。</span></span><br><span class=\"line\"><span class=\"comment\">  当我们下输入一个地址时，它会提示404错误。</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// **总结：**从理论上讲解了如何获取POST请求参数</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第05节：POST请求如何接收（2）\"><a href=\"#第05节：POST请求如何接收（2）\" class=\"headerlink\" title=\"第05节：POST请求如何接收（2）\"></a>第05节：POST请求如何接收（2）</h2><ul>\n<li><p><strong>解析Node原生POST参数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./post_demo2.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解析Node原生POST参数</span></span><br><span class=\"line\"><span class=\"comment\">// 声明一个方法，然后用Promise对象进行解析。这里我们使用了ctx.req.on来接收事件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parsePostData</span>(<span class=\"params\">ctx</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> postdata = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">      ctx.req.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        postdata += data</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      ctx.req.addListener(<span class=\"string\">&#x27;end&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        resolve(postdata)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>&#123;</span><br><span class=\"line\">      reject(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>修改在上节课接收POST请求的处理方法里，修改代码如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ctx.body = &#x27;接收到POST请求&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> postdata = <span class=\"keyword\">await</span> parsePostData(ctx)  <span class=\"comment\">// userName=jspang&amp;age=123&amp;webSite=www.douban.com</span></span><br><span class=\"line\">ctx.body = postdata</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 页面就输出刚才填的表单  userName=jspang&amp;age=123&amp;webSite=www.douban.com</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>POST字符串解析JSON对象</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./post_demo2.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// POST字符串解析JSON对象</span></span><br><span class=\"line\"><span class=\"comment\">// 字符串封装JSON兑现对象的方法</span></span><br><span class=\"line\"><span class=\"comment\">// userName=jspang&amp;age=123&amp;webSite=www.douban.com</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseQueryStr</span>(<span class=\"params\">queryStr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> queryData = &#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">// split() 方法使用指定的分隔符字符串将一个String对象分割成字符串数组，</span></span><br><span class=\"line\">  <span class=\"comment\">// 以将字符串分隔为子字符串，以确定每个拆分的位置。 </span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> queryStrList = queryStr.split(<span class=\"string\">&#x27;&amp;&#x27;</span>)</span><br><span class=\"line\">  <span class=\"comment\">// console.log(queryStrList)</span></span><br><span class=\"line\">  <span class=\"comment\">// entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [index, queryStrItem] <span class=\"keyword\">of</span> queryStrList.entries()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> itemList = queryStrItem.split(<span class=\"string\">&#x27;=&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// console.log(itemList)</span></span><br><span class=\"line\">    queryData[itemList[<span class=\"number\">0</span>]] = itemList[<span class=\"number\">1</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> queryData</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在上述解析Node原生POST参数中修改</span></span><br><span class=\"line\">ctx.req.addListener(<span class=\"string\">&#x27;end&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// resolve(postdata)</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> parseData = parseQueryStr(postdata)</span><br><span class=\"line\">    resolve(parseData)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">使用for…of 循环</span></span><br><span class=\"line\"><span class=\"comment\">var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];</span></span><br><span class=\"line\"><span class=\"comment\">var iterator = arr.entries();</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">for (let e of iterator) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  console.log(e);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">// [0, &quot;a&quot;] </span></span><br><span class=\"line\"><span class=\"comment\">// [1, &quot;b&quot;] </span></span><br><span class=\"line\"><span class=\"comment\">// [2, &quot;c&quot;]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// node运行，浏览器http://127.0.0.1:3000，先填写表单，然后页面就会返回</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">  &quot;userName&quot;: &quot;jspang&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">  &quot;age&quot;: &quot;123&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">  &quot;webSite&quot;: &quot;www.douban.com&quot;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></li>\n<li><p>完整代码见<code>post_demo2.js</code></p>\n</li>\n</ul>\n<h2 id=\"扩展-Array-entries方法精讲\"><a href=\"#扩展-Array-entries方法精讲\" class=\"headerlink\" title=\"[扩展]Array/entries方法精讲\"></a>[扩展]Array/entries方法精讲</h2><ul>\n<li><p>参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/entries\">Array/entries</a></p>\n</li>\n<li><p><code>**entries()**</code> 方法返回一个新的<strong>Array Iterator</strong>对象，该对象包含数组中每个索引的键/值对。</p>\n</li>\n<li><blockquote>\n<p>arr.entries()</p>\n</blockquote>\n<p>返回值是 一个新的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array\"><code>Array</code></a> 迭代器对象。<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-createarrayiterator\">Array Iterator</a>是对象，它的原型（<strong>proto</strong>:Array Iterator）上有一个<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-%arrayiteratorprototype%.next\">next</a>方法，可用用于遍历迭代器取得原数组的[key,value]。</p>\n</li>\n<li><p><code>Array Iterator</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> iterator = arr.entries();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*Array Iterator &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">         __proto__:Array Iterator</span></span><br><span class=\"line\"><span class=\"comment\">         next:ƒ next()</span></span><br><span class=\"line\"><span class=\"comment\">         Symbol(Symbol.toStringTag):&quot;Array Iterator&quot;</span></span><br><span class=\"line\"><span class=\"comment\">         __proto__:Object</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></li>\n<li><p><code>iterator.next()</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>]; </span><br><span class=\"line\"><span class=\"keyword\">var</span> iterator = arr.entries();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*&#123;value: Array(2), done: false&#125;</span></span><br><span class=\"line\"><span class=\"comment\">          done:false</span></span><br><span class=\"line\"><span class=\"comment\">          value:(2) [0, &quot;a&quot;]</span></span><br><span class=\"line\"><span class=\"comment\">           __proto__: Object</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">// iterator.next()返回一个对象，对于有元素的数组，</span></span><br><span class=\"line\"><span class=\"comment\">// 是next&#123; value: Array(2), done: false &#125;；</span></span><br><span class=\"line\"><span class=\"comment\">// next.done 用于指示迭代器是否完成：在每次迭代时进行更新而且都是false，</span></span><br><span class=\"line\"><span class=\"comment\">// 直到迭代器结束done才是true。</span></span><br><span class=\"line\"><span class=\"comment\">// next.value是一个[&quot;key&quot;,&quot;value&quot;]的数组，是返回的迭代器中的元素值。</span></span><br></pre></td></tr></table></figure></li>\n<li><p><code>iterator.next方法运行</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> iter = arr.entries();</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// for(var i=0; i&lt; arr.length; i++)&#123;   // 实际使用的是这个 </span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt; arr.length+<span class=\"number\">1</span>; i++)&#123;    <span class=\"comment\">// 注意，是length+1，比数组的长度大</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> tem = iter.next();             <span class=\"comment\">// 每次迭代时更新next</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(tem.done);             <span class=\"comment\">// 这里可以看到更新后的done都是false</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tem.done !== <span class=\"literal\">true</span>)&#123;             <span class=\"comment\">// 遍历迭代器结束done才是true</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(tem.value);</span><br><span class=\"line\">        a[i]=tem.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);                         <span class=\"comment\">// 遍历完毕，输出next.value的数组</span></span><br></pre></td></tr></table></figure></li>\n<li><p><code>二维数组按行排序</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sortArr</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> goNext = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> entries = arr.entries();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (goNext) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result = entries.next();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result.done !== <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            result.value[<span class=\"number\">1</span>].sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b);</span><br><span class=\"line\">            goNext = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            goNext = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [[<span class=\"number\">1</span>,<span class=\"number\">34</span>],[<span class=\"number\">456</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">44</span>,<span class=\"number\">234</span>],[<span class=\"number\">4567</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>],[<span class=\"number\">34</span>,<span class=\"number\">78</span>,<span class=\"number\">23</span>,<span class=\"number\">1</span>]];</span><br><span class=\"line\">sortArr(arr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*(4) [Array(2), Array(5), Array(5), Array(4)]</span></span><br><span class=\"line\"><span class=\"comment\">    0:(2) [1, 34]</span></span><br><span class=\"line\"><span class=\"comment\">    1:(5) [2, 3, 44, 234, 456]</span></span><br><span class=\"line\"><span class=\"comment\">    2:(5) [1, 4, 5, 6, 4567]</span></span><br><span class=\"line\"><span class=\"comment\">    3:(4) [1, 23, 34, 78]</span></span><br><span class=\"line\"><span class=\"comment\">    length:4</span></span><br><span class=\"line\"><span class=\"comment\">    __proto__:Array(0)</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></li>\n<li><p><code>使用for…of 循环</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> iterator = arr.entries();</span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> e <span class=\"keyword\">of</span> iterator) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [0, &quot;a&quot;]</span></span><br><span class=\"line\"><span class=\"comment\">// [1, &quot;b&quot;]</span></span><br><span class=\"line\"><span class=\"comment\">// [2, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第06节：koa-bodyparser中间件\"><a href=\"#第06节：koa-bodyparser中间件\" class=\"headerlink\" title=\"第06节：koa-bodyparser中间件\"></a>第06节：koa-bodyparser中间件</h2><p>对于POST请求的处理，koa-bodyparser中间件可以把koa2上下文的formData数据解析到ctx.request.body中。</p>\n<ul>\n<li><p><strong>安装中间件</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用npm进行安装，需要注意的是我们这里要用–save，因为它在生产环境中需要使用。</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm install --save koa-bodyparser@3</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>引入使用</strong></p>\n<p>安装完成后，需要在代码中引入并使用。我们在代码顶部用require进行引入。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-bodyparser&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>然后进行使用，如果不使用是没办法调用的，使用代码如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(bodyParser())</span><br></pre></td></tr></table></figure>\n\n<p>在代码中使用后，直接可以用<code>ctx.request.body</code>进行获取POST请求参数，中间件自动给我们作了解析。</p>\n</li>\n<li><p>用例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Post请求解析中间件   koa-bodyparser</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ./bodyparser_demo.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-bodyparser&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\">app.use(bodyParser())</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 当请求是GET请求，显示表单让用户填写</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ctx.url === <span class=\"string\">&#x27;/&#x27;</span> &amp;&amp; ctx.method === <span class=\"string\">&#x27;GET&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> html = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">      &lt;h1&gt;Koa2 request post demo&lt;/h1&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;form method=&#x27;POST&#x27; action=&#x27;/&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;p&gt;userName&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;input name=&quot;userName&quot;/&gt; &lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;p&gt;age&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;input name=&quot;age&quot;/&gt; &lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;p&gt;webSite&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;input name=&#x27;webSite&#x27;/&gt;&lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/form&gt;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\">    ctx.body = html</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ctx.url === <span class=\"string\">&#x27;/&#x27;</span> &amp;&amp; ctx.method === <span class=\"string\">&#x27;POST&#x27;</span>) &#123;  <span class=\"comment\">// 当请求时POST请求时</span></span><br><span class=\"line\">    <span class=\"comment\">// ctx.body = &#x27;接收到POST请求&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> postData= ctx.request.body</span><br><span class=\"line\">    ctx.body = postData</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;    <span class=\"comment\">// 其他请求显示404报错</span></span><br><span class=\"line\">    ctx.body = <span class=\"string\">&#x27;&lt;h1&gt;404 page!&lt;/h1&gt;&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第07节：Koa2原生路由实现\"><a href=\"#第07节：Koa2原生路由实现\" class=\"headerlink\" title=\"第07节：Koa2原生路由实现\"></a>第07节：Koa2原生路由实现</h2><ul>\n<li><p><code>ctx.request.url</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ctx.request.url</span></span><br><span class=\"line\"><span class=\"comment\">// 地址栏输入的路径，然后根据路径的不同进行跳转</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> url = ctx.request.url</span><br><span class=\"line\">  ctx.body = url</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 访问http://127.0.0.1:3000/jspang/18 页面会输出/jspang/18</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>Koa2原生路由实现</strong></p>\n<p>原生路由的实现需要引入fs模块来读取文件。然后再根据路由的路径去读取，最后返回给页面，进行渲染。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Koa2原生路由实现</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ctx.request.url</span></span><br><span class=\"line\"><span class=\"comment\">// 地址栏输入的路径，然后根据路径的不同进行跳转</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">page</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pageUrl = <span class=\"string\">`./page/<span class=\"subst\">$&#123;page&#125;</span>`</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取文件地址 读取文件</span></span><br><span class=\"line\">    fs.readFile(pageUrl, <span class=\"string\">&quot;binary&quot;</span>, <span class=\"function\">(<span class=\"params\">error, data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">        reject(error)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        resolve(data)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">route</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> page = <span class=\"string\">&#x27;404.html&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (url) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;/&#x27;</span>:</span><br><span class=\"line\">      page = <span class=\"string\">&#x27;index.html&#x27;</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;/index&#x27;</span>:</span><br><span class=\"line\">      page = <span class=\"string\">&#x27;index.html&#x27;</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;/todo&#x27;</span>:</span><br><span class=\"line\">      page = <span class=\"string\">&#x27;todo.html&#x27;</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;/404&#x27;</span>:</span><br><span class=\"line\">      page = <span class=\"string\">&#x27;404.html&#x27;</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"attr\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> html = <span class=\"keyword\">await</span> render(page)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> html</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> url = ctx.request.url</span><br><span class=\"line\">  <span class=\"keyword\">let</span> html = <span class=\"keyword\">await</span> route(url)</span><br><span class=\"line\">  ctx.body = html</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第08节：Koa-router中间件（1）入门\"><a href=\"#第08节：Koa-router中间件（1）入门\" class=\"headerlink\" title=\"第08节：Koa-router中间件（1）入门\"></a>第08节：Koa-router中间件（1）入门</h2><p>安装koa-router中间件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装koa-router中间件</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm install --save koa-router</span><br></pre></td></tr></table></figure>\n\n<p>基础案例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Koa-router</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ./koa-router1.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> Router = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-router&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> Router()</span><br><span class=\"line\"></span><br><span class=\"line\">router</span><br><span class=\"line\">  .get(<span class=\"string\">&#x27;/&#x27;</span>, <span class=\"function\">(<span class=\"params\">ctx, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    ctx.body = <span class=\"string\">&#x27;Hello Koa-router&#x27;</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .get(<span class=\"string\">&#x27;/todo&#x27;</span>, <span class=\"function\">(<span class=\"params\">ctx, next</span>) =&gt;</span> &#123;   <span class=\"comment\">// 路由多页面配置</span></span><br><span class=\"line\">    ctx.body = <span class=\"string\">&#x27;Todo page!&#x27;</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 挂载路由</span></span><br><span class=\"line\">app.use(router.routes())</span><br><span class=\"line\">  .use(router.allowedMethods())</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"第09节：Koa-router中间件（2）层级\"><a href=\"#第09节：Koa-router中间件（2）层级\" class=\"headerlink\" title=\"第09节：Koa-router中间件（2）层级\"></a>第09节：Koa-router中间件（2）层级</h2><ul>\n<li><p><strong>设置前缀</strong></p>\n<p>有时候我们想把所有的路径前面都再加入一个级别，比如原来我们访问的路径是<code>http://127.0.0.1:3000/todo</code>，现在我们希望在所有的路径前面都加上一个jspang层级，把路径变成<code>http://127.0.0.1:3000/jspang/todo.</code>这时候就可以使用层级来完成这个功能。路由在创建的时候是可以指定一个前缀的，这个前缀会被至于路由的最顶层，也就是说，这个路由的所有请求都是相对于这个前缀的.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> Router(&#123;</span><br><span class=\"line\">    <span class=\"attr\">prefix</span>:<span class=\"string\">&#x27;/jspang&#x27;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p>设置层级</p>\n<p>设置前缀一般都是全局的，并不能实现路由的层级，如果你想为单个页面设置层级，也是很简单的。只要在use时使用路径就可以了。</p>\n<p>例如这种写法装载路由层级，这里的router相当于父级：<code>router.use(‘/page’, page.routes(), page.allowedMethods())</code>。</p>\n<p>通过这种写法的好处是并不是全局的，我们可以给不同的路由加层级。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Koa-router 层级</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ./koa-router2.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> Router = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-router&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\"><span class=\"comment\">// const router = new Router(&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   // prefix: &#x27;/jspang&#x27;  // 设置前缀</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置路由层级</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> home = <span class=\"keyword\">new</span> Router()</span><br><span class=\"line\">home</span><br><span class=\"line\">  .get(<span class=\"string\">&#x27;/jspang&#x27;</span>, <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    ctx.body = <span class=\"string\">&#x27;Home jspang&#x27;</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .get(<span class=\"string\">&#x27;/todo&#x27;</span>, <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;   <span class=\"comment\">// 路由多页面配置</span></span><br><span class=\"line\">    ctx.body = <span class=\"string\">&#x27;Home Todo&#x27;</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> page = <span class=\"keyword\">new</span> Router()</span><br><span class=\"line\">page</span><br><span class=\"line\">  .get(<span class=\"string\">&#x27;/jspang&#x27;</span>,<span class=\"function\">(<span class=\"params\">ctx, next</span>) =&gt;</span> &#123;  <span class=\"comment\">// async 异步不异步都可以</span></span><br><span class=\"line\">    ctx.body = <span class=\"string\">&#x27;Page jspang&#x27;</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .get(<span class=\"string\">&#x27;/todo&#x27;</span>,<span class=\"function\">(<span class=\"params\">ctx, next</span>) =&gt;</span> &#123;   <span class=\"comment\">// 路由多页面配置</span></span><br><span class=\"line\">    ctx.body = <span class=\"string\">&#x27;Page Todo&#x27;</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 装载所有子路由  router.use(‘/page’, page.routes(), page.allowedMethods())</span></span><br><span class=\"line\"><span class=\"comment\">// 设置父路由</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> router = <span class=\"keyword\">new</span> Router()</span><br><span class=\"line\">router.use(<span class=\"string\">&#x27;/home&#x27;</span>, home.routes(), home.allowedMethods())</span><br><span class=\"line\">router.use(<span class=\"string\">&#x27;/page&#x27;</span>, page.routes(), page.allowedMethods())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 挂载路由中间件</span></span><br><span class=\"line\">app.use(router.routes())</span><br><span class=\"line\">  .use(router.allowedMethods())</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第10节：Koa-router中间件（3）参数\"><a href=\"#第10节：Koa-router中间件（3）参数\" class=\"headerlink\" title=\"第10节：Koa-router中间件（3）参数\"></a>第10节：Koa-router中间件（3）参数</h2><ul>\n<li><p>获取传递参数 <code>ctx.query来进行接收</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Koa-router 参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ./koa-router3.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> Router = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-router&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> Router()</span><br><span class=\"line\"></span><br><span class=\"line\">router</span><br><span class=\"line\">  .get(<span class=\"string\">&#x27;/&#x27;</span>, <span class=\"function\">(<span class=\"params\">ctx, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取 get 请求参数</span></span><br><span class=\"line\">    ctx.body = ctx.query</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 挂载路由中间件</span></span><br><span class=\"line\">app.use(router.routes())</span><br><span class=\"line\">  .use(router.allowedMethods())</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 地址栏输出 http://127.0.0.1:3000/?user=jspang&amp;age=18</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">  &quot;user&quot;: &quot;jspang&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">  &quot;age&quot;: &quot;18&quot;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第11节：Koa2中使用cookie\"><a href=\"#第11节：Koa2中使用cookie\" class=\"headerlink\" title=\"第11节：Koa2中使用cookie\"></a>第11节：Koa2中使用cookie</h2><ul>\n<li><p><code>ctx.cookies.get(name,[optins])</code>: 读取上下文请求中的cookie。</p>\n</li>\n<li><p><code>ctx.cookies.set(name,value,[options])</code>：在上下文中写入cookie</p>\n</li>\n<li><p><strong>写入<code>Cookies</code></strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.cookies.set(<span class=\"string\">&#x27;name&#x27;</span>, <span class=\"string\">&#x27;jspang&#x27;</span>)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>Cookie选项</strong></p>\n<ul>\n<li>比如我们要存储用户名，保留用户登录状态时，你可以选择7天内不用登录，也可以选择30天内不用登录。这就需要在写入是配置一些选项：</li>\n<li><code>domain</code>：写入cookie所在的域名</li>\n<li><code>path</code>：写入cookie所在的路径</li>\n<li><code>maxAge</code>：Cookie最大有效时长</li>\n<li><code>expires</code>：cookie失效时间</li>\n<li><code>httpOnly</code>:是否只用http请求中获得</li>\n<li><code>overwirte</code>：是否允许重写</li>\n</ul>\n</li>\n<li><p><strong>读取<code>cookies</code></strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.cookies.get(<span class=\"string\">&#x27;name&#x27;</span>)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第12节：Koa2的模板初识（ejs）\"><a href=\"#第12节：Koa2的模板初识（ejs）\" class=\"headerlink\" title=\"第12节：Koa2的模板初识（ejs）\"></a>第12节：Koa2的模板初识（ejs）</h2><p>开发中不可能把所有的html代码全部卸载JS里，这显然不现实，也没办法完成大型web开发。必须借用模板机制来帮助我们开发，这节课我们就简单了解一下Koa2的模板机制，koa2的目标机制要依靠中间件来完成开发。</p>\n<ul>\n<li><p><strong>安装中间件</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装中间件</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm install --save koa-views</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>安装ejs模板引擎</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装ejs模板引擎</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm install --save ejs</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>编写模板</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为了模板统一管理，我们新建一个view的文件夹，并在它下面新建index.ejs文件。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ./views/index.ejs</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class=\"line\">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;&lt;%= title%&gt;&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;</span><br><span class=\"line\">    &lt;p&gt;EJS Welcome to &lt;%= title %&gt;&lt;/p&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>编写Koa文件</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ejs模板</span></span><br><span class=\"line\"><span class=\"comment\">// ./ejs_demo.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> views = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-views&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加载模板引擎</span></span><br><span class=\"line\">app.use(views(path.join(__dirname, <span class=\"string\">&#x27;./views&#x27;</span>), &#123;</span><br><span class=\"line\">  <span class=\"attr\">extension</span>: <span class=\"string\">&#x27;ejs&#x27;</span></span><br><span class=\"line\">&#125;))</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> title = <span class=\"string\">&#x27;HELLO Koa2&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> ctx.render(<span class=\"string\">&#x27;index&#x27;</span>, &#123;</span><br><span class=\"line\">    title</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第13节：koa-static静态资源中间件\"><a href=\"#第13节：koa-static静态资源中间件\" class=\"headerlink\" title=\"第13节：koa-static静态资源中间件\"></a>第13节：koa-static静态资源中间件</h2><p>在后台开发中不仅有需要代码处理的业务逻辑请求，也会有很多的静态资源请求。比如请求js，css，jpg，png这些静态资源请求。也非常的多，有些时候还会访问静态资源路径。用koa2自己些这些静态资源访问是完全可以的，但是代码会雍长一些。所以这节课我们利用koa-static中间件来实现静态资源的访问。</p>\n<ul>\n<li><p>安装<code>koa-static</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save koa-static</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>新建static文件夹</strong> 然后在static文件中放入图片，css和js文件</p>\n</li>\n<li><p>使用<code>koa-static</code>中间件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">static</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-static&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明静态路径</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> staticPath = <span class=\"string\">&#x27;./static&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">static</span>(</span><br><span class=\"line\">    path.join(__dirname, staticPath)</span><br><span class=\"line\">))</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx) =&gt; &#123;</span><br><span class=\"line\">    ctx.body = <span class=\"string\">&#x27;hello world&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 访问图片直接 http://127.0.0.1:3000/koa2.jpg</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h1 id=\"Koa2入门小基础\"><a href=\"#Koa2入门小基础\" class=\"headerlink\" title=\"Koa2入门小基础\"></a>Koa2入门小基础</h1><p>学习指导：<a href=\"http://www.jspang.com/posts/2017/11/13/koa2.html\">挑战全栈 Koa2免费视频教程 (共13集)</a></p>\n<p>Koa2是现在最流行的基于Node.js平台的web开发框架，它很小，但扩展性很强。Koa给人一种干净利落的感觉，体积小、编程方式干净。</p>\n<blockquote>\n<p>使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。一个Koa应用就是一个对象，包含了一个middleware数组，这个数组由一组Generator函数组成。这些函数负责对HTTP请求进行各种加工，比如生成缓存、指定代理、请求重定向等等。这些中间件函数基于 request 请求以一个类似于栈的结构组成并依次执行。</p>\n</blockquote>\n<h2 id=\"第01节：Koa开发环境搭建\"><a href=\"#第01节：Koa开发环境搭建\" class=\"headerlink\" title=\"第01节：Koa开发环境搭建\"></a>第01节：Koa开发环境搭建</h2><p>作Koa2的开发，它要求Node.js版本高于V7.6。</p>\n<blockquote>\n<p>::: warning 注意事项<br>请确保你的 Node.js 版本 &gt;= 7.6。<br>:::</p>\n</blockquote>\n<h3 id=\"搭建环境\"><a href=\"#搭建环境\" class=\"headerlink\" title=\"搭建环境\"></a>搭建环境</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> code  //进入code文件夹</span><br><span class=\"line\">mkdir koa2-demo //创建koa2-demo文件夹</span><br><span class=\"line\"><span class=\"built_in\">cd</span> koa2-demo  //进入koa2-demo文件夹</span><br><span class=\"line\"></span><br><span class=\"line\">npm init -y // 初始化生产package.json 文件</span><br><span class=\"line\">npm install --save koa // 安装koa</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"与君初相识\"><a href=\"#与君初相识\" class=\"headerlink\" title=\"与君初相识\"></a>与君初相识</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 根目录下创建 index.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx) =&gt; &#123;</span><br><span class=\"line\">    ctx.body = <span class=\"string\">&#x27;Hello Koa2&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] start-quick is starting at port 3000&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 运行 node index.js</span></span><br><span class=\"line\"><span class=\"comment\">// 浏览器中输入：http://127.0.0.1:3000 就可以看到结果了</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第02节：async-await的使用方法\"><a href=\"#第02节：async-await的使用方法\" class=\"headerlink\" title=\"第02节：async/await的使用方法\"></a>第02节：async/await的使用方法</h2><h3 id=\"什么是async和await\"><a href=\"#什么是async和await\" class=\"headerlink\" title=\"什么是async和await\"></a>什么是async和await</h3><p>async是异步的简写，而await可以堪称async wait的简写。</p>\n<p>明白了两个单词，就很好理解了async是声明一个方法是异步的，await是等待异步方法完成。</p>\n<p>注意的是await必须在async方法中才可以使用因为await访问本身就会造成程序停止堵塞，所以必须在异步方法中才可以使用。</p>\n<ul>\n<li><p><strong>async到底起什么作用</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// async是让方法变成异步，这个很好理解，关键是他的返回值是什么？我们得到后如何处理？</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ./demo01.js</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testAsync</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Hello Async&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> result = testAsync()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result)  <span class=\"comment\">// Promise &#123; &#x27;Hello Async&#x27; &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输出了Promise &#123; ‘Hello Async’ &#125;，这时候会发现它返回的是Promise</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>await在等什么？</strong></p>\n<p>await一般在等待async方法执行完毕，但是其实await等待的只是一个表达式，这个表达式在官方文档里说的是Promise对象，可是它也可以接受普通值。</p>\n<p><strong>await必须在async方法中才可以使用</strong></p>\n<p><strong>await接收Promise对象，也可以接收普通值</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./demo02.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSomething</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;something&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">testAsync</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&#x27;Hello Async&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res1 = <span class=\"keyword\">await</span> getSomething()</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res2 = <span class=\"keyword\">await</span> testAsync()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res1, res2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行</span></span><br><span class=\"line\">test()  <span class=\"comment\">// something Hello Async</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"async-await同时使用\"><a href=\"#async-await同时使用\" class=\"headerlink\" title=\"async/await同时使用\"></a>async/await同时使用</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./demo03.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">takeLongTime</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"params\">resolve</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            resolve(<span class=\"string\">&#x27;long_time_value&#x27;</span>)</span><br><span class=\"line\">        &#125;, <span class=\"number\">2000</span>);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = <span class=\"keyword\">await</span> takeLongTime()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(res)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">test()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等待2秒钟， 输出 long_time_value</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"第03节：Get请求的接收\"><a href=\"#第03节：Get请求的接收\" class=\"headerlink\" title=\"第03节：Get请求的接收\"></a>第03节：Get请求的接收</h2><ul>\n<li><p>在koa2中GET请求通过request接收，但是接受的方法有两种：query和querystring。</p>\n<ul>\n<li>query：返回的是格式化好的参数对象。</li>\n<li>querystring：返回的是请求字符串。</li>\n</ul>\n</li>\n<li><p>从 <code>ctx.request</code> 中获取Get请求</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  在koa2中GET请求通过request接收，但是接受的方法有两种：query和querystring。</span></span><br><span class=\"line\"><span class=\"comment\"> *  query：返回的是格式化好的参数对象。</span></span><br><span class=\"line\"><span class=\"comment\"> *  querystring：返回的是请求字符串。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ./ get_demo.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 上下文得到url对象</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> url = ctx.url</span><br><span class=\"line\">    <span class=\"keyword\">let</span> request = ctx.request</span><br><span class=\"line\">    <span class=\"keyword\">let</span> req_query = request.query</span><br><span class=\"line\">    <span class=\"keyword\">let</span> req_querystring = request.querystring</span><br><span class=\"line\">    ctx.body = &#123;</span><br><span class=\"line\">        url,</span><br><span class=\"line\">        req_query,</span><br><span class=\"line\">        req_querystring</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 启动一切正常可在浏览器中使用http://127.0.0.1:3000?user=jspang&amp;age=18来进行访问</span></span><br><span class=\"line\"><span class=\"comment\">// &#123;&quot;url&quot;:&quot;/?user=jspang&amp;age=18&quot;,&quot;req_query&quot;:&#123;&quot;user&quot;:&quot;jspang&quot;,&quot;age&quot;:&quot;18&quot;&#125;,&quot;req_querystring&quot;:&quot;user=jspang&amp;age=18&quot;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// query是一个对象，而querystring就是一个普通的字符串。</span></span><br></pre></td></tr></table></figure></li>\n<li><p>从<code>ctx</code>中得到GET请求。<code>ctx</code>中也分为query和querystring</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从ctx中得到GET请求。ctx中也分为query和querystring</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">//从request中获取GET请求</span></span><br><span class=\"line\">    <span class=\"comment\">// 上下文得到url对象</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> url = ctx.url</span><br><span class=\"line\">    <span class=\"keyword\">let</span> request = ctx.request</span><br><span class=\"line\">    <span class=\"keyword\">let</span> req_query = request.query</span><br><span class=\"line\">    <span class=\"keyword\">let</span> req_querystring = request.querystring</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//从上下文中直接获取</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> ctx_query = ctx.query</span><br><span class=\"line\">    <span class=\"keyword\">let</span> ctx_querystring = ctx.querystring</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.body = &#123;</span><br><span class=\"line\">        url,</span><br><span class=\"line\">        req_query,</span><br><span class=\"line\">        req_querystring,</span><br><span class=\"line\">        ctx_query,</span><br><span class=\"line\">        ctx_querystring</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> // 20190813114559</span></span><br><span class=\"line\"><span class=\"comment\">// http://127.0.0.1:3000/?user=jspang&amp;age=18</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">  &quot;url&quot;: &quot;/?user=jspang&amp;age=18&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">  &quot;req_query&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    &quot;user&quot;: &quot;jspang&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">    &quot;age&quot;: &quot;18&quot;</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;,</span></span><br><span class=\"line\"><span class=\"comment\">  &quot;req_querystring&quot;: &quot;user=jspang&amp;age=18&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">  &quot;ctx_query&quot;: &#123;</span></span><br><span class=\"line\"><span class=\"comment\">    &quot;user&quot;: &quot;jspang&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">    &quot;age&quot;: &quot;18&quot;</span></span><br><span class=\"line\"><span class=\"comment\">  &#125;,</span></span><br><span class=\"line\"><span class=\"comment\">  &quot;ctx_querystring&quot;: &quot;user=jspang&amp;age=18&quot;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br></pre></td></tr></table></figure></li>\n<li><p>总结：获得GET请求的方式有两种，一种是从request中获得，一种是一直从上下文中获得。</p>\n</li>\n<li><p>获得的格式也有两种：query和querystring。</p>\n</li>\n</ul>\n<h2 id=\"第04节：POST请求如何接收（1）\"><a href=\"#第04节：POST请求如何接收（1）\" class=\"headerlink\" title=\"第04节：POST请求如何接收（1）\"></a>第04节：POST请求如何接收（1）</h2><ul>\n<li><p>对于POST请求的处理，Koa2没有封装方便的获取参数的方法，需要通过解析上下文context中的原生node.js请求对象req来获取。</p>\n</li>\n<li><p><strong>获取Post请求的步骤：</strong></p>\n</li>\n</ul>\n<ol>\n<li>解析上下文ctx中的原生nodex.js对象req。</li>\n<li>将POST表单数据解析成query string-字符串.(例如:user=jspang&amp;age=18)</li>\n<li>将字符串转换成JSON格式。</li>\n</ol>\n<ul>\n<li><strong>ctx.request和ctx.req的区别</strong></li>\n</ul>\n<ol>\n<li>ctx.request: 是Koa2中context经过封装的请求对象，它用起来更直观和简单。</li>\n<li>ctx.req: 是context提供的node.js原生HTTP请求对象。这个虽然不那么直观，但是可以得到更多的内容，适合我们深度编程。</li>\n</ol>\n<ul>\n<li><p><strong>ctx.method 得到请求类型</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ctx.method 得到请求类型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Koa2中提供了ctx.method属性，可以轻松的得到请求的类型，</span></span><br><span class=\"line\"><span class=\"comment\">// 然后根据请求类型编写不同的相应方法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ./post_demo01.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 当请求是GET请求，显示表单让用户填写</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ctx.url === <span class=\"string\">&#x27;/&#x27;</span> &amp;&amp; ctx.method === <span class=\"string\">&#x27;GET&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> html = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">      &lt;h1&gt;Koa2 request post demo&lt;/h1&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;form method=&#x27;POST&#x27; action=&#x27;/&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;p&gt;userName&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;input name=&quot;userName&quot;/&gt; &lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;p&gt;age&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;input name=&quot;age&quot;/&gt; &lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;p&gt;webSite&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;input name=&#x27;webSite&#x27;/&gt;&lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/form&gt;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\">    ctx.body = html</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ctx.url === <span class=\"string\">&#x27;/&#x27;</span> &amp;&amp; ctx.method === <span class=\"string\">&#x27;POST&#x27;</span>) &#123;  <span class=\"comment\">// 当请求时POST请求时</span></span><br><span class=\"line\">    ctx.body = <span class=\"string\">&#x27;接收到请求&#x27;</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;    <span class=\"comment\">// 其他请求显示404报错</span></span><br><span class=\"line\">    ctx.body = <span class=\"string\">&#x27;&lt;h1&gt;404 page!&lt;/h1&gt;&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">浏览器中输入http://127.0.0.1:3000进行查看，</span></span><br><span class=\"line\"><span class=\"comment\">  第一次进入时给我们展现的是一个表单页面，</span></span><br><span class=\"line\"><span class=\"comment\">  我们点击提交后可以看到服务器接收到了我们的信息，但我们并没有做出任何处理。</span></span><br><span class=\"line\"><span class=\"comment\">  当我们下输入一个地址时，它会提示404错误。</span></span><br><span class=\"line\"><span class=\"comment\">* */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// **总结：**从理论上讲解了如何获取POST请求参数</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第05节：POST请求如何接收（2）\"><a href=\"#第05节：POST请求如何接收（2）\" class=\"headerlink\" title=\"第05节：POST请求如何接收（2）\"></a>第05节：POST请求如何接收（2）</h2><ul>\n<li><p><strong>解析Node原生POST参数</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./post_demo2.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解析Node原生POST参数</span></span><br><span class=\"line\"><span class=\"comment\">// 声明一个方法，然后用Promise对象进行解析。这里我们使用了ctx.req.on来接收事件</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parsePostData</span>(<span class=\"params\">ctx</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> postdata = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">      ctx.req.on(<span class=\"string\">&#x27;data&#x27;</span>, <span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        postdata += data</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">      ctx.req.addListener(<span class=\"string\">&#x27;end&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        resolve(postdata)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>&#123;</span><br><span class=\"line\">      reject(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>修改在上节课接收POST请求的处理方法里，修改代码如下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ctx.body = &#x27;接收到POST请求&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> postdata = <span class=\"keyword\">await</span> parsePostData(ctx)  <span class=\"comment\">// userName=jspang&amp;age=123&amp;webSite=www.douban.com</span></span><br><span class=\"line\">ctx.body = postdata</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 页面就输出刚才填的表单  userName=jspang&amp;age=123&amp;webSite=www.douban.com</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>POST字符串解析JSON对象</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ./post_demo2.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// POST字符串解析JSON对象</span></span><br><span class=\"line\"><span class=\"comment\">// 字符串封装JSON兑现对象的方法</span></span><br><span class=\"line\"><span class=\"comment\">// userName=jspang&amp;age=123&amp;webSite=www.douban.com</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parseQueryStr</span>(<span class=\"params\">queryStr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> queryData = &#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">// split() 方法使用指定的分隔符字符串将一个String对象分割成字符串数组，</span></span><br><span class=\"line\">  <span class=\"comment\">// 以将字符串分隔为子字符串，以确定每个拆分的位置。 </span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> queryStrList = queryStr.split(<span class=\"string\">&#x27;&amp;&#x27;</span>)</span><br><span class=\"line\">  <span class=\"comment\">// console.log(queryStrList)</span></span><br><span class=\"line\">  <span class=\"comment\">// entries() 方法返回一个新的Array Iterator对象，该对象包含数组中每个索引的键/值对</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [index, queryStrItem] <span class=\"keyword\">of</span> queryStrList.entries()) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> itemList = queryStrItem.split(<span class=\"string\">&#x27;=&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// console.log(itemList)</span></span><br><span class=\"line\">    queryData[itemList[<span class=\"number\">0</span>]] = itemList[<span class=\"number\">1</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> queryData</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在上述解析Node原生POST参数中修改</span></span><br><span class=\"line\">ctx.req.addListener(<span class=\"string\">&#x27;end&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// resolve(postdata)</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> parseData = parseQueryStr(postdata)</span><br><span class=\"line\">    resolve(parseData)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">使用for…of 循环</span></span><br><span class=\"line\"><span class=\"comment\">var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];</span></span><br><span class=\"line\"><span class=\"comment\">var iterator = arr.entries();</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">for (let e of iterator) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">  console.log(e);</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">// [0, &quot;a&quot;] </span></span><br><span class=\"line\"><span class=\"comment\">// [1, &quot;b&quot;] </span></span><br><span class=\"line\"><span class=\"comment\">// [2, &quot;c&quot;]</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// node运行，浏览器http://127.0.0.1:3000，先填写表单，然后页面就会返回</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">  &quot;userName&quot;: &quot;jspang&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">  &quot;age&quot;: &quot;123&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">  &quot;webSite&quot;: &quot;www.douban.com&quot;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></li>\n<li><p>完整代码见<code>post_demo2.js</code></p>\n</li>\n</ul>\n<h2 id=\"扩展-Array-entries方法精讲\"><a href=\"#扩展-Array-entries方法精讲\" class=\"headerlink\" title=\"[扩展]Array/entries方法精讲\"></a>[扩展]Array/entries方法精讲</h2><ul>\n<li><p>参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/entries\">Array/entries</a></p>\n</li>\n<li><p><code>**entries()**</code> 方法返回一个新的<strong>Array Iterator</strong>对象，该对象包含数组中每个索引的键/值对。</p>\n</li>\n<li><blockquote>\n<p>arr.entries()</p>\n</blockquote>\n<p>返回值是 一个新的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Array\"><code>Array</code></a> 迭代器对象。<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-createarrayiterator\">Array Iterator</a>是对象，它的原型（<strong>proto</strong>:Array Iterator）上有一个<a href=\"http://www.ecma-international.org/ecma-262/6.0/#sec-%arrayiteratorprototype%.next\">next</a>方法，可用用于遍历迭代器取得原数组的[key,value]。</p>\n</li>\n<li><p><code>Array Iterator</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> iterator = arr.entries();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*Array Iterator &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">         __proto__:Array Iterator</span></span><br><span class=\"line\"><span class=\"comment\">         next:ƒ next()</span></span><br><span class=\"line\"><span class=\"comment\">         Symbol(Symbol.toStringTag):&quot;Array Iterator&quot;</span></span><br><span class=\"line\"><span class=\"comment\">         __proto__:Object</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></li>\n<li><p><code>iterator.next()</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>]; </span><br><span class=\"line\"><span class=\"keyword\">var</span> iterator = arr.entries();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(iterator.next());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*&#123;value: Array(2), done: false&#125;</span></span><br><span class=\"line\"><span class=\"comment\">          done:false</span></span><br><span class=\"line\"><span class=\"comment\">          value:(2) [0, &quot;a&quot;]</span></span><br><span class=\"line\"><span class=\"comment\">           __proto__: Object</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"comment\">// iterator.next()返回一个对象，对于有元素的数组，</span></span><br><span class=\"line\"><span class=\"comment\">// 是next&#123; value: Array(2), done: false &#125;；</span></span><br><span class=\"line\"><span class=\"comment\">// next.done 用于指示迭代器是否完成：在每次迭代时进行更新而且都是false，</span></span><br><span class=\"line\"><span class=\"comment\">// 直到迭代器结束done才是true。</span></span><br><span class=\"line\"><span class=\"comment\">// next.value是一个[&quot;key&quot;,&quot;value&quot;]的数组，是返回的迭代器中的元素值。</span></span><br></pre></td></tr></table></figure></li>\n<li><p><code>iterator.next方法运行</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> iter = arr.entries();</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = [];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// for(var i=0; i&lt; arr.length; i++)&#123;   // 实际使用的是这个 </span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt; arr.length+<span class=\"number\">1</span>; i++)&#123;    <span class=\"comment\">// 注意，是length+1，比数组的长度大</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> tem = iter.next();             <span class=\"comment\">// 每次迭代时更新next</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(tem.done);             <span class=\"comment\">// 这里可以看到更新后的done都是false</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(tem.done !== <span class=\"literal\">true</span>)&#123;             <span class=\"comment\">// 遍历迭代器结束done才是true</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(tem.value);</span><br><span class=\"line\">        a[i]=tem.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a);                         <span class=\"comment\">// 遍历完毕，输出next.value的数组</span></span><br></pre></td></tr></table></figure></li>\n<li><p><code>二维数组按行排序</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sortArr</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> goNext = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> entries = arr.entries();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (goNext) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result = entries.next();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result.done !== <span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            result.value[<span class=\"number\">1</span>].sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a - b);</span><br><span class=\"line\">            goNext = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            goNext = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [[<span class=\"number\">1</span>,<span class=\"number\">34</span>],[<span class=\"number\">456</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">44</span>,<span class=\"number\">234</span>],[<span class=\"number\">4567</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>],[<span class=\"number\">34</span>,<span class=\"number\">78</span>,<span class=\"number\">23</span>,<span class=\"number\">1</span>]];</span><br><span class=\"line\">sortArr(arr);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*(4) [Array(2), Array(5), Array(5), Array(4)]</span></span><br><span class=\"line\"><span class=\"comment\">    0:(2) [1, 34]</span></span><br><span class=\"line\"><span class=\"comment\">    1:(5) [2, 3, 44, 234, 456]</span></span><br><span class=\"line\"><span class=\"comment\">    2:(5) [1, 4, 5, 6, 4567]</span></span><br><span class=\"line\"><span class=\"comment\">    3:(4) [1, 23, 34, 78]</span></span><br><span class=\"line\"><span class=\"comment\">    length:4</span></span><br><span class=\"line\"><span class=\"comment\">    __proto__:Array(0)</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></li>\n<li><p><code>使用for…of 循环</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">&quot;a&quot;</span>, <span class=\"string\">&quot;b&quot;</span>, <span class=\"string\">&quot;c&quot;</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> iterator = arr.entries();</span><br><span class=\"line\"><span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> e <span class=\"keyword\">of</span> iterator) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [0, &quot;a&quot;]</span></span><br><span class=\"line\"><span class=\"comment\">// [1, &quot;b&quot;]</span></span><br><span class=\"line\"><span class=\"comment\">// [2, &quot;c&quot;]</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第06节：koa-bodyparser中间件\"><a href=\"#第06节：koa-bodyparser中间件\" class=\"headerlink\" title=\"第06节：koa-bodyparser中间件\"></a>第06节：koa-bodyparser中间件</h2><p>对于POST请求的处理，koa-bodyparser中间件可以把koa2上下文的formData数据解析到ctx.request.body中。</p>\n<ul>\n<li><p><strong>安装中间件</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用npm进行安装，需要注意的是我们这里要用–save，因为它在生产环境中需要使用。</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm install --save koa-bodyparser@3</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>引入使用</strong></p>\n<p>安装完成后，需要在代码中引入并使用。我们在代码顶部用require进行引入。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-bodyparser&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>然后进行使用，如果不使用是没办法调用的，使用代码如下。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">app.use(bodyParser())</span><br></pre></td></tr></table></figure>\n\n<p>在代码中使用后，直接可以用<code>ctx.request.body</code>进行获取POST请求参数，中间件自动给我们作了解析。</p>\n</li>\n<li><p>用例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Post请求解析中间件   koa-bodyparser</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ./bodyparser_demo.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> bodyParser = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-bodyparser&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\">app.use(bodyParser())</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 当请求是GET请求，显示表单让用户填写</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ctx.url === <span class=\"string\">&#x27;/&#x27;</span> &amp;&amp; ctx.method === <span class=\"string\">&#x27;GET&#x27;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> html = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">      &lt;h1&gt;Koa2 request post demo&lt;/h1&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;form method=&#x27;POST&#x27; action=&#x27;/&#x27;&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;p&gt;userName&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;input name=&quot;userName&quot;/&gt; &lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;p&gt;age&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;input name=&quot;age&quot;/&gt; &lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;p&gt;webSite&lt;/p&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;input name=&#x27;webSite&#x27;/&gt;&lt;br/&gt;</span></span><br><span class=\"line\"><span class=\"string\">        &lt;button type=&quot;submit&quot;&gt;submit&lt;/button&gt;</span></span><br><span class=\"line\"><span class=\"string\">      &lt;/form&gt;</span></span><br><span class=\"line\"><span class=\"string\">    `</span></span><br><span class=\"line\">    ctx.body = html</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (ctx.url === <span class=\"string\">&#x27;/&#x27;</span> &amp;&amp; ctx.method === <span class=\"string\">&#x27;POST&#x27;</span>) &#123;  <span class=\"comment\">// 当请求时POST请求时</span></span><br><span class=\"line\">    <span class=\"comment\">// ctx.body = &#x27;接收到POST请求&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> postData= ctx.request.body</span><br><span class=\"line\">    ctx.body = postData</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;    <span class=\"comment\">// 其他请求显示404报错</span></span><br><span class=\"line\">    ctx.body = <span class=\"string\">&#x27;&lt;h1&gt;404 page!&lt;/h1&gt;&#x27;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第07节：Koa2原生路由实现\"><a href=\"#第07节：Koa2原生路由实现\" class=\"headerlink\" title=\"第07节：Koa2原生路由实现\"></a>第07节：Koa2原生路由实现</h2><ul>\n<li><p><code>ctx.request.url</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ctx.request.url</span></span><br><span class=\"line\"><span class=\"comment\">// 地址栏输入的路径，然后根据路径的不同进行跳转</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> url = ctx.request.url</span><br><span class=\"line\">  ctx.body = url</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 访问http://127.0.0.1:3000/jspang/18 页面会输出/jspang/18</span></span><br></pre></td></tr></table></figure></li>\n<li><p><strong>Koa2原生路由实现</strong></p>\n<p>原生路由的实现需要引入fs模块来读取文件。然后再根据路由的路径去读取，最后返回给页面，进行渲染。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Koa2原生路由实现</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ctx.request.url</span></span><br><span class=\"line\"><span class=\"comment\">// 地址栏输入的路径，然后根据路径的不同进行跳转</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">render</span>(<span class=\"params\">page</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> pageUrl = <span class=\"string\">`./page/<span class=\"subst\">$&#123;page&#125;</span>`</span></span><br><span class=\"line\">    <span class=\"comment\">// 获取文件地址 读取文件</span></span><br><span class=\"line\">    fs.readFile(pageUrl, <span class=\"string\">&quot;binary&quot;</span>, <span class=\"function\">(<span class=\"params\">error, data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (error) &#123;</span><br><span class=\"line\">        reject(error)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        resolve(data)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">route</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> page = <span class=\"string\">&#x27;404.html&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (url) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;/&#x27;</span>:</span><br><span class=\"line\">      page = <span class=\"string\">&#x27;index.html&#x27;</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;/index&#x27;</span>:</span><br><span class=\"line\">      page = <span class=\"string\">&#x27;index.html&#x27;</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;/todo&#x27;</span>:</span><br><span class=\"line\">      page = <span class=\"string\">&#x27;todo.html&#x27;</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">&#x27;/404&#x27;</span>:</span><br><span class=\"line\">      page = <span class=\"string\">&#x27;404.html&#x27;</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"attr\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">break</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> html = <span class=\"keyword\">await</span> render(page)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> html</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> url = ctx.request.url</span><br><span class=\"line\">  <span class=\"keyword\">let</span> html = <span class=\"keyword\">await</span> route(url)</span><br><span class=\"line\">  ctx.body = html</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第08节：Koa-router中间件（1）入门\"><a href=\"#第08节：Koa-router中间件（1）入门\" class=\"headerlink\" title=\"第08节：Koa-router中间件（1）入门\"></a>第08节：Koa-router中间件（1）入门</h2><p>安装koa-router中间件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装koa-router中间件</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm install --save koa-router</span><br></pre></td></tr></table></figure>\n\n<p>基础案例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Koa-router</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ./koa-router1.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> Router = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-router&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> Router()</span><br><span class=\"line\"></span><br><span class=\"line\">router</span><br><span class=\"line\">  .get(<span class=\"string\">&#x27;/&#x27;</span>, <span class=\"function\">(<span class=\"params\">ctx, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    ctx.body = <span class=\"string\">&#x27;Hello Koa-router&#x27;</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .get(<span class=\"string\">&#x27;/todo&#x27;</span>, <span class=\"function\">(<span class=\"params\">ctx, next</span>) =&gt;</span> &#123;   <span class=\"comment\">// 路由多页面配置</span></span><br><span class=\"line\">    ctx.body = <span class=\"string\">&#x27;Todo page!&#x27;</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 挂载路由</span></span><br><span class=\"line\">app.use(router.routes())</span><br><span class=\"line\">  .use(router.allowedMethods())</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"第09节：Koa-router中间件（2）层级\"><a href=\"#第09节：Koa-router中间件（2）层级\" class=\"headerlink\" title=\"第09节：Koa-router中间件（2）层级\"></a>第09节：Koa-router中间件（2）层级</h2><ul>\n<li><p><strong>设置前缀</strong></p>\n<p>有时候我们想把所有的路径前面都再加入一个级别，比如原来我们访问的路径是<code>http://127.0.0.1:3000/todo</code>，现在我们希望在所有的路径前面都加上一个jspang层级，把路径变成<code>http://127.0.0.1:3000/jspang/todo.</code>这时候就可以使用层级来完成这个功能。路由在创建的时候是可以指定一个前缀的，这个前缀会被至于路由的最顶层，也就是说，这个路由的所有请求都是相对于这个前缀的.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> Router(&#123;</span><br><span class=\"line\">    <span class=\"attr\">prefix</span>:<span class=\"string\">&#x27;/jspang&#x27;</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n<li><p>设置层级</p>\n<p>设置前缀一般都是全局的，并不能实现路由的层级，如果你想为单个页面设置层级，也是很简单的。只要在use时使用路径就可以了。</p>\n<p>例如这种写法装载路由层级，这里的router相当于父级：<code>router.use(‘/page’, page.routes(), page.allowedMethods())</code>。</p>\n<p>通过这种写法的好处是并不是全局的，我们可以给不同的路由加层级。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Koa-router 层级</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ./koa-router2.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> Router = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-router&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\"><span class=\"comment\">// const router = new Router(&#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   // prefix: &#x27;/jspang&#x27;  // 设置前缀</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 设置路由层级</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> home = <span class=\"keyword\">new</span> Router()</span><br><span class=\"line\">home</span><br><span class=\"line\">  .get(<span class=\"string\">&#x27;/jspang&#x27;</span>, <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">    ctx.body = <span class=\"string\">&#x27;Home jspang&#x27;</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .get(<span class=\"string\">&#x27;/todo&#x27;</span>, <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;   <span class=\"comment\">// 路由多页面配置</span></span><br><span class=\"line\">    ctx.body = <span class=\"string\">&#x27;Home Todo&#x27;</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> page = <span class=\"keyword\">new</span> Router()</span><br><span class=\"line\">page</span><br><span class=\"line\">  .get(<span class=\"string\">&#x27;/jspang&#x27;</span>,<span class=\"function\">(<span class=\"params\">ctx, next</span>) =&gt;</span> &#123;  <span class=\"comment\">// async 异步不异步都可以</span></span><br><span class=\"line\">    ctx.body = <span class=\"string\">&#x27;Page jspang&#x27;</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .get(<span class=\"string\">&#x27;/todo&#x27;</span>,<span class=\"function\">(<span class=\"params\">ctx, next</span>) =&gt;</span> &#123;   <span class=\"comment\">// 路由多页面配置</span></span><br><span class=\"line\">    ctx.body = <span class=\"string\">&#x27;Page Todo&#x27;</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 装载所有子路由  router.use(‘/page’, page.routes(), page.allowedMethods())</span></span><br><span class=\"line\"><span class=\"comment\">// 设置父路由</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> router = <span class=\"keyword\">new</span> Router()</span><br><span class=\"line\">router.use(<span class=\"string\">&#x27;/home&#x27;</span>, home.routes(), home.allowedMethods())</span><br><span class=\"line\">router.use(<span class=\"string\">&#x27;/page&#x27;</span>, page.routes(), page.allowedMethods())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 挂载路由中间件</span></span><br><span class=\"line\">app.use(router.routes())</span><br><span class=\"line\">  .use(router.allowedMethods())</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第10节：Koa-router中间件（3）参数\"><a href=\"#第10节：Koa-router中间件（3）参数\" class=\"headerlink\" title=\"第10节：Koa-router中间件（3）参数\"></a>第10节：Koa-router中间件（3）参数</h2><ul>\n<li><p>获取传递参数 <code>ctx.query来进行接收</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Koa-router 参数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ./koa-router3.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> Router = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-router&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> Router()</span><br><span class=\"line\"></span><br><span class=\"line\">router</span><br><span class=\"line\">  .get(<span class=\"string\">&#x27;/&#x27;</span>, <span class=\"function\">(<span class=\"params\">ctx, next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 获取 get 请求参数</span></span><br><span class=\"line\">    ctx.body = ctx.query</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 挂载路由中间件</span></span><br><span class=\"line\">app.use(router.routes())</span><br><span class=\"line\">  .use(router.allowedMethods())</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 地址栏输出 http://127.0.0.1:3000/?user=jspang&amp;age=18</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">&#123;</span></span><br><span class=\"line\"><span class=\"comment\">  &quot;user&quot;: &quot;jspang&quot;,</span></span><br><span class=\"line\"><span class=\"comment\">  &quot;age&quot;: &quot;18&quot;</span></span><br><span class=\"line\"><span class=\"comment\">&#125;</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第11节：Koa2中使用cookie\"><a href=\"#第11节：Koa2中使用cookie\" class=\"headerlink\" title=\"第11节：Koa2中使用cookie\"></a>第11节：Koa2中使用cookie</h2><ul>\n<li><p><code>ctx.cookies.get(name,[optins])</code>: 读取上下文请求中的cookie。</p>\n</li>\n<li><p><code>ctx.cookies.set(name,value,[options])</code>：在上下文中写入cookie</p>\n</li>\n<li><p><strong>写入<code>Cookies</code></strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.cookies.set(<span class=\"string\">&#x27;name&#x27;</span>, <span class=\"string\">&#x27;jspang&#x27;</span>)</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>Cookie选项</strong></p>\n<ul>\n<li>比如我们要存储用户名，保留用户登录状态时，你可以选择7天内不用登录，也可以选择30天内不用登录。这就需要在写入是配置一些选项：</li>\n<li><code>domain</code>：写入cookie所在的域名</li>\n<li><code>path</code>：写入cookie所在的路径</li>\n<li><code>maxAge</code>：Cookie最大有效时长</li>\n<li><code>expires</code>：cookie失效时间</li>\n<li><code>httpOnly</code>:是否只用http请求中获得</li>\n<li><code>overwirte</code>：是否允许重写</li>\n</ul>\n</li>\n<li><p><strong>读取<code>cookies</code></strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctx.cookies.get(<span class=\"string\">&#x27;name&#x27;</span>)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第12节：Koa2的模板初识（ejs）\"><a href=\"#第12节：Koa2的模板初识（ejs）\" class=\"headerlink\" title=\"第12节：Koa2的模板初识（ejs）\"></a>第12节：Koa2的模板初识（ejs）</h2><p>开发中不可能把所有的html代码全部卸载JS里，这显然不现实，也没办法完成大型web开发。必须借用模板机制来帮助我们开发，这节课我们就简单了解一下Koa2的模板机制，koa2的目标机制要依靠中间件来完成开发。</p>\n<ul>\n<li><p><strong>安装中间件</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装中间件</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm install --save koa-views</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>安装ejs模板引擎</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 安装ejs模板引擎</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm install --save ejs</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>编写模板</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为了模板统一管理，我们新建一个view的文件夹，并在它下面新建index.ejs文件。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ./views/index.ejs</span></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class=\"line\">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</span><br><span class=\"line\">    &lt;title&gt;&lt;%= title%&gt;&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt;</span><br><span class=\"line\">    &lt;p&gt;EJS Welcome to &lt;%= title %&gt;&lt;/p&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>编写Koa文件</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ejs模板</span></span><br><span class=\"line\"><span class=\"comment\">// ./ejs_demo.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> views = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-views&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 加载模板引擎</span></span><br><span class=\"line\">app.use(views(path.join(__dirname, <span class=\"string\">&#x27;./views&#x27;</span>), &#123;</span><br><span class=\"line\">  <span class=\"attr\">extension</span>: <span class=\"string\">&#x27;ejs&#x27;</span></span><br><span class=\"line\">&#125;))</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> title = <span class=\"string\">&#x27;HELLO Koa2&#x27;</span></span><br><span class=\"line\">  <span class=\"keyword\">await</span> ctx.render(<span class=\"string\">&#x27;index&#x27;</span>, &#123;</span><br><span class=\"line\">    title</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"第13节：koa-static静态资源中间件\"><a href=\"#第13节：koa-static静态资源中间件\" class=\"headerlink\" title=\"第13节：koa-static静态资源中间件\"></a>第13节：koa-static静态资源中间件</h2><p>在后台开发中不仅有需要代码处理的业务逻辑请求，也会有很多的静态资源请求。比如请求js，css，jpg，png这些静态资源请求。也非常的多，有些时候还会访问静态资源路径。用koa2自己些这些静态资源访问是完全可以的，但是代码会雍长一些。所以这节课我们利用koa-static中间件来实现静态资源的访问。</p>\n<ul>\n<li><p>安装<code>koa-static</code></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save koa-static</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>新建static文件夹</strong> 然后在static文件中放入图片，css和js文件</p>\n</li>\n<li><p>使用<code>koa-static</code>中间件</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Koa = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">static</span> = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;koa-static&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> app = <span class=\"keyword\">new</span> Koa()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明静态路径</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> staticPath = <span class=\"string\">&#x27;./static&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">static</span>(</span><br><span class=\"line\">    path.join(__dirname, staticPath)</span><br><span class=\"line\">))</span><br><span class=\"line\"></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx) =&gt; &#123;</span><br><span class=\"line\">    ctx.body = <span class=\"string\">&#x27;hello world&#x27;</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">app.listen(<span class=\"number\">3000</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;[demo] server is starting at port 3000&#x27;</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 访问图片直接 http://127.0.0.1:3000/koa2.jpg</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"VS Code 使用小技巧","date":"2021-03-18T07:49:01.000Z","type":"其他","note":"VSCode使用必备插件","_content":"# VS Code 使用小技巧\n\n### **简介**\n\nVSCode是微软推出的一款轻量编辑器，采取了和VS相同的UI界面，搭配合适的插件可以优化前端开发的体验。\n\n布局：左侧是用于展示所要编辑的所有文件和文件夹的文件管理器，依次是`**资源管理器**`，`**搜索`，`GIT`，`调试`，`插件`**，右侧是打开文件的编辑区域，最多可同时打开三个编辑区域到侧边。\n\n底栏：依次是**`Git Branch`，`error&warning`，`编码格式`**等。\n<!--more-->\n### **常用插件（待补充）**\n\n\n\n- HTML Snippets：增强了zen-coding，增加了H5的自动补全，安装后每次打开自动启用(可能与其他插件冲突)。\n- Angular 1.x Snippets：增加了AngularJs 1在.html和.js中的代码补全，安装后每次打开自动启用。\n- Git Easy：增加了vscode中自带的git操作，安装后按F1调出控制台，输入git easy [options]完成git操作，代替git bash。\n- HTML CSS Support: 增加.html中css的代码补全，可以手动增加配置文件来增加外部css中的class补全。详情见插件说明。\n- VScode-icons： 美化VSCode的界面，在文件名前面显示小图标，安装后每次打开自动启用。\n- Git Blame：可以查看当前光标所在位置的Git Log，最近一次提交的人和时间，显示在左下角，安装后每次打开自动启用。\n- HTML CSS Class Completion：扫描项目中的所有css中的class名，在html中自动补全，安装后每次打开自动启用。**注意：如果css过多容易卡死。**\n- Debugger for Chrome：方便js调试的插件，前端项目在Chrome中运行起来之后，可以直接在VSCode中打断点、查看输出、查看控制台，需要配置launch.json,详情见插件说明。\n- background：VSCode美化插件，修改界面背景，详情见插件说明。\n\n \n\n### **常用快捷键（待补充）**\n\n#### **编辑器与窗口管理**\n\n同时打开多个窗口（查看多个项目）\n\n- 打开一个新窗口： Ctrl+Shift+N\n- 关闭窗口： Ctrl+Shift+W\n\n \n\n同时打开多个编辑器（查看多个文件）\n\n- 新建文件 Ctrl+N\n- 历史打开文件之间切换 Ctrl+Tab，Alt+Left，Alt+Right\n- 切出一个新的编辑器（最多3个）Ctrl+\\，也可以按住Ctrl鼠标点击Explorer里的文件名\n- 左中右3个编辑器的快捷键Ctrl+1 Ctrl+2 Ctrl+3\n- **3个编辑器之间循环切换 Ctrl+`**\n- **编辑器换位置，Ctrl+k然后按Left或Right**\n\n \n\n#### **代码编辑**\n\n**格式调整**\n\n- 代码行缩进Ctrl+[， Ctrl+]\n- **折叠打开代码块 Ctrl+Shift+[， Ctrl+Shift+]**\n- Ctrl+C Ctrl+V如果不选中，默认复制或剪切一整行\n- 代码格式化：Shift+Alt+F，或Ctrl+Shift+P后输入format code\n- 修剪空格Ctrl+Shift+X\n- 上下移动一行： Alt+Up 或 Alt+Down\n- **向上向下复制一行： Shift+Alt+Up或Shift+Alt+Down**\n- 在当前行下边插入一行Ctrl+Enter\n- 在当前行上方插入一行Ctrl+Shift+Enter\n\n \n\n**光标相关**\n\n- 移动到行首：Home\n- 移动到行尾：End\n- 移动到文件结尾：Ctrl+End\n- 移动到文件开头：Ctrl+Home\n- 移动到后半个括号 Ctrl+Shift+]\n- 选中当前行Ctrl+i（双击）\n- 选择从光标到行尾Shift+End\n- 选择从行首到光标处Shift+Home\n- **删除光标右侧的所有字Ctrl+Delete**\n- Shrink/expand selection： Shift+Alt+Left和Shift+Alt+Right\n- Multi-Cursor：可以连续选择多处，然后一起修改，Alt+Click添加cursor或者Ctrl+Alt+Down 或 Ctrl+Alt+Up\n- 同时选中所有匹配的Ctrl+Shift+L\n- Ctrl+D下一个匹配的也被选中(被我自定义成删除当前行了，见下边Ctrl+Shift+K)\n- **回退上一个光标操作Ctrl+U**\n\n \n\n**重构代码**\n\n- 跳转到定义处：F12\n- 定义处缩略图：只看一眼而不跳转过去Alt+F12\n- **列出所有的引用：Shift+F12**\n- 同时修改本文件中所有匹配的：Ctrl+F12\n- 重命名：比如要修改一个方法名，可以选中后按F2，输入新的名字，回车，会发现所有的文件都修改过了。\n- 跳转到下一个Error或Warning：当有多个错误时可以按F8逐个跳转\n- 查看diff 在explorer里选择文件右键 Set file to compare，然后需要对比的文件上右键选择Compare with 'file_name_you_chose'.\n\n \n\n**查找替换**\n\n- 查找 Ctrl+F\n- 查找替换 Ctrl+H\n- 整个文件夹中查找 Ctrl+Shift+F\n\n \n\n**显示相关**\n\n- 全屏：F11\n- zoomIn/zoomOut：Ctrl + =/Ctrl + -\n- 侧边栏显/隐：Ctrl+B\n- **预览markdown Ctrl+Shift+V**\n\n \n\n**其他**\n\n- 自动保存：File -> AutoSave ，或者Ctrl+Shift+P，输入 auto","source":"_posts/vscode-tips.md","raw":"---\ntitle: VS Code 使用小技巧\ndate: 2021-03-18 15:49:01\ntype: 其他\ntags: VSCode\nnote: VSCode使用必备插件\n---\n# VS Code 使用小技巧\n\n### **简介**\n\nVSCode是微软推出的一款轻量编辑器，采取了和VS相同的UI界面，搭配合适的插件可以优化前端开发的体验。\n\n布局：左侧是用于展示所要编辑的所有文件和文件夹的文件管理器，依次是`**资源管理器**`，`**搜索`，`GIT`，`调试`，`插件`**，右侧是打开文件的编辑区域，最多可同时打开三个编辑区域到侧边。\n\n底栏：依次是**`Git Branch`，`error&warning`，`编码格式`**等。\n<!--more-->\n### **常用插件（待补充）**\n\n\n\n- HTML Snippets：增强了zen-coding，增加了H5的自动补全，安装后每次打开自动启用(可能与其他插件冲突)。\n- Angular 1.x Snippets：增加了AngularJs 1在.html和.js中的代码补全，安装后每次打开自动启用。\n- Git Easy：增加了vscode中自带的git操作，安装后按F1调出控制台，输入git easy [options]完成git操作，代替git bash。\n- HTML CSS Support: 增加.html中css的代码补全，可以手动增加配置文件来增加外部css中的class补全。详情见插件说明。\n- VScode-icons： 美化VSCode的界面，在文件名前面显示小图标，安装后每次打开自动启用。\n- Git Blame：可以查看当前光标所在位置的Git Log，最近一次提交的人和时间，显示在左下角，安装后每次打开自动启用。\n- HTML CSS Class Completion：扫描项目中的所有css中的class名，在html中自动补全，安装后每次打开自动启用。**注意：如果css过多容易卡死。**\n- Debugger for Chrome：方便js调试的插件，前端项目在Chrome中运行起来之后，可以直接在VSCode中打断点、查看输出、查看控制台，需要配置launch.json,详情见插件说明。\n- background：VSCode美化插件，修改界面背景，详情见插件说明。\n\n \n\n### **常用快捷键（待补充）**\n\n#### **编辑器与窗口管理**\n\n同时打开多个窗口（查看多个项目）\n\n- 打开一个新窗口： Ctrl+Shift+N\n- 关闭窗口： Ctrl+Shift+W\n\n \n\n同时打开多个编辑器（查看多个文件）\n\n- 新建文件 Ctrl+N\n- 历史打开文件之间切换 Ctrl+Tab，Alt+Left，Alt+Right\n- 切出一个新的编辑器（最多3个）Ctrl+\\，也可以按住Ctrl鼠标点击Explorer里的文件名\n- 左中右3个编辑器的快捷键Ctrl+1 Ctrl+2 Ctrl+3\n- **3个编辑器之间循环切换 Ctrl+`**\n- **编辑器换位置，Ctrl+k然后按Left或Right**\n\n \n\n#### **代码编辑**\n\n**格式调整**\n\n- 代码行缩进Ctrl+[， Ctrl+]\n- **折叠打开代码块 Ctrl+Shift+[， Ctrl+Shift+]**\n- Ctrl+C Ctrl+V如果不选中，默认复制或剪切一整行\n- 代码格式化：Shift+Alt+F，或Ctrl+Shift+P后输入format code\n- 修剪空格Ctrl+Shift+X\n- 上下移动一行： Alt+Up 或 Alt+Down\n- **向上向下复制一行： Shift+Alt+Up或Shift+Alt+Down**\n- 在当前行下边插入一行Ctrl+Enter\n- 在当前行上方插入一行Ctrl+Shift+Enter\n\n \n\n**光标相关**\n\n- 移动到行首：Home\n- 移动到行尾：End\n- 移动到文件结尾：Ctrl+End\n- 移动到文件开头：Ctrl+Home\n- 移动到后半个括号 Ctrl+Shift+]\n- 选中当前行Ctrl+i（双击）\n- 选择从光标到行尾Shift+End\n- 选择从行首到光标处Shift+Home\n- **删除光标右侧的所有字Ctrl+Delete**\n- Shrink/expand selection： Shift+Alt+Left和Shift+Alt+Right\n- Multi-Cursor：可以连续选择多处，然后一起修改，Alt+Click添加cursor或者Ctrl+Alt+Down 或 Ctrl+Alt+Up\n- 同时选中所有匹配的Ctrl+Shift+L\n- Ctrl+D下一个匹配的也被选中(被我自定义成删除当前行了，见下边Ctrl+Shift+K)\n- **回退上一个光标操作Ctrl+U**\n\n \n\n**重构代码**\n\n- 跳转到定义处：F12\n- 定义处缩略图：只看一眼而不跳转过去Alt+F12\n- **列出所有的引用：Shift+F12**\n- 同时修改本文件中所有匹配的：Ctrl+F12\n- 重命名：比如要修改一个方法名，可以选中后按F2，输入新的名字，回车，会发现所有的文件都修改过了。\n- 跳转到下一个Error或Warning：当有多个错误时可以按F8逐个跳转\n- 查看diff 在explorer里选择文件右键 Set file to compare，然后需要对比的文件上右键选择Compare with 'file_name_you_chose'.\n\n \n\n**查找替换**\n\n- 查找 Ctrl+F\n- 查找替换 Ctrl+H\n- 整个文件夹中查找 Ctrl+Shift+F\n\n \n\n**显示相关**\n\n- 全屏：F11\n- zoomIn/zoomOut：Ctrl + =/Ctrl + -\n- 侧边栏显/隐：Ctrl+B\n- **预览markdown Ctrl+Shift+V**\n\n \n\n**其他**\n\n- 自动保存：File -> AutoSave ，或者Ctrl+Shift+P，输入 auto","slug":"vscode-tips","published":1,"updated":"2021-07-19T05:52:14.524Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrd8jv1a0008kwztay80ezdm","content":"<h1 id=\"VS-Code-使用小技巧\"><a href=\"#VS-Code-使用小技巧\" class=\"headerlink\" title=\"VS Code 使用小技巧\"></a>VS Code 使用小技巧</h1><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><strong>简介</strong></h3><p>VSCode是微软推出的一款轻量编辑器，采取了和VS相同的UI界面，搭配合适的插件可以优化前端开发的体验。</p>\n<p>布局：左侧是用于展示所要编辑的所有文件和文件夹的文件管理器，依次是<code>**资源管理器**</code>，<code>**搜索</code>，<code>GIT</code>，<code>调试</code>，<code>插件</code>**，右侧是打开文件的编辑区域，最多可同时打开三个编辑区域到侧边。</p>\n<p>底栏：依次是**<code>Git Branch</code>，<code>error&amp;warning</code>，<code>编码格式</code>**等。</p>\n<span id=\"more\"></span>\n<h3 id=\"常用插件（待补充）\"><a href=\"#常用插件（待补充）\" class=\"headerlink\" title=\"常用插件（待补充）\"></a><strong>常用插件（待补充）</strong></h3><ul>\n<li>HTML Snippets：增强了zen-coding，增加了H5的自动补全，安装后每次打开自动启用(可能与其他插件冲突)。</li>\n<li>Angular 1.x Snippets：增加了AngularJs 1在.html和.js中的代码补全，安装后每次打开自动启用。</li>\n<li>Git Easy：增加了vscode中自带的git操作，安装后按F1调出控制台，输入git easy [options]完成git操作，代替git bash。</li>\n<li>HTML CSS Support: 增加.html中css的代码补全，可以手动增加配置文件来增加外部css中的class补全。详情见插件说明。</li>\n<li>VScode-icons： 美化VSCode的界面，在文件名前面显示小图标，安装后每次打开自动启用。</li>\n<li>Git Blame：可以查看当前光标所在位置的Git Log，最近一次提交的人和时间，显示在左下角，安装后每次打开自动启用。</li>\n<li>HTML CSS Class Completion：扫描项目中的所有css中的class名，在html中自动补全，安装后每次打开自动启用。<strong>注意：如果css过多容易卡死。</strong></li>\n<li>Debugger for Chrome：方便js调试的插件，前端项目在Chrome中运行起来之后，可以直接在VSCode中打断点、查看输出、查看控制台，需要配置launch.json,详情见插件说明。</li>\n<li>background：VSCode美化插件，修改界面背景，详情见插件说明。</li>\n</ul>\n<h3 id=\"常用快捷键（待补充）\"><a href=\"#常用快捷键（待补充）\" class=\"headerlink\" title=\"常用快捷键（待补充）\"></a><strong>常用快捷键（待补充）</strong></h3><h4 id=\"编辑器与窗口管理\"><a href=\"#编辑器与窗口管理\" class=\"headerlink\" title=\"编辑器与窗口管理\"></a><strong>编辑器与窗口管理</strong></h4><p>同时打开多个窗口（查看多个项目）</p>\n<ul>\n<li>打开一个新窗口： Ctrl+Shift+N</li>\n<li>关闭窗口： Ctrl+Shift+W</li>\n</ul>\n<p>同时打开多个编辑器（查看多个文件）</p>\n<ul>\n<li>新建文件 Ctrl+N</li>\n<li>历史打开文件之间切换 Ctrl+Tab，Alt+Left，Alt+Right</li>\n<li>切出一个新的编辑器（最多3个）Ctrl+\\，也可以按住Ctrl鼠标点击Explorer里的文件名</li>\n<li>左中右3个编辑器的快捷键Ctrl+1 Ctrl+2 Ctrl+3</li>\n<li><strong>3个编辑器之间循环切换 Ctrl+`</strong></li>\n<li><strong>编辑器换位置，Ctrl+k然后按Left或Right</strong></li>\n</ul>\n<h4 id=\"代码编辑\"><a href=\"#代码编辑\" class=\"headerlink\" title=\"代码编辑\"></a><strong>代码编辑</strong></h4><p><strong>格式调整</strong></p>\n<ul>\n<li>代码行缩进Ctrl+[， Ctrl+]</li>\n<li><strong>折叠打开代码块 Ctrl+Shift+[， Ctrl+Shift+]</strong></li>\n<li>Ctrl+C Ctrl+V如果不选中，默认复制或剪切一整行</li>\n<li>代码格式化：Shift+Alt+F，或Ctrl+Shift+P后输入format code</li>\n<li>修剪空格Ctrl+Shift+X</li>\n<li>上下移动一行： Alt+Up 或 Alt+Down</li>\n<li><strong>向上向下复制一行： Shift+Alt+Up或Shift+Alt+Down</strong></li>\n<li>在当前行下边插入一行Ctrl+Enter</li>\n<li>在当前行上方插入一行Ctrl+Shift+Enter</li>\n</ul>\n<p><strong>光标相关</strong></p>\n<ul>\n<li>移动到行首：Home</li>\n<li>移动到行尾：End</li>\n<li>移动到文件结尾：Ctrl+End</li>\n<li>移动到文件开头：Ctrl+Home</li>\n<li>移动到后半个括号 Ctrl+Shift+]</li>\n<li>选中当前行Ctrl+i（双击）</li>\n<li>选择从光标到行尾Shift+End</li>\n<li>选择从行首到光标处Shift+Home</li>\n<li><strong>删除光标右侧的所有字Ctrl+Delete</strong></li>\n<li>Shrink/expand selection： Shift+Alt+Left和Shift+Alt+Right</li>\n<li>Multi-Cursor：可以连续选择多处，然后一起修改，Alt+Click添加cursor或者Ctrl+Alt+Down 或 Ctrl+Alt+Up</li>\n<li>同时选中所有匹配的Ctrl+Shift+L</li>\n<li>Ctrl+D下一个匹配的也被选中(被我自定义成删除当前行了，见下边Ctrl+Shift+K)</li>\n<li><strong>回退上一个光标操作Ctrl+U</strong></li>\n</ul>\n<p><strong>重构代码</strong></p>\n<ul>\n<li>跳转到定义处：F12</li>\n<li>定义处缩略图：只看一眼而不跳转过去Alt+F12</li>\n<li><strong>列出所有的引用：Shift+F12</strong></li>\n<li>同时修改本文件中所有匹配的：Ctrl+F12</li>\n<li>重命名：比如要修改一个方法名，可以选中后按F2，输入新的名字，回车，会发现所有的文件都修改过了。</li>\n<li>跳转到下一个Error或Warning：当有多个错误时可以按F8逐个跳转</li>\n<li>查看diff 在explorer里选择文件右键 Set file to compare，然后需要对比的文件上右键选择Compare with ‘file_name_you_chose’.</li>\n</ul>\n<p><strong>查找替换</strong></p>\n<ul>\n<li>查找 Ctrl+F</li>\n<li>查找替换 Ctrl+H</li>\n<li>整个文件夹中查找 Ctrl+Shift+F</li>\n</ul>\n<p><strong>显示相关</strong></p>\n<ul>\n<li>全屏：F11</li>\n<li>zoomIn/zoomOut：Ctrl + =/Ctrl + -</li>\n<li>侧边栏显/隐：Ctrl+B</li>\n<li><strong>预览markdown Ctrl+Shift+V</strong></li>\n</ul>\n<p><strong>其他</strong></p>\n<ul>\n<li>自动保存：File -&gt; AutoSave ，或者Ctrl+Shift+P，输入 auto</li>\n</ul>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"<h1 id=\"VS-Code-使用小技巧\"><a href=\"#VS-Code-使用小技巧\" class=\"headerlink\" title=\"VS Code 使用小技巧\"></a>VS Code 使用小技巧</h1><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a><strong>简介</strong></h3><p>VSCode是微软推出的一款轻量编辑器，采取了和VS相同的UI界面，搭配合适的插件可以优化前端开发的体验。</p>\n<p>布局：左侧是用于展示所要编辑的所有文件和文件夹的文件管理器，依次是<code>**资源管理器**</code>，<code>**搜索</code>，<code>GIT</code>，<code>调试</code>，<code>插件</code>**，右侧是打开文件的编辑区域，最多可同时打开三个编辑区域到侧边。</p>\n<p>底栏：依次是**<code>Git Branch</code>，<code>error&amp;warning</code>，<code>编码格式</code>**等。</p>","more":"<h3 id=\"常用插件（待补充）\"><a href=\"#常用插件（待补充）\" class=\"headerlink\" title=\"常用插件（待补充）\"></a><strong>常用插件（待补充）</strong></h3><ul>\n<li>HTML Snippets：增强了zen-coding，增加了H5的自动补全，安装后每次打开自动启用(可能与其他插件冲突)。</li>\n<li>Angular 1.x Snippets：增加了AngularJs 1在.html和.js中的代码补全，安装后每次打开自动启用。</li>\n<li>Git Easy：增加了vscode中自带的git操作，安装后按F1调出控制台，输入git easy [options]完成git操作，代替git bash。</li>\n<li>HTML CSS Support: 增加.html中css的代码补全，可以手动增加配置文件来增加外部css中的class补全。详情见插件说明。</li>\n<li>VScode-icons： 美化VSCode的界面，在文件名前面显示小图标，安装后每次打开自动启用。</li>\n<li>Git Blame：可以查看当前光标所在位置的Git Log，最近一次提交的人和时间，显示在左下角，安装后每次打开自动启用。</li>\n<li>HTML CSS Class Completion：扫描项目中的所有css中的class名，在html中自动补全，安装后每次打开自动启用。<strong>注意：如果css过多容易卡死。</strong></li>\n<li>Debugger for Chrome：方便js调试的插件，前端项目在Chrome中运行起来之后，可以直接在VSCode中打断点、查看输出、查看控制台，需要配置launch.json,详情见插件说明。</li>\n<li>background：VSCode美化插件，修改界面背景，详情见插件说明。</li>\n</ul>\n<h3 id=\"常用快捷键（待补充）\"><a href=\"#常用快捷键（待补充）\" class=\"headerlink\" title=\"常用快捷键（待补充）\"></a><strong>常用快捷键（待补充）</strong></h3><h4 id=\"编辑器与窗口管理\"><a href=\"#编辑器与窗口管理\" class=\"headerlink\" title=\"编辑器与窗口管理\"></a><strong>编辑器与窗口管理</strong></h4><p>同时打开多个窗口（查看多个项目）</p>\n<ul>\n<li>打开一个新窗口： Ctrl+Shift+N</li>\n<li>关闭窗口： Ctrl+Shift+W</li>\n</ul>\n<p>同时打开多个编辑器（查看多个文件）</p>\n<ul>\n<li>新建文件 Ctrl+N</li>\n<li>历史打开文件之间切换 Ctrl+Tab，Alt+Left，Alt+Right</li>\n<li>切出一个新的编辑器（最多3个）Ctrl+\\，也可以按住Ctrl鼠标点击Explorer里的文件名</li>\n<li>左中右3个编辑器的快捷键Ctrl+1 Ctrl+2 Ctrl+3</li>\n<li><strong>3个编辑器之间循环切换 Ctrl+`</strong></li>\n<li><strong>编辑器换位置，Ctrl+k然后按Left或Right</strong></li>\n</ul>\n<h4 id=\"代码编辑\"><a href=\"#代码编辑\" class=\"headerlink\" title=\"代码编辑\"></a><strong>代码编辑</strong></h4><p><strong>格式调整</strong></p>\n<ul>\n<li>代码行缩进Ctrl+[， Ctrl+]</li>\n<li><strong>折叠打开代码块 Ctrl+Shift+[， Ctrl+Shift+]</strong></li>\n<li>Ctrl+C Ctrl+V如果不选中，默认复制或剪切一整行</li>\n<li>代码格式化：Shift+Alt+F，或Ctrl+Shift+P后输入format code</li>\n<li>修剪空格Ctrl+Shift+X</li>\n<li>上下移动一行： Alt+Up 或 Alt+Down</li>\n<li><strong>向上向下复制一行： Shift+Alt+Up或Shift+Alt+Down</strong></li>\n<li>在当前行下边插入一行Ctrl+Enter</li>\n<li>在当前行上方插入一行Ctrl+Shift+Enter</li>\n</ul>\n<p><strong>光标相关</strong></p>\n<ul>\n<li>移动到行首：Home</li>\n<li>移动到行尾：End</li>\n<li>移动到文件结尾：Ctrl+End</li>\n<li>移动到文件开头：Ctrl+Home</li>\n<li>移动到后半个括号 Ctrl+Shift+]</li>\n<li>选中当前行Ctrl+i（双击）</li>\n<li>选择从光标到行尾Shift+End</li>\n<li>选择从行首到光标处Shift+Home</li>\n<li><strong>删除光标右侧的所有字Ctrl+Delete</strong></li>\n<li>Shrink/expand selection： Shift+Alt+Left和Shift+Alt+Right</li>\n<li>Multi-Cursor：可以连续选择多处，然后一起修改，Alt+Click添加cursor或者Ctrl+Alt+Down 或 Ctrl+Alt+Up</li>\n<li>同时选中所有匹配的Ctrl+Shift+L</li>\n<li>Ctrl+D下一个匹配的也被选中(被我自定义成删除当前行了，见下边Ctrl+Shift+K)</li>\n<li><strong>回退上一个光标操作Ctrl+U</strong></li>\n</ul>\n<p><strong>重构代码</strong></p>\n<ul>\n<li>跳转到定义处：F12</li>\n<li>定义处缩略图：只看一眼而不跳转过去Alt+F12</li>\n<li><strong>列出所有的引用：Shift+F12</strong></li>\n<li>同时修改本文件中所有匹配的：Ctrl+F12</li>\n<li>重命名：比如要修改一个方法名，可以选中后按F2，输入新的名字，回车，会发现所有的文件都修改过了。</li>\n<li>跳转到下一个Error或Warning：当有多个错误时可以按F8逐个跳转</li>\n<li>查看diff 在explorer里选择文件右键 Set file to compare，然后需要对比的文件上右键选择Compare with ‘file_name_you_chose’.</li>\n</ul>\n<p><strong>查找替换</strong></p>\n<ul>\n<li>查找 Ctrl+F</li>\n<li>查找替换 Ctrl+H</li>\n<li>整个文件夹中查找 Ctrl+Shift+F</li>\n</ul>\n<p><strong>显示相关</strong></p>\n<ul>\n<li>全屏：F11</li>\n<li>zoomIn/zoomOut：Ctrl + =/Ctrl + -</li>\n<li>侧边栏显/隐：Ctrl+B</li>\n<li><strong>预览markdown Ctrl+Shift+V</strong></li>\n</ul>\n<p><strong>其他</strong></p>\n<ul>\n<li>自动保存：File -&gt; AutoSave ，或者Ctrl+Shift+P，输入 auto</li>\n</ul>"},{"title":"前端面试题积累","date":"2021-03-18T00:00:00.000Z","type":"技术","note":"面试问题的一些整理","_content":"\n# 前端面试题积累\n\n标签（空格分隔）： Summarize Interview\n\n---\n\n## vue构造器以及实例属性\n* 构造器\n   * Vue.js是一个构造函数，编程中称之为构造器。\n   * 每一个new Vue() 都是一个Vue构造函数的实例，这个过程叫做实例化。  \n   * 构造函数需要将其实例化后才会启用。  \n   * Vue构造器要求实例化时需要传入一个选项对象。    \n   * 选项对象包括数据(data)，模板(tamplate)，挂载元素(el)，方法(methods)，生命周期钩子等选项。\n   * 每个 Vue.js应用都是通过构造函数Vue创建一个 Vue 的根实例启动的。在文档中经常会使用 vm (ViewModel 的简称)这个变量名表示 Vue 实例。\n   \n    ```\n    //vue的实例化\n    var vm = new Vue({\n      // 选项\n    })\n    ```\n\n   * 可以扩展构造器Vue，从而用预定义选项创建可复用的组件构造器，所有组件都是被扩展的Vue的实例，使用 `Vue.extend({})`来扩展；\n\n    ```\n    var MyComponent = Vue.extend({\n    \t// 扩展选项\n    })\n    // 所有的MyComponent实例都将以预定义的扩展选项被创建\n    // 相当于MyComponent继承Vue并且加上扩展的选项\n    \n    // MyComponent()相当于扩展后的vue，而myComponentInstance 就是扩展后vue的实例。\n    var myComponentInstance = new MyComponent();\n    ```\n\n* 属性与方法\n   * 每个Vue的实例都会代理其data对象里的所有属性，被代理的属性是响应的；  \n   * 如果实例创建之后添加新的属性到实例上，不会触发视图更新；\n   * 不要在实例属性或者回调函数中使用箭头函数（如 `vm.$watch('a', newVal => this.myMethod())`）。因为箭头函数绑定父上下文，所以 this 不会像预想的一样是 Vue 实例，而是`this.myMethod`未被定义。\n   * Vue实例暴露了一些有用的实例属性和方法，带有前缀 `$`，便于与代理的data区分\n      * `vm.$el`：类型（HTMLElement）挂载元素，Vue实例的DOM根元素；\n      * `vm.$data`：类型（Object），Vue实例观察的数据对象；\n      * `vm.$props`：类型（Object）。\n\n## 手写实现 `throttle` （节流）函数\n### 什么是throttle　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 \n* 定义：如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。\n\n* 接口定义\n```javascript\n/**\n* 频率控制 返回函数连续调用时，action 执行频率限定为 次 / delay\n* @param delay  {number}    延迟时间，单位毫秒\n* @param action {function}  请求关联函数，实际应用需要调用的函数\n* @return {function}    返回客户调用函数\n*/\nthrottle(delay,action)\n```\n\n### 简单实现\n\n```javascript\nvar throttle = function(delay, action){\n  var last = 0return function(){\n    var curr = +new Date()\n    if (curr - last > delay){\n      action.apply(this, arguments)\n      last = curr \n    }\n  }\n}\n```\n### 拓展延伸\n[函数节流（throttle）与函数去抖（debounce）](https://www.cnblogs.com/fsjohnhuang/p/4147810.html)\n\n\n## css实现自适应的正方形\n\n* padding-bottom实现\n```html\n<div class=\"square-shape\">这是一个可以自适应的正方形，此法很好用，有内容也是正方形。</div>\n.square-shape {\n  width: 30%;\n  height: 0;\n  padding-bottom: 30%;\n  border: 1px solid #f00;\n}\n```\n\n* 伪元素的padding-bottom，内嵌absolute元素\n\n```html\n<div class=\"square-shape\">\n    <div class=\"content\">这是一个可以自适应的正方形</div>\n</div>\n.square-shape {\n  width: 50%;\n  border: 1px solid #f00;\n}\n.square-shape:after {\n  content: '';\n  display: block;\n  padding-bottom: 100%;\n}\n.content {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n}\n```\n\n## 手写实现以下事件委托函数\n\n```javascript\n// 手写实现以下事件委托函数\nfunction delegate(parent, selector, handle) {}\n```\n\n* 事件委托，通俗来说就是将元素的事件委托给它的父级或者更外级元素处理。\n* 需要注意的地方：\n   * 保证兼容性，包括：事件绑定、元素选择器 Element.matches 、事件 event 对象\n   * 回调函数 this 指向\n   * 当目标元素下还有子元素时，子元素不能触发事件。\n     解决办法是在触发过程中对元素进行判断，如果当前触发的元素不是目标元素，就继续往该元素的 parentNode 查找，否则循环结束。\n```javascript\n/ *\n  * [delegateEvent description]\n  * @param  {[type]}   parentSelector 父元素\n  * @param  {[type]}   targetSelector 目标元素\n  * @param  {[type]}   events         事件\n  * @param  {Function} fn             回调函数\n  * @return {[type]}                  null\n   */\n\nfunction delegateEvent(parentSelector, targetSelector, events, fn) {\n  \n  // 事件绑定浏览器兼容性处理\n  function addEvent(ele, type, handle) {\n    if(ele.addEventListener) {\n      ele.addEventListener(type, handle, false);\n    } else if(ele.attachEvent){\n      ele.attachEvent('on' + type, handle);\n    } else {\n      ele['on' + type] = handle;\n    }\n  }\n\n  // 如果元素被指定的选择器字符串选择， Element.matches() 方法返回 true; 否则返回 false。\n  // 对于不支持 Element.matches() 或 Element.matchesSelector()，但支持 document.querySelectorAll() 方法的浏览器，存在以下替代方案\n  if (!Element.prototype.matches) {\n    Element.prototype.matches =\n    Element.prototype.matchesSelector ||\n    Element.prototype.mozMatchesSelector ||\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.oMatchesSelector ||\n    Element.prototype.webkitMatchesSelector ||\n    function(s) {\n      var matches = (this.document || this.ownerDocument).querySelectorAll(s),\n          i = matches.length;\n      while (--i >= 0 && matches.item(i) !== this) {}\n      return i > -1;\n    };\n  }\n\n  // 事件处理逻辑\n  addEvent(parentSelector, events, function(e) {\n\n    // 兼容性处理\n    var e = e || window.event;\n    var t = e.target || e.srcElement;\n    // currentTarget === parentSelector\n    var currentTarget = e.currentTarget;\n\n    // 遍历并判断是否为目标元素，如果不是，则往元素的 parentNode 继续查找\n    while(!t.matches(targetSelector)) {\n      // 如果是目标元素则跳出循环\n        if(t === currentTarget) {\n        t = null;\n          break;\n        }\n        t = t.parentNode;\n    }\n\n    if(t) {\n    // 将回调函数的 this 指向目标元素\n    fn.call(t, Array.prototype.slice.call(arguments));\n    }\n    \n  });\n}\n```\n\n* 实例\n```html\n<ul id=\"myLink\">\n  <li id=\"1\" class=\"link\"><a href=\"javascript:;\"><span>aaa</span></a></li>\n  <li id=\"2\" class=\"link\"><a href=\"javascript:;\">bbb</a></li>\n  <li id=\"3\" class=\"link\">ccc</li>\n</ul>\n\n<script type=\"text/javascript\">\n  var myLink = document.querySelector('#myLink');\n  delegateEvent(myLink, 'li.link', 'click', function() {\n    console.log(this, this.id + '：' + this.innerText);\n  });\n</script>\n```\n\n-----\n创建时间  2017-11-18 By MarlonChiu \n\n\n\n\n","source":"_posts/前端面试题积累.md","raw":"---\ntitle: 前端面试题积累\ndate: '2021-03-18'\ntype: 技术\ntags: 面试\nnote: 面试问题的一些整理\n---\n\n# 前端面试题积累\n\n标签（空格分隔）： Summarize Interview\n\n---\n\n## vue构造器以及实例属性\n* 构造器\n   * Vue.js是一个构造函数，编程中称之为构造器。\n   * 每一个new Vue() 都是一个Vue构造函数的实例，这个过程叫做实例化。  \n   * 构造函数需要将其实例化后才会启用。  \n   * Vue构造器要求实例化时需要传入一个选项对象。    \n   * 选项对象包括数据(data)，模板(tamplate)，挂载元素(el)，方法(methods)，生命周期钩子等选项。\n   * 每个 Vue.js应用都是通过构造函数Vue创建一个 Vue 的根实例启动的。在文档中经常会使用 vm (ViewModel 的简称)这个变量名表示 Vue 实例。\n   \n    ```\n    //vue的实例化\n    var vm = new Vue({\n      // 选项\n    })\n    ```\n\n   * 可以扩展构造器Vue，从而用预定义选项创建可复用的组件构造器，所有组件都是被扩展的Vue的实例，使用 `Vue.extend({})`来扩展；\n\n    ```\n    var MyComponent = Vue.extend({\n    \t// 扩展选项\n    })\n    // 所有的MyComponent实例都将以预定义的扩展选项被创建\n    // 相当于MyComponent继承Vue并且加上扩展的选项\n    \n    // MyComponent()相当于扩展后的vue，而myComponentInstance 就是扩展后vue的实例。\n    var myComponentInstance = new MyComponent();\n    ```\n\n* 属性与方法\n   * 每个Vue的实例都会代理其data对象里的所有属性，被代理的属性是响应的；  \n   * 如果实例创建之后添加新的属性到实例上，不会触发视图更新；\n   * 不要在实例属性或者回调函数中使用箭头函数（如 `vm.$watch('a', newVal => this.myMethod())`）。因为箭头函数绑定父上下文，所以 this 不会像预想的一样是 Vue 实例，而是`this.myMethod`未被定义。\n   * Vue实例暴露了一些有用的实例属性和方法，带有前缀 `$`，便于与代理的data区分\n      * `vm.$el`：类型（HTMLElement）挂载元素，Vue实例的DOM根元素；\n      * `vm.$data`：类型（Object），Vue实例观察的数据对象；\n      * `vm.$props`：类型（Object）。\n\n## 手写实现 `throttle` （节流）函数\n### 什么是throttle　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 \n* 定义：如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。\n\n* 接口定义\n```javascript\n/**\n* 频率控制 返回函数连续调用时，action 执行频率限定为 次 / delay\n* @param delay  {number}    延迟时间，单位毫秒\n* @param action {function}  请求关联函数，实际应用需要调用的函数\n* @return {function}    返回客户调用函数\n*/\nthrottle(delay,action)\n```\n\n### 简单实现\n\n```javascript\nvar throttle = function(delay, action){\n  var last = 0return function(){\n    var curr = +new Date()\n    if (curr - last > delay){\n      action.apply(this, arguments)\n      last = curr \n    }\n  }\n}\n```\n### 拓展延伸\n[函数节流（throttle）与函数去抖（debounce）](https://www.cnblogs.com/fsjohnhuang/p/4147810.html)\n\n\n## css实现自适应的正方形\n\n* padding-bottom实现\n```html\n<div class=\"square-shape\">这是一个可以自适应的正方形，此法很好用，有内容也是正方形。</div>\n.square-shape {\n  width: 30%;\n  height: 0;\n  padding-bottom: 30%;\n  border: 1px solid #f00;\n}\n```\n\n* 伪元素的padding-bottom，内嵌absolute元素\n\n```html\n<div class=\"square-shape\">\n    <div class=\"content\">这是一个可以自适应的正方形</div>\n</div>\n.square-shape {\n  width: 50%;\n  border: 1px solid #f00;\n}\n.square-shape:after {\n  content: '';\n  display: block;\n  padding-bottom: 100%;\n}\n.content {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n}\n```\n\n## 手写实现以下事件委托函数\n\n```javascript\n// 手写实现以下事件委托函数\nfunction delegate(parent, selector, handle) {}\n```\n\n* 事件委托，通俗来说就是将元素的事件委托给它的父级或者更外级元素处理。\n* 需要注意的地方：\n   * 保证兼容性，包括：事件绑定、元素选择器 Element.matches 、事件 event 对象\n   * 回调函数 this 指向\n   * 当目标元素下还有子元素时，子元素不能触发事件。\n     解决办法是在触发过程中对元素进行判断，如果当前触发的元素不是目标元素，就继续往该元素的 parentNode 查找，否则循环结束。\n```javascript\n/ *\n  * [delegateEvent description]\n  * @param  {[type]}   parentSelector 父元素\n  * @param  {[type]}   targetSelector 目标元素\n  * @param  {[type]}   events         事件\n  * @param  {Function} fn             回调函数\n  * @return {[type]}                  null\n   */\n\nfunction delegateEvent(parentSelector, targetSelector, events, fn) {\n  \n  // 事件绑定浏览器兼容性处理\n  function addEvent(ele, type, handle) {\n    if(ele.addEventListener) {\n      ele.addEventListener(type, handle, false);\n    } else if(ele.attachEvent){\n      ele.attachEvent('on' + type, handle);\n    } else {\n      ele['on' + type] = handle;\n    }\n  }\n\n  // 如果元素被指定的选择器字符串选择， Element.matches() 方法返回 true; 否则返回 false。\n  // 对于不支持 Element.matches() 或 Element.matchesSelector()，但支持 document.querySelectorAll() 方法的浏览器，存在以下替代方案\n  if (!Element.prototype.matches) {\n    Element.prototype.matches =\n    Element.prototype.matchesSelector ||\n    Element.prototype.mozMatchesSelector ||\n    Element.prototype.msMatchesSelector ||\n    Element.prototype.oMatchesSelector ||\n    Element.prototype.webkitMatchesSelector ||\n    function(s) {\n      var matches = (this.document || this.ownerDocument).querySelectorAll(s),\n          i = matches.length;\n      while (--i >= 0 && matches.item(i) !== this) {}\n      return i > -1;\n    };\n  }\n\n  // 事件处理逻辑\n  addEvent(parentSelector, events, function(e) {\n\n    // 兼容性处理\n    var e = e || window.event;\n    var t = e.target || e.srcElement;\n    // currentTarget === parentSelector\n    var currentTarget = e.currentTarget;\n\n    // 遍历并判断是否为目标元素，如果不是，则往元素的 parentNode 继续查找\n    while(!t.matches(targetSelector)) {\n      // 如果是目标元素则跳出循环\n        if(t === currentTarget) {\n        t = null;\n          break;\n        }\n        t = t.parentNode;\n    }\n\n    if(t) {\n    // 将回调函数的 this 指向目标元素\n    fn.call(t, Array.prototype.slice.call(arguments));\n    }\n    \n  });\n}\n```\n\n* 实例\n```html\n<ul id=\"myLink\">\n  <li id=\"1\" class=\"link\"><a href=\"javascript:;\"><span>aaa</span></a></li>\n  <li id=\"2\" class=\"link\"><a href=\"javascript:;\">bbb</a></li>\n  <li id=\"3\" class=\"link\">ccc</li>\n</ul>\n\n<script type=\"text/javascript\">\n  var myLink = document.querySelector('#myLink');\n  delegateEvent(myLink, 'li.link', 'click', function() {\n    console.log(this, this.id + '：' + this.innerText);\n  });\n</script>\n```\n\n-----\n创建时间  2017-11-18 By MarlonChiu \n\n\n\n\n","slug":"前端面试题积累","published":1,"updated":"2021-07-19T05:53:09.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrd8jv1b0009kwztcs59fday","content":"<h1 id=\"前端面试题积累\"><a href=\"#前端面试题积累\" class=\"headerlink\" title=\"前端面试题积累\"></a>前端面试题积累</h1><p>标签（空格分隔）： Summarize Interview</p>\n<hr>\n<h2 id=\"vue构造器以及实例属性\"><a href=\"#vue构造器以及实例属性\" class=\"headerlink\" title=\"vue构造器以及实例属性\"></a>vue构造器以及实例属性</h2><ul>\n<li><p>构造器</p>\n<ul>\n<li>Vue.js是一个构造函数，编程中称之为构造器。</li>\n<li>每一个new Vue() 都是一个Vue构造函数的实例，这个过程叫做实例化。  </li>\n<li>构造函数需要将其实例化后才会启用。  </li>\n<li>Vue构造器要求实例化时需要传入一个选项对象。    </li>\n<li>选项对象包括数据(data)，模板(tamplate)，挂载元素(el)，方法(methods)，生命周期钩子等选项。</li>\n<li>每个 Vue.js应用都是通过构造函数Vue创建一个 Vue 的根实例启动的。在文档中经常会使用 vm (ViewModel 的简称)这个变量名表示 Vue 实例。</li>\n</ul>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//vue的实例化</span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  // 选项</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以扩展构造器Vue，从而用预定义选项创建可复用的组件构造器，所有组件都是被扩展的Vue的实例，使用 <code>Vue.extend(&#123;&#125;)</code>来扩展；</li>\n</ul>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var MyComponent = Vue.extend(&#123;</span><br><span class=\"line\">\t// 扩展选项</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 所有的MyComponent实例都将以预定义的扩展选项被创建</span><br><span class=\"line\">// 相当于MyComponent继承Vue并且加上扩展的选项</span><br><span class=\"line\"></span><br><span class=\"line\">// MyComponent()相当于扩展后的vue，而myComponentInstance 就是扩展后vue的实例。</span><br><span class=\"line\">var myComponentInstance = new MyComponent();</span><br></pre></td></tr></table></figure></li>\n<li><p>属性与方法</p>\n<ul>\n<li>每个Vue的实例都会代理其data对象里的所有属性，被代理的属性是响应的；  </li>\n<li>如果实例创建之后添加新的属性到实例上，不会触发视图更新；</li>\n<li>不要在实例属性或者回调函数中使用箭头函数（如 <code>vm.$watch(&#39;a&#39;, newVal =&gt; this.myMethod())</code>）。因为箭头函数绑定父上下文，所以 this 不会像预想的一样是 Vue 实例，而是<code>this.myMethod</code>未被定义。</li>\n<li>Vue实例暴露了一些有用的实例属性和方法，带有前缀 <code>$</code>，便于与代理的data区分<ul>\n<li><code>vm.$el</code>：类型（HTMLElement）挂载元素，Vue实例的DOM根元素；</li>\n<li><code>vm.$data</code>：类型（Object），Vue实例观察的数据对象；</li>\n<li><code>vm.$props</code>：类型（Object）。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"手写实现-throttle-（节流）函数\"><a href=\"#手写实现-throttle-（节流）函数\" class=\"headerlink\" title=\"手写实现 throttle （节流）函数\"></a>手写实现 <code>throttle</code> （节流）函数</h2><h3 id=\"什么是throttle\"><a href=\"#什么是throttle\" class=\"headerlink\" title=\"什么是throttle\"></a>什么是throttle</h3><ul>\n<li><p>定义：如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。</p>\n</li>\n<li><p>接口定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 频率控制 返回函数连续调用时，action 执行频率限定为 次 / delay</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param </span>delay  &#123;number&#125;    延迟时间，单位毫秒</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param </span>action &#123;function&#125;  请求关联函数，实际应用需要调用的函数</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@return <span class=\"type\">&#123;function&#125;</span>    </span>返回客户调用函数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">throttle(delay,action)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"简单实现\"><a href=\"#简单实现\" class=\"headerlink\" title=\"简单实现\"></a>简单实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">delay, action</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> last = 0<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> curr = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (curr - last &gt; delay)&#123;</span><br><span class=\"line\">      action.apply(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">      last = curr </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"拓展延伸\"><a href=\"#拓展延伸\" class=\"headerlink\" title=\"拓展延伸\"></a>拓展延伸</h3><p><a href=\"https://www.cnblogs.com/fsjohnhuang/p/4147810.html\">函数节流（throttle）与函数去抖（debounce）</a></p>\n<h2 id=\"css实现自适应的正方形\"><a href=\"#css实现自适应的正方形\" class=\"headerlink\" title=\"css实现自适应的正方形\"></a>css实现自适应的正方形</h2><ul>\n<li><p>padding-bottom实现</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;square-shape&quot;</span>&gt;</span>这是一个可以自适应的正方形，此法很好用，有内容也是正方形。<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">.square-shape &#123;</span><br><span class=\"line\">  width: 30%;</span><br><span class=\"line\">  height: 0;</span><br><span class=\"line\">  padding-bottom: 30%;</span><br><span class=\"line\">  border: 1px solid #f00;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>伪元素的padding-bottom，内嵌absolute元素</p>\n</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;square-shape&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;content&quot;</span>&gt;</span>这是一个可以自适应的正方形<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">.square-shape &#123;</span><br><span class=\"line\">  width: 50%;</span><br><span class=\"line\">  border: 1px solid #f00;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.square-shape:after &#123;</span><br><span class=\"line\">  content: &#x27;&#x27;;</span><br><span class=\"line\">  display: block;</span><br><span class=\"line\">  padding-bottom: 100%;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.content &#123;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  height: 100%;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"手写实现以下事件委托函数\"><a href=\"#手写实现以下事件委托函数\" class=\"headerlink\" title=\"手写实现以下事件委托函数\"></a>手写实现以下事件委托函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 手写实现以下事件委托函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delegate</span>(<span class=\"params\">parent, selector, handle</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>事件委托，通俗来说就是将元素的事件委托给它的父级或者更外级元素处理。</p>\n</li>\n<li><p>需要注意的地方：</p>\n<ul>\n<li>保证兼容性，包括：事件绑定、元素选择器 Element.matches 、事件 event 对象</li>\n<li>回调函数 this 指向</li>\n<li>当目标元素下还有子元素时，子元素不能触发事件。<br>解决办法是在触发过程中对元素进行判断，如果当前触发的元素不是目标元素，就继续往该元素的 parentNode 查找，否则循环结束。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/ *</span><br><span class=\"line\">  * [delegateEvent description]</span><br><span class=\"line\">  * @param  &#123;[type]&#125;   parentSelector 父元素</span><br><span class=\"line\">  * @param  &#123;[type]&#125;   targetSelector 目标元素</span><br><span class=\"line\">  * @param  &#123;[type]&#125;   events         事件</span><br><span class=\"line\">  * @param  &#123;<span class=\"built_in\">Function</span>&#125; fn             回调函数</span><br><span class=\"line\">  * @<span class=\"keyword\">return</span> &#123;[type]&#125;                  <span class=\"literal\">null</span></span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delegateEvent</span>(<span class=\"params\">parentSelector, targetSelector, events, fn</span>) </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 事件绑定浏览器兼容性处理</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addEvent</span>(<span class=\"params\">ele, type, handle</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ele.addEventListener) &#123;</span><br><span class=\"line\">      ele.addEventListener(type, handle, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ele.attachEvent)&#123;</span><br><span class=\"line\">      ele.attachEvent(<span class=\"string\">&#x27;on&#x27;</span> + type, handle);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      ele[<span class=\"string\">&#x27;on&#x27;</span> + type] = handle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 如果元素被指定的选择器字符串选择， Element.matches() 方法返回 true; 否则返回 false。</span></span><br><span class=\"line\">  <span class=\"comment\">// 对于不支持 Element.matches() 或 Element.matchesSelector()，但支持 document.querySelectorAll() 方法的浏览器，存在以下替代方案</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!Element.prototype.matches) &#123;</span><br><span class=\"line\">    Element.prototype.matches =</span><br><span class=\"line\">    Element.prototype.matchesSelector ||</span><br><span class=\"line\">    Element.prototype.mozMatchesSelector ||</span><br><span class=\"line\">    Element.prototype.msMatchesSelector ||</span><br><span class=\"line\">    Element.prototype.oMatchesSelector ||</span><br><span class=\"line\">    Element.prototype.webkitMatchesSelector ||</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> matches = (<span class=\"built_in\">this</span>.document || <span class=\"built_in\">this</span>.ownerDocument).querySelectorAll(s),</span><br><span class=\"line\">          i = matches.length;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (--i &gt;= <span class=\"number\">0</span> &amp;&amp; matches.item(i) !== <span class=\"built_in\">this</span>) &#123;&#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> i &gt; -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 事件处理逻辑</span></span><br><span class=\"line\">  addEvent(parentSelector, events, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 兼容性处理</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> e = e || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> t = e.target || e.srcElement;</span><br><span class=\"line\">    <span class=\"comment\">// currentTarget === parentSelector</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentTarget = e.currentTarget;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历并判断是否为目标元素，如果不是，则往元素的 parentNode 继续查找</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!t.matches(targetSelector)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果是目标元素则跳出循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(t === currentTarget) &#123;</span><br><span class=\"line\">        t = <span class=\"literal\">null</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        t = t.parentNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(t) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将回调函数的 this 指向目标元素</span></span><br><span class=\"line\">    fn.call(t, <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>实例</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;myLink&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;1&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;link&quot;</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;javascript:;&quot;</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>aaa<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;2&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;link&quot;</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;javascript:;&quot;</span>&gt;</span>bbb<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;3&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;link&quot;</span>&gt;</span>ccc<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> myLink = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&#x27;#myLink&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  delegateEvent(myLink, <span class=\"string\">&#x27;li.link&#x27;</span>, <span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>, <span class=\"built_in\">this</span>.id + <span class=\"string\">&#x27;：&#x27;</span> + <span class=\"built_in\">this</span>.innerText);</span></span><br><span class=\"line\"><span class=\"javascript\">  &#125;);</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<p>创建时间  2017-11-18 By MarlonChiu </p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h1 id=\"前端面试题积累\"><a href=\"#前端面试题积累\" class=\"headerlink\" title=\"前端面试题积累\"></a>前端面试题积累</h1><p>标签（空格分隔）： Summarize Interview</p>\n<hr>\n<h2 id=\"vue构造器以及实例属性\"><a href=\"#vue构造器以及实例属性\" class=\"headerlink\" title=\"vue构造器以及实例属性\"></a>vue构造器以及实例属性</h2><ul>\n<li><p>构造器</p>\n<ul>\n<li>Vue.js是一个构造函数，编程中称之为构造器。</li>\n<li>每一个new Vue() 都是一个Vue构造函数的实例，这个过程叫做实例化。  </li>\n<li>构造函数需要将其实例化后才会启用。  </li>\n<li>Vue构造器要求实例化时需要传入一个选项对象。    </li>\n<li>选项对象包括数据(data)，模板(tamplate)，挂载元素(el)，方法(methods)，生命周期钩子等选项。</li>\n<li>每个 Vue.js应用都是通过构造函数Vue创建一个 Vue 的根实例启动的。在文档中经常会使用 vm (ViewModel 的简称)这个变量名表示 Vue 实例。</li>\n</ul>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//vue的实例化</span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  // 选项</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以扩展构造器Vue，从而用预定义选项创建可复用的组件构造器，所有组件都是被扩展的Vue的实例，使用 <code>Vue.extend(&#123;&#125;)</code>来扩展；</li>\n</ul>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var MyComponent = Vue.extend(&#123;</span><br><span class=\"line\">\t// 扩展选项</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 所有的MyComponent实例都将以预定义的扩展选项被创建</span><br><span class=\"line\">// 相当于MyComponent继承Vue并且加上扩展的选项</span><br><span class=\"line\"></span><br><span class=\"line\">// MyComponent()相当于扩展后的vue，而myComponentInstance 就是扩展后vue的实例。</span><br><span class=\"line\">var myComponentInstance = new MyComponent();</span><br></pre></td></tr></table></figure></li>\n<li><p>属性与方法</p>\n<ul>\n<li>每个Vue的实例都会代理其data对象里的所有属性，被代理的属性是响应的；  </li>\n<li>如果实例创建之后添加新的属性到实例上，不会触发视图更新；</li>\n<li>不要在实例属性或者回调函数中使用箭头函数（如 <code>vm.$watch(&#39;a&#39;, newVal =&gt; this.myMethod())</code>）。因为箭头函数绑定父上下文，所以 this 不会像预想的一样是 Vue 实例，而是<code>this.myMethod</code>未被定义。</li>\n<li>Vue实例暴露了一些有用的实例属性和方法，带有前缀 <code>$</code>，便于与代理的data区分<ul>\n<li><code>vm.$el</code>：类型（HTMLElement）挂载元素，Vue实例的DOM根元素；</li>\n<li><code>vm.$data</code>：类型（Object），Vue实例观察的数据对象；</li>\n<li><code>vm.$props</code>：类型（Object）。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"手写实现-throttle-（节流）函数\"><a href=\"#手写实现-throttle-（节流）函数\" class=\"headerlink\" title=\"手写实现 throttle （节流）函数\"></a>手写实现 <code>throttle</code> （节流）函数</h2><h3 id=\"什么是throttle\"><a href=\"#什么是throttle\" class=\"headerlink\" title=\"什么是throttle\"></a>什么是throttle</h3><ul>\n<li><p>定义：如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。</p>\n</li>\n<li><p>接口定义</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* 频率控制 返回函数连续调用时，action 执行频率限定为 次 / delay</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param </span>delay  &#123;number&#125;    延迟时间，单位毫秒</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param </span>action &#123;function&#125;  请求关联函数，实际应用需要调用的函数</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@return <span class=\"type\">&#123;function&#125;</span>    </span>返回客户调用函数</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">throttle(delay,action)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"简单实现\"><a href=\"#简单实现\" class=\"headerlink\" title=\"简单实现\"></a>简单实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> throttle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">delay, action</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> last = 0<span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> curr = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (curr - last &gt; delay)&#123;</span><br><span class=\"line\">      action.apply(<span class=\"built_in\">this</span>, <span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">      last = curr </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"拓展延伸\"><a href=\"#拓展延伸\" class=\"headerlink\" title=\"拓展延伸\"></a>拓展延伸</h3><p><a href=\"https://www.cnblogs.com/fsjohnhuang/p/4147810.html\">函数节流（throttle）与函数去抖（debounce）</a></p>\n<h2 id=\"css实现自适应的正方形\"><a href=\"#css实现自适应的正方形\" class=\"headerlink\" title=\"css实现自适应的正方形\"></a>css实现自适应的正方形</h2><ul>\n<li><p>padding-bottom实现</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;square-shape&quot;</span>&gt;</span>这是一个可以自适应的正方形，此法很好用，有内容也是正方形。<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">.square-shape &#123;</span><br><span class=\"line\">  width: 30%;</span><br><span class=\"line\">  height: 0;</span><br><span class=\"line\">  padding-bottom: 30%;</span><br><span class=\"line\">  border: 1px solid #f00;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>伪元素的padding-bottom，内嵌absolute元素</p>\n</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;square-shape&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;content&quot;</span>&gt;</span>这是一个可以自适应的正方形<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">.square-shape &#123;</span><br><span class=\"line\">  width: 50%;</span><br><span class=\"line\">  border: 1px solid #f00;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.square-shape:after &#123;</span><br><span class=\"line\">  content: &#x27;&#x27;;</span><br><span class=\"line\">  display: block;</span><br><span class=\"line\">  padding-bottom: 100%;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.content &#123;</span><br><span class=\"line\">  position: absolute;</span><br><span class=\"line\">  width: 100%;</span><br><span class=\"line\">  height: 100%;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"手写实现以下事件委托函数\"><a href=\"#手写实现以下事件委托函数\" class=\"headerlink\" title=\"手写实现以下事件委托函数\"></a>手写实现以下事件委托函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 手写实现以下事件委托函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delegate</span>(<span class=\"params\">parent, selector, handle</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>事件委托，通俗来说就是将元素的事件委托给它的父级或者更外级元素处理。</p>\n</li>\n<li><p>需要注意的地方：</p>\n<ul>\n<li>保证兼容性，包括：事件绑定、元素选择器 Element.matches 、事件 event 对象</li>\n<li>回调函数 this 指向</li>\n<li>当目标元素下还有子元素时，子元素不能触发事件。<br>解决办法是在触发过程中对元素进行判断，如果当前触发的元素不是目标元素，就继续往该元素的 parentNode 查找，否则循环结束。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/ *</span><br><span class=\"line\">  * [delegateEvent description]</span><br><span class=\"line\">  * @param  &#123;[type]&#125;   parentSelector 父元素</span><br><span class=\"line\">  * @param  &#123;[type]&#125;   targetSelector 目标元素</span><br><span class=\"line\">  * @param  &#123;[type]&#125;   events         事件</span><br><span class=\"line\">  * @param  &#123;<span class=\"built_in\">Function</span>&#125; fn             回调函数</span><br><span class=\"line\">  * @<span class=\"keyword\">return</span> &#123;[type]&#125;                  <span class=\"literal\">null</span></span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">delegateEvent</span>(<span class=\"params\">parentSelector, targetSelector, events, fn</span>) </span>&#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 事件绑定浏览器兼容性处理</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addEvent</span>(<span class=\"params\">ele, type, handle</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(ele.addEventListener) &#123;</span><br><span class=\"line\">      ele.addEventListener(type, handle, <span class=\"literal\">false</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ele.attachEvent)&#123;</span><br><span class=\"line\">      ele.attachEvent(<span class=\"string\">&#x27;on&#x27;</span> + type, handle);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      ele[<span class=\"string\">&#x27;on&#x27;</span> + type] = handle;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 如果元素被指定的选择器字符串选择， Element.matches() 方法返回 true; 否则返回 false。</span></span><br><span class=\"line\">  <span class=\"comment\">// 对于不支持 Element.matches() 或 Element.matchesSelector()，但支持 document.querySelectorAll() 方法的浏览器，存在以下替代方案</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!Element.prototype.matches) &#123;</span><br><span class=\"line\">    Element.prototype.matches =</span><br><span class=\"line\">    Element.prototype.matchesSelector ||</span><br><span class=\"line\">    Element.prototype.mozMatchesSelector ||</span><br><span class=\"line\">    Element.prototype.msMatchesSelector ||</span><br><span class=\"line\">    Element.prototype.oMatchesSelector ||</span><br><span class=\"line\">    Element.prototype.webkitMatchesSelector ||</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">s</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> matches = (<span class=\"built_in\">this</span>.document || <span class=\"built_in\">this</span>.ownerDocument).querySelectorAll(s),</span><br><span class=\"line\">          i = matches.length;</span><br><span class=\"line\">      <span class=\"keyword\">while</span> (--i &gt;= <span class=\"number\">0</span> &amp;&amp; matches.item(i) !== <span class=\"built_in\">this</span>) &#123;&#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> i &gt; -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 事件处理逻辑</span></span><br><span class=\"line\">  addEvent(parentSelector, events, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 兼容性处理</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> e = e || <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> t = e.target || e.srcElement;</span><br><span class=\"line\">    <span class=\"comment\">// currentTarget === parentSelector</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentTarget = e.currentTarget;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 遍历并判断是否为目标元素，如果不是，则往元素的 parentNode 继续查找</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(!t.matches(targetSelector)) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果是目标元素则跳出循环</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(t === currentTarget) &#123;</span><br><span class=\"line\">        t = <span class=\"literal\">null</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        t = t.parentNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(t) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 将回调函数的 this 指向目标元素</span></span><br><span class=\"line\">    fn.call(t, <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>实例</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;myLink&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;1&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;link&quot;</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;javascript:;&quot;</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>aaa<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;2&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;link&quot;</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;javascript:;&quot;</span>&gt;</span>bbb<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;3&quot;</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;link&quot;</span>&gt;</span>ccc<span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"javascript\"></span></span><br><span class=\"line\"><span class=\"javascript\">  <span class=\"keyword\">var</span> myLink = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">&#x27;#myLink&#x27;</span>);</span></span><br><span class=\"line\"><span class=\"javascript\">  delegateEvent(myLink, <span class=\"string\">&#x27;li.link&#x27;</span>, <span class=\"string\">&#x27;click&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span></span><br><span class=\"line\"><span class=\"javascript\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>, <span class=\"built_in\">this</span>.id + <span class=\"string\">&#x27;：&#x27;</span> + <span class=\"built_in\">this</span>.innerText);</span></span><br><span class=\"line\"><span class=\"javascript\">  &#125;);</span></span><br><span class=\"line\"><span class=\"javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<p>创建时间  2017-11-18 By MarlonChiu </p>\n"},{"title":"常用前端面试参考总结","date":"2021-03-18T00:00:00.000Z","type":"技术","note":"原型与原型链、Webpack及构建工具的理解、客户端存储、类的继承","_content":"\n# 常用前端面试参考总结\n\n标签（空格分隔）： Summarize Interview\n\n---\n## 原型与原型链\n### 原型\n* 函数的prototype属性(图)\n   * 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)\n   * 原型对象中有一个属性constructor, 它指向函数对象\n* 给原型对象添加属性(一般都是方法)\n   * 作用: 函数的所有实例对象自动拥有原型中的属性(方法)\n   * 原型对象上的方法一般给其实例对象调用\n\n### 显式原型与隐式原型\n* 每个函数对象function都有一个prototype，即显式原型\n* 每个实例对象都有一个 `__proto__` ，可称为隐式原型\n* 对象的隐式原型的值为其对应构造函数的显式原型的值 ===> 都指向函数对象\n* 内存结构(图)\n* 总结:\n   * 函数的prototype属性： 在定义函数时自动添加的，默认值是一个空Object对象\n   * 对象的`__proto__`属性：创建对象时自动添加的，默认值为构造函数的prototype属性值\n   * 程序员能直接操作显式原型，但不能直接操作隐式原型(ES6之前)\n* 举个例子\n\n```\n// Fn()\nvar Fn = function () {}  // 执行这条函数定义语句, 函数体并没有执行\n\n// 每个函数function都有一个prototype，即显式原型(属性)\nconsole.log(Fn.prototype)\n\n// 每个实例对象都有一个__proto__，可称为隐式原型(属性)\nvar fn = new Fn()\nconsole.log(fn.__proto__)\n\n// 对象的隐式原型的值为其对应构造函数的显式原型的值\nconsole.log(fn.__proto__ === Fn.prototype)  // true\n\n/*\n 1. prototype属性: 函数对象\n    什么时候添加? 函数被定义时(创建函数对象时自动添加)\n    值是多少?  空的object实例对象: this.prototype = {}  this.prototype.constructor = this\n\n2. __proto__属性: 实例对象\n    什么时候添加? 创建实例对象时自动添加\n    值是多少?   构造函数的prototype属性值: this.__proto__ = Fn.prototype\n */\n\n/*\n    执行函数: 执行函数体中的所有语句\n    执行函数定义: 本质是创建函数对象\n*/\nconsole.log(Object.prototype.__proto__);  // null\n```\n\n### 原型链\n* 原型链(图解)\n* 访问一个对象的属性时，\n   * 先在自身属性中查找，找到返回\n   * 如果没有,再沿着`__proto__`这条链向上查找, 找到返回\n   * 如果最终没找到,返回undefined\n* 别名：隐式原型链\n* 作用：**查找对象的属性(方法)**\n* 构造函数/原型/实体对象的关系(图解)\n* 构造函数/原型/实体对象的关系2(图解)\n* 举个例子\n```\nconsole.log(Function.prototype===Function.__proto__)  // true\nconsole.log(Object.prototype.__proto__)  // null\nconsole.log(Object.prototype)\nfunction Fn() {\n    this.test1 = function () {\n        console.log('test1()')\n    }\n}\nFn.prototype.test2 = function () {\n    console.log('test2()')\n}\nvar fn = new Fn()\n\nfn.test1()\nfn.test2()\nconsole.log(fn.toString())\nconsole.log(fn.test3)  // undefined\nfn.test3()\n\n// 详情请看githubMarkdownPhotos分析图\n```\n* **原型链总结**\n   * 查找对象的属性沿着原型链查找，查找变量沿着作用域链查找\n   * 函数对象既有`prototype`属性，也有`__proto__`属性（函数的本质是被new出来的）\n   * 所有函数对象的`__proto__`属性值都相等，都等于大写的Function的 `prototype`\n   * 所有函数都是Function的实例，包括它自己。\n    `Function.prototype === Function.__proto__ // true`\n   * 非函数对象（实例对象）肯定是其对应构造函数的实例\n\n### 原型链的属性问题\n* 读取对象的属性值时: 会自动到原型链中查找\n* 设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值\n* 即：**当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作**\n* 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上\n* 举个例子\n\n```\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\nPerson.prototype.setName = function (name) {\n    this.name = name;\n}\nPerson.prototype.sex = '男';\n\nvar p1 = new Person('Tom', 12)\np1.setName('Jack')\nconsole.log(p1.name, p1.age, p1.sex) // Jack 12 '男'\n\np1.sex = '女'  // 设置属性值时, 不会查看原型链\nconsole.log(p1.name, p1.age, p1.sex) //Jack 12 '女'\n\nvar p2 = new Person('Bob', 23)\nconsole.log(p2.name, p2.age, p2.sex) //'Bob' 23 '男'\n```\n\n### 探索instanceof\n* instanceof是如何判断的?\n   * 表达式: A instanceof B\n   * 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false\n   * A可以寻找多步，B只能找一步到自己的显式原型上\n* Function是通过new自己产生的实例。即所有函数都是Function的实例包括它自身。\n* 几点总结\n   * `Object created by Function`\n   * `Object 是 Function 的实例`\n   * `Object 是 Object 的实例`\n* 理解实例\n\n```\nconsole.log(Object instanceof Function) // true\nconsole.log(Object instanceof Object) // true\nconsole.log(Function instanceof Object) // true\nconsole.log(Function instanceof Function) // true\nconsole.log(Object instanceof Foo); // false\n\nconsole.log(Function.prototype) // 不是Object的实例  ƒ () { [native code] }\nconsole.log(Function.prototype.__proto__===Object.prototype) // true\n```\n\n* 原型与原型链分析详图\n```\nfunction Foo () {}\nvar f1 = new Foo()\nvar f2 = new Foo()\nvar o1 = {}\nvar o2 = {}\n```\n![原型与原型链分析](https://i.imgur.com/Q3nxgq6.png)\n\n### 面试题及总结\n```\n// 测试题 1\nvar A = function() {}\nA.prototype.n = 1\nvar b = new A()\n\nA.prototype = {\n    n: 2,\n    m: 3\n}\nvar c = new A()\nconsole.log(b.n, b.m, c.n, c.m) //  1 undefined  2  3\n\n// 测试题2\nvar F = function(){};\nObject.prototype.a = function(){\n    console.log('a()')\n};\nFunction.prototype.b = function(){\n    console.log('b()')\n};\nvar f = new F();\nf.a()     // a()\nf.b()     // f.b is not a function\nF.a()     // a()\nF.b()     // b()\n\n\n<!--\n原型链（隐式原型链）：作用查找对象的属性\n    访问一个对象的属性时，先在自身属性中查找，找到返回；\n    如果没有再沿着 __proto__ 这条链向上查找，找到返回，如果最终没有找到，则返回undefined\n\nA instanceof B  的判断\n    如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false\n\nprototype 与 __proto__ 在创建的时候相关联，在执行的时候没有关联\n-->\n```\n\n\n\n## webpack及构建工具的理解\n### 构建工具的功能\n* **代码转换**：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。（开发写的代码有些浏览器无法识别，如ES6语法）\n* **文件优化**：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。（压缩代码）\n* **模块合并**：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。\n* **代码分割**：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。\n* **自动刷新**：监听本地源代码的变化，自动重新构建、刷新浏览器。 live reload 自动刷新 / hot reload 热模替换（HMR）（开发环境下修改代码后可以自动刷新浏览器看到最新的效果，可以监视源码的变化）\n* **代码校验**：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。\n\n### 模块化打包和非模块化打包思想差异\n* 非模块化打包：先对文件进行分类（如js/img/css等），然后分别打包\n* 模块化打包：将所有资源看成模块，而所有的模块之间都是有关系的，项目中的资源是相互关联的节点通过入口js形成一个网(图)的结构。\n   * 从入口开始递归的查找所有相关联的模块\n   * 找到一个模块(如css)后会找对应的loader，模块文件会进行正则匹配的\n   * 四个核心概念：entry | output | module(loader) | plugins\n   * loader模块加载器，将非js模块打包成webpack能理解的js模块\n   * 图片处理推荐使用 `url-loader`，配置选项可以对图片进行限制，小于此限制的会会通过base64处理的\n\n### webpack的核心概念\n* **Entry**：入口，Webpack进行打包的起始点(文件)\n* **Output**：出口，webpack编译打包生成的bundle(文件)\n* **Loader**：模块加载(转换)器，将非js模块包装成webpack能理解的js模块\n   * （举例：如处理css要用到style-loader/css-loader;处理img使用file-loader/url-loader）\n* **Plugin**：插件，在Webpack构建流程中的特定时机插入具有特定功能的代码\n   * （举例：CleanPlugin一开始就会清除指定的文件/夹；\n   * ExtractTextPlugin用于样式的抽取，用来从js中分离出css并单独打包；\n   * CopyPlugin复制静态资源；\n   * webpack.HashedModuleIdsPlugin根据代码内容生成hash作为模块的id(默认是下标)；\n   * webpack.optimize.CommonsChunkPlugin将第三方模块单独打包\n   * ……） \n* Module：模块，在 Webpack眼里一切皆模块，默认只识别js文件，如果是其它类型文件利用对应的loader转换为js模块\n* Chunk：代码块，一个 Chunk 由多个模块组合而成，最终浏览器执行的是webpack打包生成的chunk文件(bundle同理)\n\n### webpack的其他概念\n* ![webpack其它概念_1.png-39.4kB][1]\n* ![webpack其它概念_2.png-27.8kB][2]\n\n### webpack 和 gulp 的区别\n* webpack 是一种模块化打包工具，主要用于模块化方案，预编译模块的方案；\n* gulp 是工具链、构建工具，可以配合各种插件做 js 压缩，css压缩，less 编译替代手工实现自动化工作。\n* Grunt/Gulp 更多的是一种工作流；提供集成所有服务的一站式平台； gulp可以用来优化前端工作流程。\n\n## 客户端两种存储\n### Cookie存储\n```\nCookie是一项很老的技术的，就是因为它老，所以兼容性还是不错的。\n使用Cookie作为本地存储优点：兼容性好，缺点：操作繁琐，只能存简单的数据，还会过期，站点设置httponly的话，JS就不无法操作Cookie了。\n```\n\n### Web Storage存储\n```\nWebStorage是HTML5中为WebApplication提供一种存储的API，目前主流的新版本的浏览器都支持，当然IE789你就没有办法了。WebStorage主要分成localStorage和sessionStorage两种。\n```\n\n#### sessionStorage\n```\nsessionStorage是个全局对象，它维护着在页面会话(page session)期间有效的存储空间。只要浏览器开着，页面会话周期就会一直持续。当页面重新载入(reload)或者被恢复(restores)时，页面会话也是一直存在的。每在新标签或者新窗口中打开一个新页面，都会初始化一个新的会话。\n```\n\n#### localStorage\n```\nlocalStorage也是一个全局变量，它的生命周期比sessionStorage长。localStorage和sessionStorage都继承自Storage因此它们的用法相同。\n```\n\n#### WebStorage的优点\n```\n使用简单方便，缺点：IE有些版本不支持，不能存复杂的对象，必须先转化成JSON字符串，没有索引搜索效率不高，只能同步读写操作，当写入的数据比较大时可能造成JS引擎堵塞。\n```\n\n#### sessionStorage用法和localStorage区别\n```\n完全一致，差别只在有效期：\nsessionStorage在用户结束会话（即关闭浏览器或退出账户时失效）；\nlocalStorage无失效期，用户在清理浏览器缓存的时候会被清除。\n```\n\n### Cookie存储和Web Storage存储区别\n```\nlocalStorage与sessionStorage作为新时代的产物，相比旧时代的cookie有其巨大的优越性。优越性有三:\n    其一在能存储的数据量，cookie最大能存储4kb的数据，而localStorage与sessionStorage最大能存储5Mb，目前各大浏览器支持的标准都是如此；\n    \n    其二在功能上，cookie只能存储String类型的数据，以往要将用户数据存储在本地，需要将数据拼接成字符串，再存进cookie,取数据的时候同样麻烦，先将整个cookie对象拿到（String对象），再按拼接的规则拆分，再拿需要的数据，存取都很麻烦！\n    localStorage与sessionStorage不仅支持传统的String类型，还可以将json对象存储进去,存取数据都方便不少，json的优越性就不赘述，localStorage与sessionStorage无疑更现代化；\n    \n    其三是cookie是不可或缺的，cookie的作用是与服务器进行交互，作为http规范的一部分而存在；而web storage仅仅是为了在本地‘存储’而生；\n    其四在语义层面上，localStorage与sessionStorage语法更优雅、简便。\n```\n\n### 存储方式的操作对比演示\n```\n// cookie的操作\n设置cookie: document.cookie = 'key=value';\n获取cookie: document.cookie;\n删除cookie: document.cookie = \"key=value;max-age=0\";\n设置max-age存储期限: document.cookie = \"key=value;max-age=1000\"; // 1000秒\n\n// web storage操作\n保存数据 setItem(key,value)\n读取数据 getItem(key)\n删除单个数据 removeItem(key)\n清空全部数据 clearItem()\n获取数据索引 key(index)\n```\n\n### cookie / storage / session 关系\n* cookie\n   * 优点：可以解决http无状态问题 \n   * 缺点：\n     1) 与服务器交互的时候有数量和长度限制 每个域名最多20条，长度不能超过4KB  \n     2) 安全性问题 容易被人拦截 \n     3) 浪费宽带，每次请求新页面，cookie都会被发过去 \n     4) 不可以跨域  \n\n\n* cookie 和session区别\n   * cookie是把数据放在客户的浏览器上，只能存储sting类型\n   * session数据是放在服务器上，能存储json 类型、sting类型\n   * session会在一定的时间内保留数据存在服务器上，当访问增多，\n会比较占你服务器的性能 ，减轻服务器的性能 应当使用cookie\n   * sessionStorage是当前对话的缓存，浏览器窗口关闭即消失，会话级别的存储\n   * localStorage持久存在，除非清除浏览器缓存。\n\n## 数组的一些方法\n### 数组去重\n```javascript\n/*\n1.先将原数组进行排序\n2.检查原数组中的第i个元素 与 结果数组中的最后一个元素是否相同，因为已经排序，所以重复元素会在相邻位置\n3.如果不相同，则将该元素存入结果数组中\n*/\nArray.prototype.unique1 = function(){\n    this.sort(); //先排序\n    var res = [this[0]];\n    for(var i = 1; i < this.length; i++){\n    if(this[i] !== res[res.length - 1]){\n        res.push(this[i]);\n    }\n}\n    return res;\n}\n  \n/*\n1.创建一个新的数组存放结果\n2.创建一个空对象\n3.for循环时，每次取出一个元素与对象进行对比，如果这个元素不重复，\n  则把它存放到结果数组中，同时把这个元素的内容作为对象的一个属性，\n  并赋值为1，存入到第2步建立的对象中。\n说明：至于如何对比，就是每次从原数组中取出一个元素，然后到对象中去访问这个属性，如果能访问到值，则说明重复。\n*/\nArray.prototype.unique2 = function(){\n    var res = [];\n    var json = {};\n    for(var i = 0; i < this.length; i++){\n        if(!json[this[i]]){\n            res.push(this[i]);\n            json[this[i]] = 1;\n        }\n    }\n    return res;\n}\n\nvar arr2 = [112,112,34,'你好',112,112,34,'你好','str','str1'];\nvar arr = [1,7,3,4,11,2,3,2,0];\n// 方法零\nconsole.log(new Set(arr));  // Set(7) {1, 7, 3, 4, 11, 2, 0}\n// 方法一\nconsole.log(arr.unique1()); // (7) [0, 1, 11, 2, 3, 4, 7]  按照Unicode排列了\n// 方法二\nconsole.log(arr.unique2()); // (7) [0, 1, 11, 2, 3, 4, 7]\n```\n\n### 数组排序\n```\nfunction quickSort(arr) {\n  if(arr.length <= 1){\n    return arr;\n  }\n  // 基准索引（理论上可以任意选取）\n  var pivotIndex = parseInt(arr.length/2),\n    // 基准值\n    pivot = arr.splice(pivotIndex,1)[0],\n    leftArr = [],\n    rightArr = [],\n    length = arr.length;\n  // 遍历序列，根据基准拆分为两个子序列\n  for (var i = 0; i < length; i++) {\n    if(arr[i] < pivot){\n      leftArr.push(arr[i]);\n    }else {\n      rightArr.push(arr[i]);\n    }\n    \n  }\n  console.log(pivot); // 输出了三次 3 1 7\n  \n  // 连接左序列、基准、右序列\n  return quickSort(leftArr).concat(pivot, quickSort(rightArr))\n}\nvar demoArr = [8,4,7,2,0,3,1]\n\n// 方法一\nconsole.log(demoArr.sort()); // (7) [0, 1, 2, 3, 4, 7, 8]\n// 方法二\nconsole.log(quickSort(demoArr)) // (7) [0, 1, 2, 3, 4, 7, 8]\n```\n\n## 前端WEB/H5性能优化\n\n```\n// 参考CSDN博客\nhttp://blog.csdn.net/lpf1215/article/details/74315797?locationNum=8&fps=1\n```\n\n* 减少http请求，合理设置 HTTP缓存\n* 使用浏览器缓存\n* 启用压缩\n* CSS Sprites\n* LazyLoad Images\n* CSS放在页面最上部，javascript放在页面最下面\n* 异步请求Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容）\n* 减少cookie传输\n* Javascript代码优化\n* CSS选择符优化\n* CDN加速\n* 反向代理\n\n## px em rem 区别\n* px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的\n* em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸\n* rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素\n\n## 实现一个jsonp请求\n```\n<script type=\"text/javascript\">\nfunction jsonpCallback(result) {\n    // alert(result);  \n    for(var i in result) {\n        alert(i+\":\"+result[i]);// 循环输出a:1,b:2,etc.  \n    }\n}\n\nvar JSONP = document.createElement(\"script\");\nJSONP.type = \"text/javascript\";\nJSONP.src = \"http://crossdomain.com/services.php?callback=jsonpCallback\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(JSONP);\n</script>\n```\n\n## 原型与原型链分析图例\n* 图例一\n![原型链分析图例_01.png-35.1kB][3]\n```\n// 图例分析说明\n```\n\n* 图例二\n![原型链分析图例_02.png-46.7kB][4]\n```\n// 图例分析说明\n两个空间：栈和堆。在代码未执行之前，JS引擎就会先加载执行一些内置的代码就。在开始之前就先执行了Object定义（function Object(value){}），栈空间会有一个Object引用变量，传的是地址值0x123，开辟出一块空间，该空间就是Object函数对象，函数对象上有一个prototype属性，该属性也是引用类型，传递地址值0x234，开辟出一块新的空间，该空间指向Object原型对象，该Object原型对象的原型上包含hasOwnProperty、toString......等一些属性，也就说在代码执行之前第一列的关系已经存在了。\n\n代码执行function Fn(){}，Fn指向的堆空间中一块区域，地址值为0x345，即Fn函数对象，Fn函数对象有一个prototype属性，该属性也是指向一块地址值0x456，指向Fn原型对象，该对象是一个空对象即{}。这个实例对象的__proto__又会指向Object的函数对象的prototype属性（实例对象的隐式原型等于函数对象的显示原型），地址值也是0x234，也会指向Object原型对象。\n代码执行Fn.prototype.test2 则在Fn原型对象上添加test2()方法\n\n代码执行var fn = new Fn()，fn的地址值为0x567，在堆内存中开辟空间指向Fn实例对象，该对象有隐式原型__proto__，其值是0x456，箭头指向Fn原型对象。Fn实例对象上有个方法test1()。\n\n\nconsole.log(Function.prototype === Function.__proto__)  // true\nconsole.log(Object.prototype.__proto__)  // null\nconsole.log(Object.prototype.toString)  // ƒ toString() { [native code] }  Object原型上有toString方法\n```\n\n* 图例三\n![原型与原型链分析图例_03.png-129.8kB][5]\n```\nfunction Foo() {\n}\nvar f1 = new Foo()\nvar f2 = new Foo()\nvar o1 = {}\nvar o2 = {}\n```\n\n* 图例四\n![函数对象的原型分析.png-60.3kB][6]\n\n\n## 实现类的继承\n### 原型链的方法\n* 套路\n    1. 定义父类型构造函数\n    2. 给父类型的原型添加方法\n    3. 定义子类型的构造函数\n    4. 创建父类型的对象赋值给子类型的原型\n    5. 将子类型原型的构造属性设置为子类型\n    6. 给子类型原型添加方法\n    7. 创建子类型的对象: 可以调用父类型的方法\n* 关键\n    1. 子类型的原型为父类型的一个实例对象\n    Child.prototype = new Parent()\n\n```\nfunction Parent() {\n    this.pProp = 'this Parent prop'\n}\nParent.prototype.showPProp = function () {\n    console.log('showPProp()', this.pProp)\n}\n\nfunction Child() {\n    this.cProp = 'this Child prop'\n}\n\n// 让子类原型指向父类型实例\nChild.prototype = new Parent()\n// 让子类原型对象构造器属性指向子类\nChild.prototype.constructor = Child\n\nChild.prototype.showCProp = function () {\n    console.log('showCProp()', this.cProp)\n}\n\nvar child = new Child()\nchild.showPProp()\nconsole.log(child.constructor) // ƒ Child() { this.cProp = 'this Child prop'}\nconsole.log(child)   // Child {cProp: \"this Child prop\"}\n```\n\n### class 类的方式\n* 通过class定义类/实现类的继承\n* 在类中通过constructor定义构造方法\n* 通过new来创建类的实例\n* 通过extends来实现类的继承\n* 通过super调用父类的构造方法\n* 重写从父类中继承的一般方法\n\n```\n// 用class定义一个Person类\nclass Person{\n    constructor (name, age){   // 类的构造方法\n        this.name = name;\n        this.age = age;\n    }\n    showName (){   // 类的一般方法\n        console.log(this.name, this.age);\n    }\n}\nlet p1 = new Person(\"TOM\", 18);\nconsole.log(p1.name);\np1.showName();\n\n\n// 定义一个Student 继承Person\nclass Student extends Person {  // 定义的Student类继承自Person类\n    constructor (name, age, salary){\n        super(name,age);  // 通过super调用父类的构造方法\n        this.salary = salary;\n    }\n    showName (name, age, salary){\n        console.log(this.name, this.age, this.salary);\n    }\n}\nlet s1 = new Student(\"MARLON\", 26, 17000);\nconsole.log(s1.name);\ns1.showName();\n```\n\n### Object.create()方法\n* `Object.create(prototype, [descriptors])`\n   * 作用: 以指定对象为原型创建新的对象\n   * 为新的对象指定新的属性, 并对属性进行描述\n     value : 指定值\n     writable : 标识当前属性值是否是可修改的, 默认为 false\n* 用法演示\n```\n//  Object.create(prototype, [descriptors])\nvar obj = {n:11};\nvar obj2 = Object.create(obj);\nconsole.log(obj2, obj2.n);   // {} 11\nvar obj3 = Object.create(obj,{\n    m: {\n        value: \"asd\",\n        writable: false\n    }\n});\nobj3.m = 456;\nconsole.log(obj3.m);  // asd\n```\n\n### 原型链 + 借用构造函数的组合继承\n* 利用原型链实现对父类型对象的方法继承\n* 利用call()借用父类型构建函数初始化相同属性\n\n```\nfunction Person(name, age) {\n    this.name = name\n    this.age = age\n}\nPerson.prototype.setName = function (name) {\n    this.name = name\n}\nfunction Student(name, age, price) { // 身价\n    Person.call(this, name, age)  // 相当于: this.Person(name, age)\n    this.price = price\n}\n\nStudent.prototype = new Person()\nStudent.prototype.constructor = Student\n\nStudent.prototype.setPrice = function (price) {\n    this.price = price\n}\n\nvar s = new Student('Jack', 21, 13000)\ns.setName('Bob')\ns.setPrice(14000)\nconsole.log(s.name, s.age, s.price)\n```\n\n-------------------------------------------------------------------\n\n\n  [1]: http://static.zybuluo.com/MarlonChiu/12qcvudloms3ft00fsxugjtt/webpack%E5%85%B6%E5%AE%83%E6%A6%82%E5%BF%B5_1.png\n  [2]: http://static.zybuluo.com/MarlonChiu/sxodezube6trrxitofbx3drp/webpack%E5%85%B6%E5%AE%83%E6%A6%82%E5%BF%B5_2.png\n  [3]: http://static.zybuluo.com/MarlonChiu/v5fxgw1c326yrmvru8gt4qxa/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90%E5%9B%BE%E4%BE%8B_01.png\n  [4]: http://static.zybuluo.com/MarlonChiu/qj4jj2hpkqymby58zjazwl7x/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90%E5%9B%BE%E4%BE%8B_02.png\n  [5]: http://static.zybuluo.com/MarlonChiu/2o4q7d8zguhokxee7b4avun1/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90%E5%9B%BE%E4%BE%8B_03.png\n  [6]: http://static.zybuluo.com/MarlonChiu/4shqfy3qe573pw8t7fi70jpz/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%88%86%E6%9E%90.png","source":"_posts/常用前端面试参考总结.md","raw":"---\ntitle: 常用前端面试参考总结\ndate: '2021-03-18'\ntype: 技术\ntags: 面试\nnote: 原型与原型链、Webpack及构建工具的理解、客户端存储、类的继承\n---\n\n# 常用前端面试参考总结\n\n标签（空格分隔）： Summarize Interview\n\n---\n## 原型与原型链\n### 原型\n* 函数的prototype属性(图)\n   * 每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)\n   * 原型对象中有一个属性constructor, 它指向函数对象\n* 给原型对象添加属性(一般都是方法)\n   * 作用: 函数的所有实例对象自动拥有原型中的属性(方法)\n   * 原型对象上的方法一般给其实例对象调用\n\n### 显式原型与隐式原型\n* 每个函数对象function都有一个prototype，即显式原型\n* 每个实例对象都有一个 `__proto__` ，可称为隐式原型\n* 对象的隐式原型的值为其对应构造函数的显式原型的值 ===> 都指向函数对象\n* 内存结构(图)\n* 总结:\n   * 函数的prototype属性： 在定义函数时自动添加的，默认值是一个空Object对象\n   * 对象的`__proto__`属性：创建对象时自动添加的，默认值为构造函数的prototype属性值\n   * 程序员能直接操作显式原型，但不能直接操作隐式原型(ES6之前)\n* 举个例子\n\n```\n// Fn()\nvar Fn = function () {}  // 执行这条函数定义语句, 函数体并没有执行\n\n// 每个函数function都有一个prototype，即显式原型(属性)\nconsole.log(Fn.prototype)\n\n// 每个实例对象都有一个__proto__，可称为隐式原型(属性)\nvar fn = new Fn()\nconsole.log(fn.__proto__)\n\n// 对象的隐式原型的值为其对应构造函数的显式原型的值\nconsole.log(fn.__proto__ === Fn.prototype)  // true\n\n/*\n 1. prototype属性: 函数对象\n    什么时候添加? 函数被定义时(创建函数对象时自动添加)\n    值是多少?  空的object实例对象: this.prototype = {}  this.prototype.constructor = this\n\n2. __proto__属性: 实例对象\n    什么时候添加? 创建实例对象时自动添加\n    值是多少?   构造函数的prototype属性值: this.__proto__ = Fn.prototype\n */\n\n/*\n    执行函数: 执行函数体中的所有语句\n    执行函数定义: 本质是创建函数对象\n*/\nconsole.log(Object.prototype.__proto__);  // null\n```\n\n### 原型链\n* 原型链(图解)\n* 访问一个对象的属性时，\n   * 先在自身属性中查找，找到返回\n   * 如果没有,再沿着`__proto__`这条链向上查找, 找到返回\n   * 如果最终没找到,返回undefined\n* 别名：隐式原型链\n* 作用：**查找对象的属性(方法)**\n* 构造函数/原型/实体对象的关系(图解)\n* 构造函数/原型/实体对象的关系2(图解)\n* 举个例子\n```\nconsole.log(Function.prototype===Function.__proto__)  // true\nconsole.log(Object.prototype.__proto__)  // null\nconsole.log(Object.prototype)\nfunction Fn() {\n    this.test1 = function () {\n        console.log('test1()')\n    }\n}\nFn.prototype.test2 = function () {\n    console.log('test2()')\n}\nvar fn = new Fn()\n\nfn.test1()\nfn.test2()\nconsole.log(fn.toString())\nconsole.log(fn.test3)  // undefined\nfn.test3()\n\n// 详情请看githubMarkdownPhotos分析图\n```\n* **原型链总结**\n   * 查找对象的属性沿着原型链查找，查找变量沿着作用域链查找\n   * 函数对象既有`prototype`属性，也有`__proto__`属性（函数的本质是被new出来的）\n   * 所有函数对象的`__proto__`属性值都相等，都等于大写的Function的 `prototype`\n   * 所有函数都是Function的实例，包括它自己。\n    `Function.prototype === Function.__proto__ // true`\n   * 非函数对象（实例对象）肯定是其对应构造函数的实例\n\n### 原型链的属性问题\n* 读取对象的属性值时: 会自动到原型链中查找\n* 设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值\n* 即：**当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作**\n* 方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上\n* 举个例子\n\n```\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\nPerson.prototype.setName = function (name) {\n    this.name = name;\n}\nPerson.prototype.sex = '男';\n\nvar p1 = new Person('Tom', 12)\np1.setName('Jack')\nconsole.log(p1.name, p1.age, p1.sex) // Jack 12 '男'\n\np1.sex = '女'  // 设置属性值时, 不会查看原型链\nconsole.log(p1.name, p1.age, p1.sex) //Jack 12 '女'\n\nvar p2 = new Person('Bob', 23)\nconsole.log(p2.name, p2.age, p2.sex) //'Bob' 23 '男'\n```\n\n### 探索instanceof\n* instanceof是如何判断的?\n   * 表达式: A instanceof B\n   * 如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false\n   * A可以寻找多步，B只能找一步到自己的显式原型上\n* Function是通过new自己产生的实例。即所有函数都是Function的实例包括它自身。\n* 几点总结\n   * `Object created by Function`\n   * `Object 是 Function 的实例`\n   * `Object 是 Object 的实例`\n* 理解实例\n\n```\nconsole.log(Object instanceof Function) // true\nconsole.log(Object instanceof Object) // true\nconsole.log(Function instanceof Object) // true\nconsole.log(Function instanceof Function) // true\nconsole.log(Object instanceof Foo); // false\n\nconsole.log(Function.prototype) // 不是Object的实例  ƒ () { [native code] }\nconsole.log(Function.prototype.__proto__===Object.prototype) // true\n```\n\n* 原型与原型链分析详图\n```\nfunction Foo () {}\nvar f1 = new Foo()\nvar f2 = new Foo()\nvar o1 = {}\nvar o2 = {}\n```\n![原型与原型链分析](https://i.imgur.com/Q3nxgq6.png)\n\n### 面试题及总结\n```\n// 测试题 1\nvar A = function() {}\nA.prototype.n = 1\nvar b = new A()\n\nA.prototype = {\n    n: 2,\n    m: 3\n}\nvar c = new A()\nconsole.log(b.n, b.m, c.n, c.m) //  1 undefined  2  3\n\n// 测试题2\nvar F = function(){};\nObject.prototype.a = function(){\n    console.log('a()')\n};\nFunction.prototype.b = function(){\n    console.log('b()')\n};\nvar f = new F();\nf.a()     // a()\nf.b()     // f.b is not a function\nF.a()     // a()\nF.b()     // b()\n\n\n<!--\n原型链（隐式原型链）：作用查找对象的属性\n    访问一个对象的属性时，先在自身属性中查找，找到返回；\n    如果没有再沿着 __proto__ 这条链向上查找，找到返回，如果最终没有找到，则返回undefined\n\nA instanceof B  的判断\n    如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false\n\nprototype 与 __proto__ 在创建的时候相关联，在执行的时候没有关联\n-->\n```\n\n\n\n## webpack及构建工具的理解\n### 构建工具的功能\n* **代码转换**：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。（开发写的代码有些浏览器无法识别，如ES6语法）\n* **文件优化**：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。（压缩代码）\n* **模块合并**：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。\n* **代码分割**：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。\n* **自动刷新**：监听本地源代码的变化，自动重新构建、刷新浏览器。 live reload 自动刷新 / hot reload 热模替换（HMR）（开发环境下修改代码后可以自动刷新浏览器看到最新的效果，可以监视源码的变化）\n* **代码校验**：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。\n\n### 模块化打包和非模块化打包思想差异\n* 非模块化打包：先对文件进行分类（如js/img/css等），然后分别打包\n* 模块化打包：将所有资源看成模块，而所有的模块之间都是有关系的，项目中的资源是相互关联的节点通过入口js形成一个网(图)的结构。\n   * 从入口开始递归的查找所有相关联的模块\n   * 找到一个模块(如css)后会找对应的loader，模块文件会进行正则匹配的\n   * 四个核心概念：entry | output | module(loader) | plugins\n   * loader模块加载器，将非js模块打包成webpack能理解的js模块\n   * 图片处理推荐使用 `url-loader`，配置选项可以对图片进行限制，小于此限制的会会通过base64处理的\n\n### webpack的核心概念\n* **Entry**：入口，Webpack进行打包的起始点(文件)\n* **Output**：出口，webpack编译打包生成的bundle(文件)\n* **Loader**：模块加载(转换)器，将非js模块包装成webpack能理解的js模块\n   * （举例：如处理css要用到style-loader/css-loader;处理img使用file-loader/url-loader）\n* **Plugin**：插件，在Webpack构建流程中的特定时机插入具有特定功能的代码\n   * （举例：CleanPlugin一开始就会清除指定的文件/夹；\n   * ExtractTextPlugin用于样式的抽取，用来从js中分离出css并单独打包；\n   * CopyPlugin复制静态资源；\n   * webpack.HashedModuleIdsPlugin根据代码内容生成hash作为模块的id(默认是下标)；\n   * webpack.optimize.CommonsChunkPlugin将第三方模块单独打包\n   * ……） \n* Module：模块，在 Webpack眼里一切皆模块，默认只识别js文件，如果是其它类型文件利用对应的loader转换为js模块\n* Chunk：代码块，一个 Chunk 由多个模块组合而成，最终浏览器执行的是webpack打包生成的chunk文件(bundle同理)\n\n### webpack的其他概念\n* ![webpack其它概念_1.png-39.4kB][1]\n* ![webpack其它概念_2.png-27.8kB][2]\n\n### webpack 和 gulp 的区别\n* webpack 是一种模块化打包工具，主要用于模块化方案，预编译模块的方案；\n* gulp 是工具链、构建工具，可以配合各种插件做 js 压缩，css压缩，less 编译替代手工实现自动化工作。\n* Grunt/Gulp 更多的是一种工作流；提供集成所有服务的一站式平台； gulp可以用来优化前端工作流程。\n\n## 客户端两种存储\n### Cookie存储\n```\nCookie是一项很老的技术的，就是因为它老，所以兼容性还是不错的。\n使用Cookie作为本地存储优点：兼容性好，缺点：操作繁琐，只能存简单的数据，还会过期，站点设置httponly的话，JS就不无法操作Cookie了。\n```\n\n### Web Storage存储\n```\nWebStorage是HTML5中为WebApplication提供一种存储的API，目前主流的新版本的浏览器都支持，当然IE789你就没有办法了。WebStorage主要分成localStorage和sessionStorage两种。\n```\n\n#### sessionStorage\n```\nsessionStorage是个全局对象，它维护着在页面会话(page session)期间有效的存储空间。只要浏览器开着，页面会话周期就会一直持续。当页面重新载入(reload)或者被恢复(restores)时，页面会话也是一直存在的。每在新标签或者新窗口中打开一个新页面，都会初始化一个新的会话。\n```\n\n#### localStorage\n```\nlocalStorage也是一个全局变量，它的生命周期比sessionStorage长。localStorage和sessionStorage都继承自Storage因此它们的用法相同。\n```\n\n#### WebStorage的优点\n```\n使用简单方便，缺点：IE有些版本不支持，不能存复杂的对象，必须先转化成JSON字符串，没有索引搜索效率不高，只能同步读写操作，当写入的数据比较大时可能造成JS引擎堵塞。\n```\n\n#### sessionStorage用法和localStorage区别\n```\n完全一致，差别只在有效期：\nsessionStorage在用户结束会话（即关闭浏览器或退出账户时失效）；\nlocalStorage无失效期，用户在清理浏览器缓存的时候会被清除。\n```\n\n### Cookie存储和Web Storage存储区别\n```\nlocalStorage与sessionStorage作为新时代的产物，相比旧时代的cookie有其巨大的优越性。优越性有三:\n    其一在能存储的数据量，cookie最大能存储4kb的数据，而localStorage与sessionStorage最大能存储5Mb，目前各大浏览器支持的标准都是如此；\n    \n    其二在功能上，cookie只能存储String类型的数据，以往要将用户数据存储在本地，需要将数据拼接成字符串，再存进cookie,取数据的时候同样麻烦，先将整个cookie对象拿到（String对象），再按拼接的规则拆分，再拿需要的数据，存取都很麻烦！\n    localStorage与sessionStorage不仅支持传统的String类型，还可以将json对象存储进去,存取数据都方便不少，json的优越性就不赘述，localStorage与sessionStorage无疑更现代化；\n    \n    其三是cookie是不可或缺的，cookie的作用是与服务器进行交互，作为http规范的一部分而存在；而web storage仅仅是为了在本地‘存储’而生；\n    其四在语义层面上，localStorage与sessionStorage语法更优雅、简便。\n```\n\n### 存储方式的操作对比演示\n```\n// cookie的操作\n设置cookie: document.cookie = 'key=value';\n获取cookie: document.cookie;\n删除cookie: document.cookie = \"key=value;max-age=0\";\n设置max-age存储期限: document.cookie = \"key=value;max-age=1000\"; // 1000秒\n\n// web storage操作\n保存数据 setItem(key,value)\n读取数据 getItem(key)\n删除单个数据 removeItem(key)\n清空全部数据 clearItem()\n获取数据索引 key(index)\n```\n\n### cookie / storage / session 关系\n* cookie\n   * 优点：可以解决http无状态问题 \n   * 缺点：\n     1) 与服务器交互的时候有数量和长度限制 每个域名最多20条，长度不能超过4KB  \n     2) 安全性问题 容易被人拦截 \n     3) 浪费宽带，每次请求新页面，cookie都会被发过去 \n     4) 不可以跨域  \n\n\n* cookie 和session区别\n   * cookie是把数据放在客户的浏览器上，只能存储sting类型\n   * session数据是放在服务器上，能存储json 类型、sting类型\n   * session会在一定的时间内保留数据存在服务器上，当访问增多，\n会比较占你服务器的性能 ，减轻服务器的性能 应当使用cookie\n   * sessionStorage是当前对话的缓存，浏览器窗口关闭即消失，会话级别的存储\n   * localStorage持久存在，除非清除浏览器缓存。\n\n## 数组的一些方法\n### 数组去重\n```javascript\n/*\n1.先将原数组进行排序\n2.检查原数组中的第i个元素 与 结果数组中的最后一个元素是否相同，因为已经排序，所以重复元素会在相邻位置\n3.如果不相同，则将该元素存入结果数组中\n*/\nArray.prototype.unique1 = function(){\n    this.sort(); //先排序\n    var res = [this[0]];\n    for(var i = 1; i < this.length; i++){\n    if(this[i] !== res[res.length - 1]){\n        res.push(this[i]);\n    }\n}\n    return res;\n}\n  \n/*\n1.创建一个新的数组存放结果\n2.创建一个空对象\n3.for循环时，每次取出一个元素与对象进行对比，如果这个元素不重复，\n  则把它存放到结果数组中，同时把这个元素的内容作为对象的一个属性，\n  并赋值为1，存入到第2步建立的对象中。\n说明：至于如何对比，就是每次从原数组中取出一个元素，然后到对象中去访问这个属性，如果能访问到值，则说明重复。\n*/\nArray.prototype.unique2 = function(){\n    var res = [];\n    var json = {};\n    for(var i = 0; i < this.length; i++){\n        if(!json[this[i]]){\n            res.push(this[i]);\n            json[this[i]] = 1;\n        }\n    }\n    return res;\n}\n\nvar arr2 = [112,112,34,'你好',112,112,34,'你好','str','str1'];\nvar arr = [1,7,3,4,11,2,3,2,0];\n// 方法零\nconsole.log(new Set(arr));  // Set(7) {1, 7, 3, 4, 11, 2, 0}\n// 方法一\nconsole.log(arr.unique1()); // (7) [0, 1, 11, 2, 3, 4, 7]  按照Unicode排列了\n// 方法二\nconsole.log(arr.unique2()); // (7) [0, 1, 11, 2, 3, 4, 7]\n```\n\n### 数组排序\n```\nfunction quickSort(arr) {\n  if(arr.length <= 1){\n    return arr;\n  }\n  // 基准索引（理论上可以任意选取）\n  var pivotIndex = parseInt(arr.length/2),\n    // 基准值\n    pivot = arr.splice(pivotIndex,1)[0],\n    leftArr = [],\n    rightArr = [],\n    length = arr.length;\n  // 遍历序列，根据基准拆分为两个子序列\n  for (var i = 0; i < length; i++) {\n    if(arr[i] < pivot){\n      leftArr.push(arr[i]);\n    }else {\n      rightArr.push(arr[i]);\n    }\n    \n  }\n  console.log(pivot); // 输出了三次 3 1 7\n  \n  // 连接左序列、基准、右序列\n  return quickSort(leftArr).concat(pivot, quickSort(rightArr))\n}\nvar demoArr = [8,4,7,2,0,3,1]\n\n// 方法一\nconsole.log(demoArr.sort()); // (7) [0, 1, 2, 3, 4, 7, 8]\n// 方法二\nconsole.log(quickSort(demoArr)) // (7) [0, 1, 2, 3, 4, 7, 8]\n```\n\n## 前端WEB/H5性能优化\n\n```\n// 参考CSDN博客\nhttp://blog.csdn.net/lpf1215/article/details/74315797?locationNum=8&fps=1\n```\n\n* 减少http请求，合理设置 HTTP缓存\n* 使用浏览器缓存\n* 启用压缩\n* CSS Sprites\n* LazyLoad Images\n* CSS放在页面最上部，javascript放在页面最下面\n* 异步请求Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容）\n* 减少cookie传输\n* Javascript代码优化\n* CSS选择符优化\n* CDN加速\n* 反向代理\n\n## px em rem 区别\n* px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的\n* em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸\n* rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素\n\n## 实现一个jsonp请求\n```\n<script type=\"text/javascript\">\nfunction jsonpCallback(result) {\n    // alert(result);  \n    for(var i in result) {\n        alert(i+\":\"+result[i]);// 循环输出a:1,b:2,etc.  \n    }\n}\n\nvar JSONP = document.createElement(\"script\");\nJSONP.type = \"text/javascript\";\nJSONP.src = \"http://crossdomain.com/services.php?callback=jsonpCallback\";\ndocument.getElementsByTagName(\"head\")[0].appendChild(JSONP);\n</script>\n```\n\n## 原型与原型链分析图例\n* 图例一\n![原型链分析图例_01.png-35.1kB][3]\n```\n// 图例分析说明\n```\n\n* 图例二\n![原型链分析图例_02.png-46.7kB][4]\n```\n// 图例分析说明\n两个空间：栈和堆。在代码未执行之前，JS引擎就会先加载执行一些内置的代码就。在开始之前就先执行了Object定义（function Object(value){}），栈空间会有一个Object引用变量，传的是地址值0x123，开辟出一块空间，该空间就是Object函数对象，函数对象上有一个prototype属性，该属性也是引用类型，传递地址值0x234，开辟出一块新的空间，该空间指向Object原型对象，该Object原型对象的原型上包含hasOwnProperty、toString......等一些属性，也就说在代码执行之前第一列的关系已经存在了。\n\n代码执行function Fn(){}，Fn指向的堆空间中一块区域，地址值为0x345，即Fn函数对象，Fn函数对象有一个prototype属性，该属性也是指向一块地址值0x456，指向Fn原型对象，该对象是一个空对象即{}。这个实例对象的__proto__又会指向Object的函数对象的prototype属性（实例对象的隐式原型等于函数对象的显示原型），地址值也是0x234，也会指向Object原型对象。\n代码执行Fn.prototype.test2 则在Fn原型对象上添加test2()方法\n\n代码执行var fn = new Fn()，fn的地址值为0x567，在堆内存中开辟空间指向Fn实例对象，该对象有隐式原型__proto__，其值是0x456，箭头指向Fn原型对象。Fn实例对象上有个方法test1()。\n\n\nconsole.log(Function.prototype === Function.__proto__)  // true\nconsole.log(Object.prototype.__proto__)  // null\nconsole.log(Object.prototype.toString)  // ƒ toString() { [native code] }  Object原型上有toString方法\n```\n\n* 图例三\n![原型与原型链分析图例_03.png-129.8kB][5]\n```\nfunction Foo() {\n}\nvar f1 = new Foo()\nvar f2 = new Foo()\nvar o1 = {}\nvar o2 = {}\n```\n\n* 图例四\n![函数对象的原型分析.png-60.3kB][6]\n\n\n## 实现类的继承\n### 原型链的方法\n* 套路\n    1. 定义父类型构造函数\n    2. 给父类型的原型添加方法\n    3. 定义子类型的构造函数\n    4. 创建父类型的对象赋值给子类型的原型\n    5. 将子类型原型的构造属性设置为子类型\n    6. 给子类型原型添加方法\n    7. 创建子类型的对象: 可以调用父类型的方法\n* 关键\n    1. 子类型的原型为父类型的一个实例对象\n    Child.prototype = new Parent()\n\n```\nfunction Parent() {\n    this.pProp = 'this Parent prop'\n}\nParent.prototype.showPProp = function () {\n    console.log('showPProp()', this.pProp)\n}\n\nfunction Child() {\n    this.cProp = 'this Child prop'\n}\n\n// 让子类原型指向父类型实例\nChild.prototype = new Parent()\n// 让子类原型对象构造器属性指向子类\nChild.prototype.constructor = Child\n\nChild.prototype.showCProp = function () {\n    console.log('showCProp()', this.cProp)\n}\n\nvar child = new Child()\nchild.showPProp()\nconsole.log(child.constructor) // ƒ Child() { this.cProp = 'this Child prop'}\nconsole.log(child)   // Child {cProp: \"this Child prop\"}\n```\n\n### class 类的方式\n* 通过class定义类/实现类的继承\n* 在类中通过constructor定义构造方法\n* 通过new来创建类的实例\n* 通过extends来实现类的继承\n* 通过super调用父类的构造方法\n* 重写从父类中继承的一般方法\n\n```\n// 用class定义一个Person类\nclass Person{\n    constructor (name, age){   // 类的构造方法\n        this.name = name;\n        this.age = age;\n    }\n    showName (){   // 类的一般方法\n        console.log(this.name, this.age);\n    }\n}\nlet p1 = new Person(\"TOM\", 18);\nconsole.log(p1.name);\np1.showName();\n\n\n// 定义一个Student 继承Person\nclass Student extends Person {  // 定义的Student类继承自Person类\n    constructor (name, age, salary){\n        super(name,age);  // 通过super调用父类的构造方法\n        this.salary = salary;\n    }\n    showName (name, age, salary){\n        console.log(this.name, this.age, this.salary);\n    }\n}\nlet s1 = new Student(\"MARLON\", 26, 17000);\nconsole.log(s1.name);\ns1.showName();\n```\n\n### Object.create()方法\n* `Object.create(prototype, [descriptors])`\n   * 作用: 以指定对象为原型创建新的对象\n   * 为新的对象指定新的属性, 并对属性进行描述\n     value : 指定值\n     writable : 标识当前属性值是否是可修改的, 默认为 false\n* 用法演示\n```\n//  Object.create(prototype, [descriptors])\nvar obj = {n:11};\nvar obj2 = Object.create(obj);\nconsole.log(obj2, obj2.n);   // {} 11\nvar obj3 = Object.create(obj,{\n    m: {\n        value: \"asd\",\n        writable: false\n    }\n});\nobj3.m = 456;\nconsole.log(obj3.m);  // asd\n```\n\n### 原型链 + 借用构造函数的组合继承\n* 利用原型链实现对父类型对象的方法继承\n* 利用call()借用父类型构建函数初始化相同属性\n\n```\nfunction Person(name, age) {\n    this.name = name\n    this.age = age\n}\nPerson.prototype.setName = function (name) {\n    this.name = name\n}\nfunction Student(name, age, price) { // 身价\n    Person.call(this, name, age)  // 相当于: this.Person(name, age)\n    this.price = price\n}\n\nStudent.prototype = new Person()\nStudent.prototype.constructor = Student\n\nStudent.prototype.setPrice = function (price) {\n    this.price = price\n}\n\nvar s = new Student('Jack', 21, 13000)\ns.setName('Bob')\ns.setPrice(14000)\nconsole.log(s.name, s.age, s.price)\n```\n\n-------------------------------------------------------------------\n\n\n  [1]: http://static.zybuluo.com/MarlonChiu/12qcvudloms3ft00fsxugjtt/webpack%E5%85%B6%E5%AE%83%E6%A6%82%E5%BF%B5_1.png\n  [2]: http://static.zybuluo.com/MarlonChiu/sxodezube6trrxitofbx3drp/webpack%E5%85%B6%E5%AE%83%E6%A6%82%E5%BF%B5_2.png\n  [3]: http://static.zybuluo.com/MarlonChiu/v5fxgw1c326yrmvru8gt4qxa/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90%E5%9B%BE%E4%BE%8B_01.png\n  [4]: http://static.zybuluo.com/MarlonChiu/qj4jj2hpkqymby58zjazwl7x/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90%E5%9B%BE%E4%BE%8B_02.png\n  [5]: http://static.zybuluo.com/MarlonChiu/2o4q7d8zguhokxee7b4avun1/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90%E5%9B%BE%E4%BE%8B_03.png\n  [6]: http://static.zybuluo.com/MarlonChiu/4shqfy3qe573pw8t7fi70jpz/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%88%86%E6%9E%90.png","slug":"常用前端面试参考总结","published":1,"updated":"2021-07-19T05:52:56.184Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrd8jv1c000bkwzt7sog16bg","content":"<h1 id=\"常用前端面试参考总结\"><a href=\"#常用前端面试参考总结\" class=\"headerlink\" title=\"常用前端面试参考总结\"></a>常用前端面试参考总结</h1><p>标签（空格分隔）： Summarize Interview</p>\n<hr>\n<h2 id=\"原型与原型链\"><a href=\"#原型与原型链\" class=\"headerlink\" title=\"原型与原型链\"></a>原型与原型链</h2><h3 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h3><ul>\n<li>函数的prototype属性(图)<ul>\n<li>每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)</li>\n<li>原型对象中有一个属性constructor, 它指向函数对象</li>\n</ul>\n</li>\n<li>给原型对象添加属性(一般都是方法)<ul>\n<li>作用: 函数的所有实例对象自动拥有原型中的属性(方法)</li>\n<li>原型对象上的方法一般给其实例对象调用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"显式原型与隐式原型\"><a href=\"#显式原型与隐式原型\" class=\"headerlink\" title=\"显式原型与隐式原型\"></a>显式原型与隐式原型</h3><ul>\n<li>每个函数对象function都有一个prototype，即显式原型</li>\n<li>每个实例对象都有一个 <code>__proto__</code> ，可称为隐式原型</li>\n<li>对象的隐式原型的值为其对应构造函数的显式原型的值 ===&gt; 都指向函数对象</li>\n<li>内存结构(图)</li>\n<li>总结:<ul>\n<li>函数的prototype属性： 在定义函数时自动添加的，默认值是一个空Object对象</li>\n<li>对象的<code>__proto__</code>属性：创建对象时自动添加的，默认值为构造函数的prototype属性值</li>\n<li>程序员能直接操作显式原型，但不能直接操作隐式原型(ES6之前)</li>\n</ul>\n</li>\n<li>举个例子</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Fn()</span><br><span class=\"line\">var Fn = function () &#123;&#125;  // 执行这条函数定义语句, 函数体并没有执行</span><br><span class=\"line\"></span><br><span class=\"line\">// 每个函数function都有一个prototype，即显式原型(属性)</span><br><span class=\"line\">console.log(Fn.prototype)</span><br><span class=\"line\"></span><br><span class=\"line\">// 每个实例对象都有一个__proto__，可称为隐式原型(属性)</span><br><span class=\"line\">var fn = new Fn()</span><br><span class=\"line\">console.log(fn.__proto__)</span><br><span class=\"line\"></span><br><span class=\"line\">// 对象的隐式原型的值为其对应构造函数的显式原型的值</span><br><span class=\"line\">console.log(fn.__proto__ === Fn.prototype)  // true</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\"> 1. prototype属性: 函数对象</span><br><span class=\"line\">    什么时候添加? 函数被定义时(创建函数对象时自动添加)</span><br><span class=\"line\">    值是多少?  空的object实例对象: this.prototype = &#123;&#125;  this.prototype.constructor = this</span><br><span class=\"line\"></span><br><span class=\"line\">2. __proto__属性: 实例对象</span><br><span class=\"line\">    什么时候添加? 创建实例对象时自动添加</span><br><span class=\"line\">    值是多少?   构造函数的prototype属性值: this.__proto__ = Fn.prototype</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">    执行函数: 执行函数体中的所有语句</span><br><span class=\"line\">    执行函数定义: 本质是创建函数对象</span><br><span class=\"line\">*/</span><br><span class=\"line\">console.log(Object.prototype.__proto__);  // null</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h3><ul>\n<li>原型链(图解)</li>\n<li>访问一个对象的属性时，<ul>\n<li>先在自身属性中查找，找到返回</li>\n<li>如果没有,再沿着<code>__proto__</code>这条链向上查找, 找到返回</li>\n<li>如果最终没找到,返回undefined</li>\n</ul>\n</li>\n<li>别名：隐式原型链</li>\n<li>作用：<strong>查找对象的属性(方法)</strong></li>\n<li>构造函数/原型/实体对象的关系(图解)</li>\n<li>构造函数/原型/实体对象的关系2(图解)</li>\n<li>举个例子<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(Function.prototype===Function.__proto__)  // true</span><br><span class=\"line\">console.log(Object.prototype.__proto__)  // null</span><br><span class=\"line\">console.log(Object.prototype)</span><br><span class=\"line\">function Fn() &#123;</span><br><span class=\"line\">    this.test1 = function () &#123;</span><br><span class=\"line\">        console.log(&#x27;test1()&#x27;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fn.prototype.test2 = function () &#123;</span><br><span class=\"line\">    console.log(&#x27;test2()&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var fn = new Fn()</span><br><span class=\"line\"></span><br><span class=\"line\">fn.test1()</span><br><span class=\"line\">fn.test2()</span><br><span class=\"line\">console.log(fn.toString())</span><br><span class=\"line\">console.log(fn.test3)  // undefined</span><br><span class=\"line\">fn.test3()</span><br><span class=\"line\"></span><br><span class=\"line\">// 详情请看githubMarkdownPhotos分析图</span><br></pre></td></tr></table></figure></li>\n<li><strong>原型链总结</strong><ul>\n<li>查找对象的属性沿着原型链查找，查找变量沿着作用域链查找</li>\n<li>函数对象既有<code>prototype</code>属性，也有<code>__proto__</code>属性（函数的本质是被new出来的）</li>\n<li>所有函数对象的<code>__proto__</code>属性值都相等，都等于大写的Function的 <code>prototype</code></li>\n<li>所有函数都是Function的实例，包括它自己。<br><code>Function.prototype === Function.__proto__ // true</code></li>\n<li>非函数对象（实例对象）肯定是其对应构造函数的实例</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"原型链的属性问题\"><a href=\"#原型链的属性问题\" class=\"headerlink\" title=\"原型链的属性问题\"></a>原型链的属性问题</h3><ul>\n<li>读取对象的属性值时: 会自动到原型链中查找</li>\n<li>设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值</li>\n<li>即：<strong>当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作</strong></li>\n<li>方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上</li>\n<li>举个例子</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(name, age) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.setName = function (name) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.sex = &#x27;男&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">var p1 = new Person(&#x27;Tom&#x27;, 12)</span><br><span class=\"line\">p1.setName(&#x27;Jack&#x27;)</span><br><span class=\"line\">console.log(p1.name, p1.age, p1.sex) // Jack 12 &#x27;男&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">p1.sex = &#x27;女&#x27;  // 设置属性值时, 不会查看原型链</span><br><span class=\"line\">console.log(p1.name, p1.age, p1.sex) //Jack 12 &#x27;女&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">var p2 = new Person(&#x27;Bob&#x27;, 23)</span><br><span class=\"line\">console.log(p2.name, p2.age, p2.sex) //&#x27;Bob&#x27; 23 &#x27;男&#x27;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"探索instanceof\"><a href=\"#探索instanceof\" class=\"headerlink\" title=\"探索instanceof\"></a>探索instanceof</h3><ul>\n<li>instanceof是如何判断的?<ul>\n<li>表达式: A instanceof B</li>\n<li>如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false</li>\n<li>A可以寻找多步，B只能找一步到自己的显式原型上</li>\n</ul>\n</li>\n<li>Function是通过new自己产生的实例。即所有函数都是Function的实例包括它自身。</li>\n<li>几点总结<ul>\n<li><code>Object created by Function</code></li>\n<li><code>Object 是 Function 的实例</code></li>\n<li><code>Object 是 Object 的实例</code></li>\n</ul>\n</li>\n<li>理解实例</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(Object instanceof Function) // true</span><br><span class=\"line\">console.log(Object instanceof Object) // true</span><br><span class=\"line\">console.log(Function instanceof Object) // true</span><br><span class=\"line\">console.log(Function instanceof Function) // true</span><br><span class=\"line\">console.log(Object instanceof Foo); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Function.prototype) // 不是Object的实例  ƒ () &#123; [native code] &#125;</span><br><span class=\"line\">console.log(Function.prototype.__proto__===Object.prototype) // true</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>原型与原型链分析详图<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Foo () &#123;&#125;</span><br><span class=\"line\">var f1 = new Foo()</span><br><span class=\"line\">var f2 = new Foo()</span><br><span class=\"line\">var o1 = &#123;&#125;</span><br><span class=\"line\">var o2 = &#123;&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"https://i.imgur.com/Q3nxgq6.png\" alt=\"原型与原型链分析\"></li>\n</ul>\n<h3 id=\"面试题及总结\"><a href=\"#面试题及总结\" class=\"headerlink\" title=\"面试题及总结\"></a>面试题及总结</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 测试题 1</span><br><span class=\"line\">var A = function() &#123;&#125;</span><br><span class=\"line\">A.prototype.n = 1</span><br><span class=\"line\">var b = new A()</span><br><span class=\"line\"></span><br><span class=\"line\">A.prototype = &#123;</span><br><span class=\"line\">    n: 2,</span><br><span class=\"line\">    m: 3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var c = new A()</span><br><span class=\"line\">console.log(b.n, b.m, c.n, c.m) //  1 undefined  2  3</span><br><span class=\"line\"></span><br><span class=\"line\">// 测试题2</span><br><span class=\"line\">var F = function()&#123;&#125;;</span><br><span class=\"line\">Object.prototype.a = function()&#123;</span><br><span class=\"line\">    console.log(&#x27;a()&#x27;)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Function.prototype.b = function()&#123;</span><br><span class=\"line\">    console.log(&#x27;b()&#x27;)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var f = new F();</span><br><span class=\"line\">f.a()     // a()</span><br><span class=\"line\">f.b()     // f.b is not a function</span><br><span class=\"line\">F.a()     // a()</span><br><span class=\"line\">F.b()     // b()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--</span><br><span class=\"line\">原型链（隐式原型链）：作用查找对象的属性</span><br><span class=\"line\">    访问一个对象的属性时，先在自身属性中查找，找到返回；</span><br><span class=\"line\">    如果没有再沿着 __proto__ 这条链向上查找，找到返回，如果最终没有找到，则返回undefined</span><br><span class=\"line\"></span><br><span class=\"line\">A instanceof B  的判断</span><br><span class=\"line\">    如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false</span><br><span class=\"line\"></span><br><span class=\"line\">prototype 与 __proto__ 在创建的时候相关联，在执行的时候没有关联</span><br><span class=\"line\">--&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"webpack及构建工具的理解\"><a href=\"#webpack及构建工具的理解\" class=\"headerlink\" title=\"webpack及构建工具的理解\"></a>webpack及构建工具的理解</h2><h3 id=\"构建工具的功能\"><a href=\"#构建工具的功能\" class=\"headerlink\" title=\"构建工具的功能\"></a>构建工具的功能</h3><ul>\n<li><strong>代码转换</strong>：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。（开发写的代码有些浏览器无法识别，如ES6语法）</li>\n<li><strong>文件优化</strong>：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。（压缩代码）</li>\n<li><strong>模块合并</strong>：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。</li>\n<li><strong>代码分割</strong>：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li>\n<li><strong>自动刷新</strong>：监听本地源代码的变化，自动重新构建、刷新浏览器。 live reload 自动刷新 / hot reload 热模替换（HMR）（开发环境下修改代码后可以自动刷新浏览器看到最新的效果，可以监视源码的变化）</li>\n<li><strong>代码校验</strong>：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</li>\n</ul>\n<h3 id=\"模块化打包和非模块化打包思想差异\"><a href=\"#模块化打包和非模块化打包思想差异\" class=\"headerlink\" title=\"模块化打包和非模块化打包思想差异\"></a>模块化打包和非模块化打包思想差异</h3><ul>\n<li>非模块化打包：先对文件进行分类（如js/img/css等），然后分别打包</li>\n<li>模块化打包：将所有资源看成模块，而所有的模块之间都是有关系的，项目中的资源是相互关联的节点通过入口js形成一个网(图)的结构。<ul>\n<li>从入口开始递归的查找所有相关联的模块</li>\n<li>找到一个模块(如css)后会找对应的loader，模块文件会进行正则匹配的</li>\n<li>四个核心概念：entry | output | module(loader) | plugins</li>\n<li>loader模块加载器，将非js模块打包成webpack能理解的js模块</li>\n<li>图片处理推荐使用 <code>url-loader</code>，配置选项可以对图片进行限制，小于此限制的会会通过base64处理的</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"webpack的核心概念\"><a href=\"#webpack的核心概念\" class=\"headerlink\" title=\"webpack的核心概念\"></a>webpack的核心概念</h3><ul>\n<li><strong>Entry</strong>：入口，Webpack进行打包的起始点(文件)</li>\n<li><strong>Output</strong>：出口，webpack编译打包生成的bundle(文件)</li>\n<li><strong>Loader</strong>：模块加载(转换)器，将非js模块包装成webpack能理解的js模块<ul>\n<li>（举例：如处理css要用到style-loader/css-loader;处理img使用file-loader/url-loader）</li>\n</ul>\n</li>\n<li><strong>Plugin</strong>：插件，在Webpack构建流程中的特定时机插入具有特定功能的代码<ul>\n<li>（举例：CleanPlugin一开始就会清除指定的文件/夹；</li>\n<li>ExtractTextPlugin用于样式的抽取，用来从js中分离出css并单独打包；</li>\n<li>CopyPlugin复制静态资源；</li>\n<li>webpack.HashedModuleIdsPlugin根据代码内容生成hash作为模块的id(默认是下标)；</li>\n<li>webpack.optimize.CommonsChunkPlugin将第三方模块单独打包</li>\n<li>……） </li>\n</ul>\n</li>\n<li>Module：模块，在 Webpack眼里一切皆模块，默认只识别js文件，如果是其它类型文件利用对应的loader转换为js模块</li>\n<li>Chunk：代码块，一个 Chunk 由多个模块组合而成，最终浏览器执行的是webpack打包生成的chunk文件(bundle同理)</li>\n</ul>\n<h3 id=\"webpack的其他概念\"><a href=\"#webpack的其他概念\" class=\"headerlink\" title=\"webpack的其他概念\"></a>webpack的其他概念</h3><ul>\n<li><img src=\"http://static.zybuluo.com/MarlonChiu/12qcvudloms3ft00fsxugjtt/webpack%E5%85%B6%E5%AE%83%E6%A6%82%E5%BF%B5_1.png\" alt=\"webpack其它概念_1.png-39.4kB\"></li>\n<li><img src=\"http://static.zybuluo.com/MarlonChiu/sxodezube6trrxitofbx3drp/webpack%E5%85%B6%E5%AE%83%E6%A6%82%E5%BF%B5_2.png\" alt=\"webpack其它概念_2.png-27.8kB\"></li>\n</ul>\n<h3 id=\"webpack-和-gulp-的区别\"><a href=\"#webpack-和-gulp-的区别\" class=\"headerlink\" title=\"webpack 和 gulp 的区别\"></a>webpack 和 gulp 的区别</h3><ul>\n<li>webpack 是一种模块化打包工具，主要用于模块化方案，预编译模块的方案；</li>\n<li>gulp 是工具链、构建工具，可以配合各种插件做 js 压缩，css压缩，less 编译替代手工实现自动化工作。</li>\n<li>Grunt/Gulp 更多的是一种工作流；提供集成所有服务的一站式平台； gulp可以用来优化前端工作流程。</li>\n</ul>\n<h2 id=\"客户端两种存储\"><a href=\"#客户端两种存储\" class=\"headerlink\" title=\"客户端两种存储\"></a>客户端两种存储</h2><h3 id=\"Cookie存储\"><a href=\"#Cookie存储\" class=\"headerlink\" title=\"Cookie存储\"></a>Cookie存储</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cookie是一项很老的技术的，就是因为它老，所以兼容性还是不错的。</span><br><span class=\"line\">使用Cookie作为本地存储优点：兼容性好，缺点：操作繁琐，只能存简单的数据，还会过期，站点设置httponly的话，JS就不无法操作Cookie了。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Web-Storage存储\"><a href=\"#Web-Storage存储\" class=\"headerlink\" title=\"Web Storage存储\"></a>Web Storage存储</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebStorage是HTML5中为WebApplication提供一种存储的API，目前主流的新版本的浏览器都支持，当然IE789你就没有办法了。WebStorage主要分成localStorage和sessionStorage两种。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"sessionStorage\"><a href=\"#sessionStorage\" class=\"headerlink\" title=\"sessionStorage\"></a>sessionStorage</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sessionStorage是个全局对象，它维护着在页面会话(page session)期间有效的存储空间。只要浏览器开着，页面会话周期就会一直持续。当页面重新载入(reload)或者被恢复(restores)时，页面会话也是一直存在的。每在新标签或者新窗口中打开一个新页面，都会初始化一个新的会话。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"localStorage\"><a href=\"#localStorage\" class=\"headerlink\" title=\"localStorage\"></a>localStorage</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localStorage也是一个全局变量，它的生命周期比sessionStorage长。localStorage和sessionStorage都继承自Storage因此它们的用法相同。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"WebStorage的优点\"><a href=\"#WebStorage的优点\" class=\"headerlink\" title=\"WebStorage的优点\"></a>WebStorage的优点</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用简单方便，缺点：IE有些版本不支持，不能存复杂的对象，必须先转化成JSON字符串，没有索引搜索效率不高，只能同步读写操作，当写入的数据比较大时可能造成JS引擎堵塞。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"sessionStorage用法和localStorage区别\"><a href=\"#sessionStorage用法和localStorage区别\" class=\"headerlink\" title=\"sessionStorage用法和localStorage区别\"></a>sessionStorage用法和localStorage区别</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">完全一致，差别只在有效期：</span><br><span class=\"line\">sessionStorage在用户结束会话（即关闭浏览器或退出账户时失效）；</span><br><span class=\"line\">localStorage无失效期，用户在清理浏览器缓存的时候会被清除。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Cookie存储和Web-Storage存储区别\"><a href=\"#Cookie存储和Web-Storage存储区别\" class=\"headerlink\" title=\"Cookie存储和Web Storage存储区别\"></a>Cookie存储和Web Storage存储区别</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localStorage与sessionStorage作为新时代的产物，相比旧时代的cookie有其巨大的优越性。优越性有三:</span><br><span class=\"line\">    其一在能存储的数据量，cookie最大能存储4kb的数据，而localStorage与sessionStorage最大能存储5Mb，目前各大浏览器支持的标准都是如此；</span><br><span class=\"line\">    </span><br><span class=\"line\">    其二在功能上，cookie只能存储String类型的数据，以往要将用户数据存储在本地，需要将数据拼接成字符串，再存进cookie,取数据的时候同样麻烦，先将整个cookie对象拿到（String对象），再按拼接的规则拆分，再拿需要的数据，存取都很麻烦！</span><br><span class=\"line\">    localStorage与sessionStorage不仅支持传统的String类型，还可以将json对象存储进去,存取数据都方便不少，json的优越性就不赘述，localStorage与sessionStorage无疑更现代化；</span><br><span class=\"line\">    </span><br><span class=\"line\">    其三是cookie是不可或缺的，cookie的作用是与服务器进行交互，作为http规范的一部分而存在；而web storage仅仅是为了在本地‘存储’而生；</span><br><span class=\"line\">    其四在语义层面上，localStorage与sessionStorage语法更优雅、简便。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"存储方式的操作对比演示\"><a href=\"#存储方式的操作对比演示\" class=\"headerlink\" title=\"存储方式的操作对比演示\"></a>存储方式的操作对比演示</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// cookie的操作</span><br><span class=\"line\">设置cookie: document.cookie = &#x27;key=value&#x27;;</span><br><span class=\"line\">获取cookie: document.cookie;</span><br><span class=\"line\">删除cookie: document.cookie = &quot;key=value;max-age=0&quot;;</span><br><span class=\"line\">设置max-age存储期限: document.cookie = &quot;key=value;max-age=1000&quot;; // 1000秒</span><br><span class=\"line\"></span><br><span class=\"line\">// web storage操作</span><br><span class=\"line\">保存数据 setItem(key,value)</span><br><span class=\"line\">读取数据 getItem(key)</span><br><span class=\"line\">删除单个数据 removeItem(key)</span><br><span class=\"line\">清空全部数据 clearItem()</span><br><span class=\"line\">获取数据索引 key(index)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"cookie-storage-session-关系\"><a href=\"#cookie-storage-session-关系\" class=\"headerlink\" title=\"cookie / storage / session 关系\"></a>cookie / storage / session 关系</h3><ul>\n<li>cookie<ul>\n<li>优点：可以解决http无状态问题 </li>\n<li>缺点：<ol>\n<li>与服务器交互的时候有数量和长度限制 每个域名最多20条，长度不能超过4KB  </li>\n<li>安全性问题 容易被人拦截 </li>\n<li>浪费宽带，每次请求新页面，cookie都会被发过去 </li>\n<li>不可以跨域  </li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>cookie 和session区别<ul>\n<li>cookie是把数据放在客户的浏览器上，只能存储sting类型</li>\n<li>session数据是放在服务器上，能存储json 类型、sting类型</li>\n<li>session会在一定的时间内保留数据存在服务器上，当访问增多，<br>会比较占你服务器的性能 ，减轻服务器的性能 应当使用cookie</li>\n<li>sessionStorage是当前对话的缓存，浏览器窗口关闭即消失，会话级别的存储</li>\n<li>localStorage持久存在，除非清除浏览器缓存。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数组的一些方法\"><a href=\"#数组的一些方法\" class=\"headerlink\" title=\"数组的一些方法\"></a>数组的一些方法</h2><h3 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">1.先将原数组进行排序</span></span><br><span class=\"line\"><span class=\"comment\">2.检查原数组中的第i个元素 与 结果数组中的最后一个元素是否相同，因为已经排序，所以重复元素会在相邻位置</span></span><br><span class=\"line\"><span class=\"comment\">3.如果不相同，则将该元素存入结果数组中</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.unique1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.sort(); <span class=\"comment\">//先排序</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = [<span class=\"built_in\">this</span>[<span class=\"number\">0</span>]];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">this</span>.length; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">this</span>[i] !== res[res.length - <span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">        res.push(<span class=\"built_in\">this</span>[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">1.创建一个新的数组存放结果</span></span><br><span class=\"line\"><span class=\"comment\">2.创建一个空对象</span></span><br><span class=\"line\"><span class=\"comment\">3.for循环时，每次取出一个元素与对象进行对比，如果这个元素不重复，</span></span><br><span class=\"line\"><span class=\"comment\">  则把它存放到结果数组中，同时把这个元素的内容作为对象的一个属性，</span></span><br><span class=\"line\"><span class=\"comment\">  并赋值为1，存入到第2步建立的对象中。</span></span><br><span class=\"line\"><span class=\"comment\">说明：至于如何对比，就是每次从原数组中取出一个元素，然后到对象中去访问这个属性，如果能访问到值，则说明重复。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.unique2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> json = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">this</span>.length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!json[<span class=\"built_in\">this</span>[i]])&#123;</span><br><span class=\"line\">            res.push(<span class=\"built_in\">this</span>[i]);</span><br><span class=\"line\">            json[<span class=\"built_in\">this</span>[i]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">112</span>,<span class=\"number\">112</span>,<span class=\"number\">34</span>,<span class=\"string\">&#x27;你好&#x27;</span>,<span class=\"number\">112</span>,<span class=\"number\">112</span>,<span class=\"number\">34</span>,<span class=\"string\">&#x27;你好&#x27;</span>,<span class=\"string\">&#x27;str&#x27;</span>,<span class=\"string\">&#x27;str1&#x27;</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">7</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">11</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"comment\">// 方法零</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr));  <span class=\"comment\">// Set(7) &#123;1, 7, 3, 4, 11, 2, 0&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 方法一</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.unique1()); <span class=\"comment\">// (7) [0, 1, 11, 2, 3, 4, 7]  按照Unicode排列了</span></span><br><span class=\"line\"><span class=\"comment\">// 方法二</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.unique2()); <span class=\"comment\">// (7) [0, 1, 11, 2, 3, 4, 7]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组排序\"><a href=\"#数组排序\" class=\"headerlink\" title=\"数组排序\"></a>数组排序</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function quickSort(arr) &#123;</span><br><span class=\"line\">  if(arr.length &lt;= 1)&#123;</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 基准索引（理论上可以任意选取）</span><br><span class=\"line\">  var pivotIndex = parseInt(arr.length/2),</span><br><span class=\"line\">    // 基准值</span><br><span class=\"line\">    pivot = arr.splice(pivotIndex,1)[0],</span><br><span class=\"line\">    leftArr = [],</span><br><span class=\"line\">    rightArr = [],</span><br><span class=\"line\">    length = arr.length;</span><br><span class=\"line\">  // 遍历序列，根据基准拆分为两个子序列</span><br><span class=\"line\">  for (var i = 0; i &lt; length; i++) &#123;</span><br><span class=\"line\">    if(arr[i] &lt; pivot)&#123;</span><br><span class=\"line\">      leftArr.push(arr[i]);</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">      rightArr.push(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(pivot); // 输出了三次 3 1 7</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 连接左序列、基准、右序列</span><br><span class=\"line\">  return quickSort(leftArr).concat(pivot, quickSort(rightArr))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var demoArr = [8,4,7,2,0,3,1]</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法一</span><br><span class=\"line\">console.log(demoArr.sort()); // (7) [0, 1, 2, 3, 4, 7, 8]</span><br><span class=\"line\">// 方法二</span><br><span class=\"line\">console.log(quickSort(demoArr)) // (7) [0, 1, 2, 3, 4, 7, 8]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"前端WEB-H5性能优化\"><a href=\"#前端WEB-H5性能优化\" class=\"headerlink\" title=\"前端WEB/H5性能优化\"></a>前端WEB/H5性能优化</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 参考CSDN博客</span><br><span class=\"line\">http://blog.csdn.net/lpf1215/article/details/74315797?locationNum=8&amp;fps=1</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>减少http请求，合理设置 HTTP缓存</li>\n<li>使用浏览器缓存</li>\n<li>启用压缩</li>\n<li>CSS Sprites</li>\n<li>LazyLoad Images</li>\n<li>CSS放在页面最上部，javascript放在页面最下面</li>\n<li>异步请求Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容）</li>\n<li>减少cookie传输</li>\n<li>Javascript代码优化</li>\n<li>CSS选择符优化</li>\n<li>CDN加速</li>\n<li>反向代理</li>\n</ul>\n<h2 id=\"px-em-rem-区别\"><a href=\"#px-em-rem-区别\" class=\"headerlink\" title=\"px em rem 区别\"></a>px em rem 区别</h2><ul>\n<li>px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的</li>\n<li>em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸</li>\n<li>rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素</li>\n</ul>\n<h2 id=\"实现一个jsonp请求\"><a href=\"#实现一个jsonp请求\" class=\"headerlink\" title=\"实现一个jsonp请求\"></a>实现一个jsonp请求</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">function jsonpCallback(result) &#123;</span><br><span class=\"line\">    // alert(result);  </span><br><span class=\"line\">    for(var i in result) &#123;</span><br><span class=\"line\">        alert(i+&quot;:&quot;+result[i]);// 循环输出a:1,b:2,etc.  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var JSONP = document.createElement(&quot;script&quot;);</span><br><span class=\"line\">JSONP.type = &quot;text/javascript&quot;;</span><br><span class=\"line\">JSONP.src = &quot;http://crossdomain.com/services.php?callback=jsonpCallback&quot;;</span><br><span class=\"line\">document.getElementsByTagName(&quot;head&quot;)[0].appendChild(JSONP);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"原型与原型链分析图例\"><a href=\"#原型与原型链分析图例\" class=\"headerlink\" title=\"原型与原型链分析图例\"></a>原型与原型链分析图例</h2><ul>\n<li><p>图例一<br><img src=\"http://static.zybuluo.com/MarlonChiu/v5fxgw1c326yrmvru8gt4qxa/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90%E5%9B%BE%E4%BE%8B_01.png\" alt=\"原型链分析图例_01.png-35.1kB\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 图例分析说明</span><br></pre></td></tr></table></figure></li>\n<li><p>图例二<br><img src=\"http://static.zybuluo.com/MarlonChiu/qj4jj2hpkqymby58zjazwl7x/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90%E5%9B%BE%E4%BE%8B_02.png\" alt=\"原型链分析图例_02.png-46.7kB\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 图例分析说明</span><br><span class=\"line\">两个空间：栈和堆。在代码未执行之前，JS引擎就会先加载执行一些内置的代码就。在开始之前就先执行了Object定义（function Object(value)&#123;&#125;），栈空间会有一个Object引用变量，传的是地址值0x123，开辟出一块空间，该空间就是Object函数对象，函数对象上有一个prototype属性，该属性也是引用类型，传递地址值0x234，开辟出一块新的空间，该空间指向Object原型对象，该Object原型对象的原型上包含hasOwnProperty、toString......等一些属性，也就说在代码执行之前第一列的关系已经存在了。</span><br><span class=\"line\"></span><br><span class=\"line\">代码执行function Fn()&#123;&#125;，Fn指向的堆空间中一块区域，地址值为0x345，即Fn函数对象，Fn函数对象有一个prototype属性，该属性也是指向一块地址值0x456，指向Fn原型对象，该对象是一个空对象即&#123;&#125;。这个实例对象的__proto__又会指向Object的函数对象的prototype属性（实例对象的隐式原型等于函数对象的显示原型），地址值也是0x234，也会指向Object原型对象。</span><br><span class=\"line\">代码执行Fn.prototype.test2 则在Fn原型对象上添加test2()方法</span><br><span class=\"line\"></span><br><span class=\"line\">代码执行var fn = new Fn()，fn的地址值为0x567，在堆内存中开辟空间指向Fn实例对象，该对象有隐式原型__proto__，其值是0x456，箭头指向Fn原型对象。Fn实例对象上有个方法test1()。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Function.prototype === Function.__proto__)  // true</span><br><span class=\"line\">console.log(Object.prototype.__proto__)  // null</span><br><span class=\"line\">console.log(Object.prototype.toString)  // ƒ toString() &#123; [native code] &#125;  Object原型上有toString方法</span><br></pre></td></tr></table></figure></li>\n<li><p>图例三<br><img src=\"http://static.zybuluo.com/MarlonChiu/2o4q7d8zguhokxee7b4avun1/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90%E5%9B%BE%E4%BE%8B_03.png\" alt=\"原型与原型链分析图例_03.png-129.8kB\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Foo() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var f1 = new Foo()</span><br><span class=\"line\">var f2 = new Foo()</span><br><span class=\"line\">var o1 = &#123;&#125;</span><br><span class=\"line\">var o2 = &#123;&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>图例四<br><img src=\"http://static.zybuluo.com/MarlonChiu/4shqfy3qe573pw8t7fi70jpz/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%88%86%E6%9E%90.png\" alt=\"函数对象的原型分析.png-60.3kB\"></p>\n</li>\n</ul>\n<h2 id=\"实现类的继承\"><a href=\"#实现类的继承\" class=\"headerlink\" title=\"实现类的继承\"></a>实现类的继承</h2><h3 id=\"原型链的方法\"><a href=\"#原型链的方法\" class=\"headerlink\" title=\"原型链的方法\"></a>原型链的方法</h3><ul>\n<li>套路<ol>\n<li>定义父类型构造函数</li>\n<li>给父类型的原型添加方法</li>\n<li>定义子类型的构造函数</li>\n<li>创建父类型的对象赋值给子类型的原型</li>\n<li>将子类型原型的构造属性设置为子类型</li>\n<li>给子类型原型添加方法</li>\n<li>创建子类型的对象: 可以调用父类型的方法</li>\n</ol>\n</li>\n<li>关键<ol>\n<li>子类型的原型为父类型的一个实例对象<br>Child.prototype = new Parent()</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent() &#123;</span><br><span class=\"line\">    this.pProp = &#x27;this Parent prop&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.showPProp = function () &#123;</span><br><span class=\"line\">    console.log(&#x27;showPProp()&#x27;, this.pProp)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child() &#123;</span><br><span class=\"line\">    this.cProp = &#x27;this Child prop&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 让子类原型指向父类型实例</span><br><span class=\"line\">Child.prototype = new Parent()</span><br><span class=\"line\">// 让子类原型对象构造器属性指向子类</span><br><span class=\"line\">Child.prototype.constructor = Child</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype.showCProp = function () &#123;</span><br><span class=\"line\">    console.log(&#x27;showCProp()&#x27;, this.cProp)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var child = new Child()</span><br><span class=\"line\">child.showPProp()</span><br><span class=\"line\">console.log(child.constructor) // ƒ Child() &#123; this.cProp = &#x27;this Child prop&#x27;&#125;</span><br><span class=\"line\">console.log(child)   // Child &#123;cProp: &quot;this Child prop&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"class-类的方式\"><a href=\"#class-类的方式\" class=\"headerlink\" title=\"class 类的方式\"></a>class 类的方式</h3><ul>\n<li>通过class定义类/实现类的继承</li>\n<li>在类中通过constructor定义构造方法</li>\n<li>通过new来创建类的实例</li>\n<li>通过extends来实现类的继承</li>\n<li>通过super调用父类的构造方法</li>\n<li>重写从父类中继承的一般方法</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 用class定义一个Person类</span><br><span class=\"line\">class Person&#123;</span><br><span class=\"line\">    constructor (name, age)&#123;   // 类的构造方法</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    showName ()&#123;   // 类的一般方法</span><br><span class=\"line\">        console.log(this.name, this.age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let p1 = new Person(&quot;TOM&quot;, 18);</span><br><span class=\"line\">console.log(p1.name);</span><br><span class=\"line\">p1.showName();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 定义一个Student 继承Person</span><br><span class=\"line\">class Student extends Person &#123;  // 定义的Student类继承自Person类</span><br><span class=\"line\">    constructor (name, age, salary)&#123;</span><br><span class=\"line\">        super(name,age);  // 通过super调用父类的构造方法</span><br><span class=\"line\">        this.salary = salary;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    showName (name, age, salary)&#123;</span><br><span class=\"line\">        console.log(this.name, this.age, this.salary);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let s1 = new Student(&quot;MARLON&quot;, 26, 17000);</span><br><span class=\"line\">console.log(s1.name);</span><br><span class=\"line\">s1.showName();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Object-create-方法\"><a href=\"#Object-create-方法\" class=\"headerlink\" title=\"Object.create()方法\"></a>Object.create()方法</h3><ul>\n<li><code>Object.create(prototype, [descriptors])</code><ul>\n<li>作用: 以指定对象为原型创建新的对象</li>\n<li>为新的对象指定新的属性, 并对属性进行描述<br>value : 指定值<br>writable : 标识当前属性值是否是可修改的, 默认为 false</li>\n</ul>\n</li>\n<li>用法演示<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  Object.create(prototype, [descriptors])</span><br><span class=\"line\">var obj = &#123;n:11&#125;;</span><br><span class=\"line\">var obj2 = Object.create(obj);</span><br><span class=\"line\">console.log(obj2, obj2.n);   // &#123;&#125; 11</span><br><span class=\"line\">var obj3 = Object.create(obj,&#123;</span><br><span class=\"line\">    m: &#123;</span><br><span class=\"line\">        value: &quot;asd&quot;,</span><br><span class=\"line\">        writable: false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">obj3.m = 456;</span><br><span class=\"line\">console.log(obj3.m);  // asd</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"原型链-借用构造函数的组合继承\"><a href=\"#原型链-借用构造函数的组合继承\" class=\"headerlink\" title=\"原型链 + 借用构造函数的组合继承\"></a>原型链 + 借用构造函数的组合继承</h3><ul>\n<li>利用原型链实现对父类型对象的方法继承</li>\n<li>利用call()借用父类型构建函数初始化相同属性</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(name, age) &#123;</span><br><span class=\"line\">    this.name = name</span><br><span class=\"line\">    this.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.setName = function (name) &#123;</span><br><span class=\"line\">    this.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Student(name, age, price) &#123; // 身价</span><br><span class=\"line\">    Person.call(this, name, age)  // 相当于: this.Person(name, age)</span><br><span class=\"line\">    this.price = price</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Student.prototype = new Person()</span><br><span class=\"line\">Student.prototype.constructor = Student</span><br><span class=\"line\"></span><br><span class=\"line\">Student.prototype.setPrice = function (price) &#123;</span><br><span class=\"line\">    this.price = price</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var s = new Student(&#x27;Jack&#x27;, 21, 13000)</span><br><span class=\"line\">s.setName(&#x27;Bob&#x27;)</span><br><span class=\"line\">s.setPrice(14000)</span><br><span class=\"line\">console.log(s.name, s.age, s.price)</span><br></pre></td></tr></table></figure>\n\n<hr>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h1 id=\"常用前端面试参考总结\"><a href=\"#常用前端面试参考总结\" class=\"headerlink\" title=\"常用前端面试参考总结\"></a>常用前端面试参考总结</h1><p>标签（空格分隔）： Summarize Interview</p>\n<hr>\n<h2 id=\"原型与原型链\"><a href=\"#原型与原型链\" class=\"headerlink\" title=\"原型与原型链\"></a>原型与原型链</h2><h3 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h3><ul>\n<li>函数的prototype属性(图)<ul>\n<li>每个函数都有一个prototype属性, 它默认指向一个Object空对象(即称为: 原型对象)</li>\n<li>原型对象中有一个属性constructor, 它指向函数对象</li>\n</ul>\n</li>\n<li>给原型对象添加属性(一般都是方法)<ul>\n<li>作用: 函数的所有实例对象自动拥有原型中的属性(方法)</li>\n<li>原型对象上的方法一般给其实例对象调用</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"显式原型与隐式原型\"><a href=\"#显式原型与隐式原型\" class=\"headerlink\" title=\"显式原型与隐式原型\"></a>显式原型与隐式原型</h3><ul>\n<li>每个函数对象function都有一个prototype，即显式原型</li>\n<li>每个实例对象都有一个 <code>__proto__</code> ，可称为隐式原型</li>\n<li>对象的隐式原型的值为其对应构造函数的显式原型的值 ===&gt; 都指向函数对象</li>\n<li>内存结构(图)</li>\n<li>总结:<ul>\n<li>函数的prototype属性： 在定义函数时自动添加的，默认值是一个空Object对象</li>\n<li>对象的<code>__proto__</code>属性：创建对象时自动添加的，默认值为构造函数的prototype属性值</li>\n<li>程序员能直接操作显式原型，但不能直接操作隐式原型(ES6之前)</li>\n</ul>\n</li>\n<li>举个例子</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Fn()</span><br><span class=\"line\">var Fn = function () &#123;&#125;  // 执行这条函数定义语句, 函数体并没有执行</span><br><span class=\"line\"></span><br><span class=\"line\">// 每个函数function都有一个prototype，即显式原型(属性)</span><br><span class=\"line\">console.log(Fn.prototype)</span><br><span class=\"line\"></span><br><span class=\"line\">// 每个实例对象都有一个__proto__，可称为隐式原型(属性)</span><br><span class=\"line\">var fn = new Fn()</span><br><span class=\"line\">console.log(fn.__proto__)</span><br><span class=\"line\"></span><br><span class=\"line\">// 对象的隐式原型的值为其对应构造函数的显式原型的值</span><br><span class=\"line\">console.log(fn.__proto__ === Fn.prototype)  // true</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\"> 1. prototype属性: 函数对象</span><br><span class=\"line\">    什么时候添加? 函数被定义时(创建函数对象时自动添加)</span><br><span class=\"line\">    值是多少?  空的object实例对象: this.prototype = &#123;&#125;  this.prototype.constructor = this</span><br><span class=\"line\"></span><br><span class=\"line\">2. __proto__属性: 实例对象</span><br><span class=\"line\">    什么时候添加? 创建实例对象时自动添加</span><br><span class=\"line\">    值是多少?   构造函数的prototype属性值: this.__proto__ = Fn.prototype</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">/*</span><br><span class=\"line\">    执行函数: 执行函数体中的所有语句</span><br><span class=\"line\">    执行函数定义: 本质是创建函数对象</span><br><span class=\"line\">*/</span><br><span class=\"line\">console.log(Object.prototype.__proto__);  // null</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h3><ul>\n<li>原型链(图解)</li>\n<li>访问一个对象的属性时，<ul>\n<li>先在自身属性中查找，找到返回</li>\n<li>如果没有,再沿着<code>__proto__</code>这条链向上查找, 找到返回</li>\n<li>如果最终没找到,返回undefined</li>\n</ul>\n</li>\n<li>别名：隐式原型链</li>\n<li>作用：<strong>查找对象的属性(方法)</strong></li>\n<li>构造函数/原型/实体对象的关系(图解)</li>\n<li>构造函数/原型/实体对象的关系2(图解)</li>\n<li>举个例子<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(Function.prototype===Function.__proto__)  // true</span><br><span class=\"line\">console.log(Object.prototype.__proto__)  // null</span><br><span class=\"line\">console.log(Object.prototype)</span><br><span class=\"line\">function Fn() &#123;</span><br><span class=\"line\">    this.test1 = function () &#123;</span><br><span class=\"line\">        console.log(&#x27;test1()&#x27;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fn.prototype.test2 = function () &#123;</span><br><span class=\"line\">    console.log(&#x27;test2()&#x27;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var fn = new Fn()</span><br><span class=\"line\"></span><br><span class=\"line\">fn.test1()</span><br><span class=\"line\">fn.test2()</span><br><span class=\"line\">console.log(fn.toString())</span><br><span class=\"line\">console.log(fn.test3)  // undefined</span><br><span class=\"line\">fn.test3()</span><br><span class=\"line\"></span><br><span class=\"line\">// 详情请看githubMarkdownPhotos分析图</span><br></pre></td></tr></table></figure></li>\n<li><strong>原型链总结</strong><ul>\n<li>查找对象的属性沿着原型链查找，查找变量沿着作用域链查找</li>\n<li>函数对象既有<code>prototype</code>属性，也有<code>__proto__</code>属性（函数的本质是被new出来的）</li>\n<li>所有函数对象的<code>__proto__</code>属性值都相等，都等于大写的Function的 <code>prototype</code></li>\n<li>所有函数都是Function的实例，包括它自己。<br><code>Function.prototype === Function.__proto__ // true</code></li>\n<li>非函数对象（实例对象）肯定是其对应构造函数的实例</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"原型链的属性问题\"><a href=\"#原型链的属性问题\" class=\"headerlink\" title=\"原型链的属性问题\"></a>原型链的属性问题</h3><ul>\n<li>读取对象的属性值时: 会自动到原型链中查找</li>\n<li>设置对象的属性值时: 不会查找原型链, 如果当前对象中没有此属性, 直接添加此属性并设置其值</li>\n<li>即：<strong>当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作</strong></li>\n<li>方法一般定义在原型中, 属性一般通过构造函数定义在对象本身上</li>\n<li>举个例子</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(name, age) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">    this.age = age;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.setName = function (name) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.sex = &#x27;男&#x27;;</span><br><span class=\"line\"></span><br><span class=\"line\">var p1 = new Person(&#x27;Tom&#x27;, 12)</span><br><span class=\"line\">p1.setName(&#x27;Jack&#x27;)</span><br><span class=\"line\">console.log(p1.name, p1.age, p1.sex) // Jack 12 &#x27;男&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">p1.sex = &#x27;女&#x27;  // 设置属性值时, 不会查看原型链</span><br><span class=\"line\">console.log(p1.name, p1.age, p1.sex) //Jack 12 &#x27;女&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">var p2 = new Person(&#x27;Bob&#x27;, 23)</span><br><span class=\"line\">console.log(p2.name, p2.age, p2.sex) //&#x27;Bob&#x27; 23 &#x27;男&#x27;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"探索instanceof\"><a href=\"#探索instanceof\" class=\"headerlink\" title=\"探索instanceof\"></a>探索instanceof</h3><ul>\n<li>instanceof是如何判断的?<ul>\n<li>表达式: A instanceof B</li>\n<li>如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false</li>\n<li>A可以寻找多步，B只能找一步到自己的显式原型上</li>\n</ul>\n</li>\n<li>Function是通过new自己产生的实例。即所有函数都是Function的实例包括它自身。</li>\n<li>几点总结<ul>\n<li><code>Object created by Function</code></li>\n<li><code>Object 是 Function 的实例</code></li>\n<li><code>Object 是 Object 的实例</code></li>\n</ul>\n</li>\n<li>理解实例</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(Object instanceof Function) // true</span><br><span class=\"line\">console.log(Object instanceof Object) // true</span><br><span class=\"line\">console.log(Function instanceof Object) // true</span><br><span class=\"line\">console.log(Function instanceof Function) // true</span><br><span class=\"line\">console.log(Object instanceof Foo); // false</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Function.prototype) // 不是Object的实例  ƒ () &#123; [native code] &#125;</span><br><span class=\"line\">console.log(Function.prototype.__proto__===Object.prototype) // true</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>原型与原型链分析详图<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Foo () &#123;&#125;</span><br><span class=\"line\">var f1 = new Foo()</span><br><span class=\"line\">var f2 = new Foo()</span><br><span class=\"line\">var o1 = &#123;&#125;</span><br><span class=\"line\">var o2 = &#123;&#125;</span><br></pre></td></tr></table></figure>\n<img src=\"https://i.imgur.com/Q3nxgq6.png\" alt=\"原型与原型链分析\"></li>\n</ul>\n<h3 id=\"面试题及总结\"><a href=\"#面试题及总结\" class=\"headerlink\" title=\"面试题及总结\"></a>面试题及总结</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 测试题 1</span><br><span class=\"line\">var A = function() &#123;&#125;</span><br><span class=\"line\">A.prototype.n = 1</span><br><span class=\"line\">var b = new A()</span><br><span class=\"line\"></span><br><span class=\"line\">A.prototype = &#123;</span><br><span class=\"line\">    n: 2,</span><br><span class=\"line\">    m: 3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var c = new A()</span><br><span class=\"line\">console.log(b.n, b.m, c.n, c.m) //  1 undefined  2  3</span><br><span class=\"line\"></span><br><span class=\"line\">// 测试题2</span><br><span class=\"line\">var F = function()&#123;&#125;;</span><br><span class=\"line\">Object.prototype.a = function()&#123;</span><br><span class=\"line\">    console.log(&#x27;a()&#x27;)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Function.prototype.b = function()&#123;</span><br><span class=\"line\">    console.log(&#x27;b()&#x27;)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var f = new F();</span><br><span class=\"line\">f.a()     // a()</span><br><span class=\"line\">f.b()     // f.b is not a function</span><br><span class=\"line\">F.a()     // a()</span><br><span class=\"line\">F.b()     // b()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--</span><br><span class=\"line\">原型链（隐式原型链）：作用查找对象的属性</span><br><span class=\"line\">    访问一个对象的属性时，先在自身属性中查找，找到返回；</span><br><span class=\"line\">    如果没有再沿着 __proto__ 这条链向上查找，找到返回，如果最终没有找到，则返回undefined</span><br><span class=\"line\"></span><br><span class=\"line\">A instanceof B  的判断</span><br><span class=\"line\">    如果B函数的显式原型对象在A对象的原型链上, 返回true, 否则返回false</span><br><span class=\"line\"></span><br><span class=\"line\">prototype 与 __proto__ 在创建的时候相关联，在执行的时候没有关联</span><br><span class=\"line\">--&gt;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"webpack及构建工具的理解\"><a href=\"#webpack及构建工具的理解\" class=\"headerlink\" title=\"webpack及构建工具的理解\"></a>webpack及构建工具的理解</h2><h3 id=\"构建工具的功能\"><a href=\"#构建工具的功能\" class=\"headerlink\" title=\"构建工具的功能\"></a>构建工具的功能</h3><ul>\n<li><strong>代码转换</strong>：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等。（开发写的代码有些浏览器无法识别，如ES6语法）</li>\n<li><strong>文件优化</strong>：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等。（压缩代码）</li>\n<li><strong>模块合并</strong>：在采用模块化的项目里会有很多个模块和文件，需要构建功能把模块分类合并成一个文件。</li>\n<li><strong>代码分割</strong>：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载。</li>\n<li><strong>自动刷新</strong>：监听本地源代码的变化，自动重新构建、刷新浏览器。 live reload 自动刷新 / hot reload 热模替换（HMR）（开发环境下修改代码后可以自动刷新浏览器看到最新的效果，可以监视源码的变化）</li>\n<li><strong>代码校验</strong>：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</li>\n</ul>\n<h3 id=\"模块化打包和非模块化打包思想差异\"><a href=\"#模块化打包和非模块化打包思想差异\" class=\"headerlink\" title=\"模块化打包和非模块化打包思想差异\"></a>模块化打包和非模块化打包思想差异</h3><ul>\n<li>非模块化打包：先对文件进行分类（如js/img/css等），然后分别打包</li>\n<li>模块化打包：将所有资源看成模块，而所有的模块之间都是有关系的，项目中的资源是相互关联的节点通过入口js形成一个网(图)的结构。<ul>\n<li>从入口开始递归的查找所有相关联的模块</li>\n<li>找到一个模块(如css)后会找对应的loader，模块文件会进行正则匹配的</li>\n<li>四个核心概念：entry | output | module(loader) | plugins</li>\n<li>loader模块加载器，将非js模块打包成webpack能理解的js模块</li>\n<li>图片处理推荐使用 <code>url-loader</code>，配置选项可以对图片进行限制，小于此限制的会会通过base64处理的</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"webpack的核心概念\"><a href=\"#webpack的核心概念\" class=\"headerlink\" title=\"webpack的核心概念\"></a>webpack的核心概念</h3><ul>\n<li><strong>Entry</strong>：入口，Webpack进行打包的起始点(文件)</li>\n<li><strong>Output</strong>：出口，webpack编译打包生成的bundle(文件)</li>\n<li><strong>Loader</strong>：模块加载(转换)器，将非js模块包装成webpack能理解的js模块<ul>\n<li>（举例：如处理css要用到style-loader/css-loader;处理img使用file-loader/url-loader）</li>\n</ul>\n</li>\n<li><strong>Plugin</strong>：插件，在Webpack构建流程中的特定时机插入具有特定功能的代码<ul>\n<li>（举例：CleanPlugin一开始就会清除指定的文件/夹；</li>\n<li>ExtractTextPlugin用于样式的抽取，用来从js中分离出css并单独打包；</li>\n<li>CopyPlugin复制静态资源；</li>\n<li>webpack.HashedModuleIdsPlugin根据代码内容生成hash作为模块的id(默认是下标)；</li>\n<li>webpack.optimize.CommonsChunkPlugin将第三方模块单独打包</li>\n<li>……） </li>\n</ul>\n</li>\n<li>Module：模块，在 Webpack眼里一切皆模块，默认只识别js文件，如果是其它类型文件利用对应的loader转换为js模块</li>\n<li>Chunk：代码块，一个 Chunk 由多个模块组合而成，最终浏览器执行的是webpack打包生成的chunk文件(bundle同理)</li>\n</ul>\n<h3 id=\"webpack的其他概念\"><a href=\"#webpack的其他概念\" class=\"headerlink\" title=\"webpack的其他概念\"></a>webpack的其他概念</h3><ul>\n<li><img src=\"http://static.zybuluo.com/MarlonChiu/12qcvudloms3ft00fsxugjtt/webpack%E5%85%B6%E5%AE%83%E6%A6%82%E5%BF%B5_1.png\" alt=\"webpack其它概念_1.png-39.4kB\"></li>\n<li><img src=\"http://static.zybuluo.com/MarlonChiu/sxodezube6trrxitofbx3drp/webpack%E5%85%B6%E5%AE%83%E6%A6%82%E5%BF%B5_2.png\" alt=\"webpack其它概念_2.png-27.8kB\"></li>\n</ul>\n<h3 id=\"webpack-和-gulp-的区别\"><a href=\"#webpack-和-gulp-的区别\" class=\"headerlink\" title=\"webpack 和 gulp 的区别\"></a>webpack 和 gulp 的区别</h3><ul>\n<li>webpack 是一种模块化打包工具，主要用于模块化方案，预编译模块的方案；</li>\n<li>gulp 是工具链、构建工具，可以配合各种插件做 js 压缩，css压缩，less 编译替代手工实现自动化工作。</li>\n<li>Grunt/Gulp 更多的是一种工作流；提供集成所有服务的一站式平台； gulp可以用来优化前端工作流程。</li>\n</ul>\n<h2 id=\"客户端两种存储\"><a href=\"#客户端两种存储\" class=\"headerlink\" title=\"客户端两种存储\"></a>客户端两种存储</h2><h3 id=\"Cookie存储\"><a href=\"#Cookie存储\" class=\"headerlink\" title=\"Cookie存储\"></a>Cookie存储</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Cookie是一项很老的技术的，就是因为它老，所以兼容性还是不错的。</span><br><span class=\"line\">使用Cookie作为本地存储优点：兼容性好，缺点：操作繁琐，只能存简单的数据，还会过期，站点设置httponly的话，JS就不无法操作Cookie了。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Web-Storage存储\"><a href=\"#Web-Storage存储\" class=\"headerlink\" title=\"Web Storage存储\"></a>Web Storage存储</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WebStorage是HTML5中为WebApplication提供一种存储的API，目前主流的新版本的浏览器都支持，当然IE789你就没有办法了。WebStorage主要分成localStorage和sessionStorage两种。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"sessionStorage\"><a href=\"#sessionStorage\" class=\"headerlink\" title=\"sessionStorage\"></a>sessionStorage</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sessionStorage是个全局对象，它维护着在页面会话(page session)期间有效的存储空间。只要浏览器开着，页面会话周期就会一直持续。当页面重新载入(reload)或者被恢复(restores)时，页面会话也是一直存在的。每在新标签或者新窗口中打开一个新页面，都会初始化一个新的会话。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"localStorage\"><a href=\"#localStorage\" class=\"headerlink\" title=\"localStorage\"></a>localStorage</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localStorage也是一个全局变量，它的生命周期比sessionStorage长。localStorage和sessionStorage都继承自Storage因此它们的用法相同。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"WebStorage的优点\"><a href=\"#WebStorage的优点\" class=\"headerlink\" title=\"WebStorage的优点\"></a>WebStorage的优点</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用简单方便，缺点：IE有些版本不支持，不能存复杂的对象，必须先转化成JSON字符串，没有索引搜索效率不高，只能同步读写操作，当写入的数据比较大时可能造成JS引擎堵塞。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"sessionStorage用法和localStorage区别\"><a href=\"#sessionStorage用法和localStorage区别\" class=\"headerlink\" title=\"sessionStorage用法和localStorage区别\"></a>sessionStorage用法和localStorage区别</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">完全一致，差别只在有效期：</span><br><span class=\"line\">sessionStorage在用户结束会话（即关闭浏览器或退出账户时失效）；</span><br><span class=\"line\">localStorage无失效期，用户在清理浏览器缓存的时候会被清除。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Cookie存储和Web-Storage存储区别\"><a href=\"#Cookie存储和Web-Storage存储区别\" class=\"headerlink\" title=\"Cookie存储和Web Storage存储区别\"></a>Cookie存储和Web Storage存储区别</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localStorage与sessionStorage作为新时代的产物，相比旧时代的cookie有其巨大的优越性。优越性有三:</span><br><span class=\"line\">    其一在能存储的数据量，cookie最大能存储4kb的数据，而localStorage与sessionStorage最大能存储5Mb，目前各大浏览器支持的标准都是如此；</span><br><span class=\"line\">    </span><br><span class=\"line\">    其二在功能上，cookie只能存储String类型的数据，以往要将用户数据存储在本地，需要将数据拼接成字符串，再存进cookie,取数据的时候同样麻烦，先将整个cookie对象拿到（String对象），再按拼接的规则拆分，再拿需要的数据，存取都很麻烦！</span><br><span class=\"line\">    localStorage与sessionStorage不仅支持传统的String类型，还可以将json对象存储进去,存取数据都方便不少，json的优越性就不赘述，localStorage与sessionStorage无疑更现代化；</span><br><span class=\"line\">    </span><br><span class=\"line\">    其三是cookie是不可或缺的，cookie的作用是与服务器进行交互，作为http规范的一部分而存在；而web storage仅仅是为了在本地‘存储’而生；</span><br><span class=\"line\">    其四在语义层面上，localStorage与sessionStorage语法更优雅、简便。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"存储方式的操作对比演示\"><a href=\"#存储方式的操作对比演示\" class=\"headerlink\" title=\"存储方式的操作对比演示\"></a>存储方式的操作对比演示</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// cookie的操作</span><br><span class=\"line\">设置cookie: document.cookie = &#x27;key=value&#x27;;</span><br><span class=\"line\">获取cookie: document.cookie;</span><br><span class=\"line\">删除cookie: document.cookie = &quot;key=value;max-age=0&quot;;</span><br><span class=\"line\">设置max-age存储期限: document.cookie = &quot;key=value;max-age=1000&quot;; // 1000秒</span><br><span class=\"line\"></span><br><span class=\"line\">// web storage操作</span><br><span class=\"line\">保存数据 setItem(key,value)</span><br><span class=\"line\">读取数据 getItem(key)</span><br><span class=\"line\">删除单个数据 removeItem(key)</span><br><span class=\"line\">清空全部数据 clearItem()</span><br><span class=\"line\">获取数据索引 key(index)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"cookie-storage-session-关系\"><a href=\"#cookie-storage-session-关系\" class=\"headerlink\" title=\"cookie / storage / session 关系\"></a>cookie / storage / session 关系</h3><ul>\n<li>cookie<ul>\n<li>优点：可以解决http无状态问题 </li>\n<li>缺点：<ol>\n<li>与服务器交互的时候有数量和长度限制 每个域名最多20条，长度不能超过4KB  </li>\n<li>安全性问题 容易被人拦截 </li>\n<li>浪费宽带，每次请求新页面，cookie都会被发过去 </li>\n<li>不可以跨域  </li>\n</ol>\n</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li>cookie 和session区别<ul>\n<li>cookie是把数据放在客户的浏览器上，只能存储sting类型</li>\n<li>session数据是放在服务器上，能存储json 类型、sting类型</li>\n<li>session会在一定的时间内保留数据存在服务器上，当访问增多，<br>会比较占你服务器的性能 ，减轻服务器的性能 应当使用cookie</li>\n<li>sessionStorage是当前对话的缓存，浏览器窗口关闭即消失，会话级别的存储</li>\n<li>localStorage持久存在，除非清除浏览器缓存。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"数组的一些方法\"><a href=\"#数组的一些方法\" class=\"headerlink\" title=\"数组的一些方法\"></a>数组的一些方法</h2><h3 id=\"数组去重\"><a href=\"#数组去重\" class=\"headerlink\" title=\"数组去重\"></a>数组去重</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">1.先将原数组进行排序</span></span><br><span class=\"line\"><span class=\"comment\">2.检查原数组中的第i个元素 与 结果数组中的最后一个元素是否相同，因为已经排序，所以重复元素会在相邻位置</span></span><br><span class=\"line\"><span class=\"comment\">3.如果不相同，则将该元素存入结果数组中</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.unique1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.sort(); <span class=\"comment\">//先排序</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = [<span class=\"built_in\">this</span>[<span class=\"number\">0</span>]];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; <span class=\"built_in\">this</span>.length; i++)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"built_in\">this</span>[i] !== res[res.length - <span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">        res.push(<span class=\"built_in\">this</span>[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">1.创建一个新的数组存放结果</span></span><br><span class=\"line\"><span class=\"comment\">2.创建一个空对象</span></span><br><span class=\"line\"><span class=\"comment\">3.for循环时，每次取出一个元素与对象进行对比，如果这个元素不重复，</span></span><br><span class=\"line\"><span class=\"comment\">  则把它存放到结果数组中，同时把这个元素的内容作为对象的一个属性，</span></span><br><span class=\"line\"><span class=\"comment\">  并赋值为1，存入到第2步建立的对象中。</span></span><br><span class=\"line\"><span class=\"comment\">说明：至于如何对比，就是每次从原数组中取出一个元素，然后到对象中去访问这个属性，如果能访问到值，则说明重复。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.unique2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> res = [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> json = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"built_in\">this</span>.length; i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!json[<span class=\"built_in\">this</span>[i]])&#123;</span><br><span class=\"line\">            res.push(<span class=\"built_in\">this</span>[i]);</span><br><span class=\"line\">            json[<span class=\"built_in\">this</span>[i]] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = [<span class=\"number\">112</span>,<span class=\"number\">112</span>,<span class=\"number\">34</span>,<span class=\"string\">&#x27;你好&#x27;</span>,<span class=\"number\">112</span>,<span class=\"number\">112</span>,<span class=\"number\">34</span>,<span class=\"string\">&#x27;你好&#x27;</span>,<span class=\"string\">&#x27;str&#x27;</span>,<span class=\"string\">&#x27;str1&#x27;</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">7</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">11</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">0</span>];</span><br><span class=\"line\"><span class=\"comment\">// 方法零</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr));  <span class=\"comment\">// Set(7) &#123;1, 7, 3, 4, 11, 2, 0&#125;</span></span><br><span class=\"line\"><span class=\"comment\">// 方法一</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.unique1()); <span class=\"comment\">// (7) [0, 1, 11, 2, 3, 4, 7]  按照Unicode排列了</span></span><br><span class=\"line\"><span class=\"comment\">// 方法二</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.unique2()); <span class=\"comment\">// (7) [0, 1, 11, 2, 3, 4, 7]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组排序\"><a href=\"#数组排序\" class=\"headerlink\" title=\"数组排序\"></a>数组排序</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function quickSort(arr) &#123;</span><br><span class=\"line\">  if(arr.length &lt;= 1)&#123;</span><br><span class=\"line\">    return arr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  // 基准索引（理论上可以任意选取）</span><br><span class=\"line\">  var pivotIndex = parseInt(arr.length/2),</span><br><span class=\"line\">    // 基准值</span><br><span class=\"line\">    pivot = arr.splice(pivotIndex,1)[0],</span><br><span class=\"line\">    leftArr = [],</span><br><span class=\"line\">    rightArr = [],</span><br><span class=\"line\">    length = arr.length;</span><br><span class=\"line\">  // 遍历序列，根据基准拆分为两个子序列</span><br><span class=\"line\">  for (var i = 0; i &lt; length; i++) &#123;</span><br><span class=\"line\">    if(arr[i] &lt; pivot)&#123;</span><br><span class=\"line\">      leftArr.push(arr[i]);</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">      rightArr.push(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  console.log(pivot); // 输出了三次 3 1 7</span><br><span class=\"line\">  </span><br><span class=\"line\">  // 连接左序列、基准、右序列</span><br><span class=\"line\">  return quickSort(leftArr).concat(pivot, quickSort(rightArr))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var demoArr = [8,4,7,2,0,3,1]</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法一</span><br><span class=\"line\">console.log(demoArr.sort()); // (7) [0, 1, 2, 3, 4, 7, 8]</span><br><span class=\"line\">// 方法二</span><br><span class=\"line\">console.log(quickSort(demoArr)) // (7) [0, 1, 2, 3, 4, 7, 8]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"前端WEB-H5性能优化\"><a href=\"#前端WEB-H5性能优化\" class=\"headerlink\" title=\"前端WEB/H5性能优化\"></a>前端WEB/H5性能优化</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 参考CSDN博客</span><br><span class=\"line\">http://blog.csdn.net/lpf1215/article/details/74315797?locationNum=8&amp;fps=1</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>减少http请求，合理设置 HTTP缓存</li>\n<li>使用浏览器缓存</li>\n<li>启用压缩</li>\n<li>CSS Sprites</li>\n<li>LazyLoad Images</li>\n<li>CSS放在页面最上部，javascript放在页面最下面</li>\n<li>异步请求Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容）</li>\n<li>减少cookie传输</li>\n<li>Javascript代码优化</li>\n<li>CSS选择符优化</li>\n<li>CDN加速</li>\n<li>反向代理</li>\n</ul>\n<h2 id=\"px-em-rem-区别\"><a href=\"#px-em-rem-区别\" class=\"headerlink\" title=\"px em rem 区别\"></a>px em rem 区别</h2><ul>\n<li>px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的</li>\n<li>em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸</li>\n<li>rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素</li>\n</ul>\n<h2 id=\"实现一个jsonp请求\"><a href=\"#实现一个jsonp请求\" class=\"headerlink\" title=\"实现一个jsonp请求\"></a>实现一个jsonp请求</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class=\"line\">function jsonpCallback(result) &#123;</span><br><span class=\"line\">    // alert(result);  </span><br><span class=\"line\">    for(var i in result) &#123;</span><br><span class=\"line\">        alert(i+&quot;:&quot;+result[i]);// 循环输出a:1,b:2,etc.  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var JSONP = document.createElement(&quot;script&quot;);</span><br><span class=\"line\">JSONP.type = &quot;text/javascript&quot;;</span><br><span class=\"line\">JSONP.src = &quot;http://crossdomain.com/services.php?callback=jsonpCallback&quot;;</span><br><span class=\"line\">document.getElementsByTagName(&quot;head&quot;)[0].appendChild(JSONP);</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"原型与原型链分析图例\"><a href=\"#原型与原型链分析图例\" class=\"headerlink\" title=\"原型与原型链分析图例\"></a>原型与原型链分析图例</h2><ul>\n<li><p>图例一<br><img src=\"http://static.zybuluo.com/MarlonChiu/v5fxgw1c326yrmvru8gt4qxa/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90%E5%9B%BE%E4%BE%8B_01.png\" alt=\"原型链分析图例_01.png-35.1kB\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 图例分析说明</span><br></pre></td></tr></table></figure></li>\n<li><p>图例二<br><img src=\"http://static.zybuluo.com/MarlonChiu/qj4jj2hpkqymby58zjazwl7x/%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90%E5%9B%BE%E4%BE%8B_02.png\" alt=\"原型链分析图例_02.png-46.7kB\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 图例分析说明</span><br><span class=\"line\">两个空间：栈和堆。在代码未执行之前，JS引擎就会先加载执行一些内置的代码就。在开始之前就先执行了Object定义（function Object(value)&#123;&#125;），栈空间会有一个Object引用变量，传的是地址值0x123，开辟出一块空间，该空间就是Object函数对象，函数对象上有一个prototype属性，该属性也是引用类型，传递地址值0x234，开辟出一块新的空间，该空间指向Object原型对象，该Object原型对象的原型上包含hasOwnProperty、toString......等一些属性，也就说在代码执行之前第一列的关系已经存在了。</span><br><span class=\"line\"></span><br><span class=\"line\">代码执行function Fn()&#123;&#125;，Fn指向的堆空间中一块区域，地址值为0x345，即Fn函数对象，Fn函数对象有一个prototype属性，该属性也是指向一块地址值0x456，指向Fn原型对象，该对象是一个空对象即&#123;&#125;。这个实例对象的__proto__又会指向Object的函数对象的prototype属性（实例对象的隐式原型等于函数对象的显示原型），地址值也是0x234，也会指向Object原型对象。</span><br><span class=\"line\">代码执行Fn.prototype.test2 则在Fn原型对象上添加test2()方法</span><br><span class=\"line\"></span><br><span class=\"line\">代码执行var fn = new Fn()，fn的地址值为0x567，在堆内存中开辟空间指向Fn实例对象，该对象有隐式原型__proto__，其值是0x456，箭头指向Fn原型对象。Fn实例对象上有个方法test1()。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">console.log(Function.prototype === Function.__proto__)  // true</span><br><span class=\"line\">console.log(Object.prototype.__proto__)  // null</span><br><span class=\"line\">console.log(Object.prototype.toString)  // ƒ toString() &#123; [native code] &#125;  Object原型上有toString方法</span><br></pre></td></tr></table></figure></li>\n<li><p>图例三<br><img src=\"http://static.zybuluo.com/MarlonChiu/2o4q7d8zguhokxee7b4avun1/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%88%86%E6%9E%90%E5%9B%BE%E4%BE%8B_03.png\" alt=\"原型与原型链分析图例_03.png-129.8kB\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Foo() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var f1 = new Foo()</span><br><span class=\"line\">var f2 = new Foo()</span><br><span class=\"line\">var o1 = &#123;&#125;</span><br><span class=\"line\">var o2 = &#123;&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>图例四<br><img src=\"http://static.zybuluo.com/MarlonChiu/4shqfy3qe573pw8t7fi70jpz/%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%88%86%E6%9E%90.png\" alt=\"函数对象的原型分析.png-60.3kB\"></p>\n</li>\n</ul>\n<h2 id=\"实现类的继承\"><a href=\"#实现类的继承\" class=\"headerlink\" title=\"实现类的继承\"></a>实现类的继承</h2><h3 id=\"原型链的方法\"><a href=\"#原型链的方法\" class=\"headerlink\" title=\"原型链的方法\"></a>原型链的方法</h3><ul>\n<li>套路<ol>\n<li>定义父类型构造函数</li>\n<li>给父类型的原型添加方法</li>\n<li>定义子类型的构造函数</li>\n<li>创建父类型的对象赋值给子类型的原型</li>\n<li>将子类型原型的构造属性设置为子类型</li>\n<li>给子类型原型添加方法</li>\n<li>创建子类型的对象: 可以调用父类型的方法</li>\n</ol>\n</li>\n<li>关键<ol>\n<li>子类型的原型为父类型的一个实例对象<br>Child.prototype = new Parent()</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Parent() &#123;</span><br><span class=\"line\">    this.pProp = &#x27;this Parent prop&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.showPProp = function () &#123;</span><br><span class=\"line\">    console.log(&#x27;showPProp()&#x27;, this.pProp)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Child() &#123;</span><br><span class=\"line\">    this.cProp = &#x27;this Child prop&#x27;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 让子类原型指向父类型实例</span><br><span class=\"line\">Child.prototype = new Parent()</span><br><span class=\"line\">// 让子类原型对象构造器属性指向子类</span><br><span class=\"line\">Child.prototype.constructor = Child</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype.showCProp = function () &#123;</span><br><span class=\"line\">    console.log(&#x27;showCProp()&#x27;, this.cProp)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var child = new Child()</span><br><span class=\"line\">child.showPProp()</span><br><span class=\"line\">console.log(child.constructor) // ƒ Child() &#123; this.cProp = &#x27;this Child prop&#x27;&#125;</span><br><span class=\"line\">console.log(child)   // Child &#123;cProp: &quot;this Child prop&quot;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"class-类的方式\"><a href=\"#class-类的方式\" class=\"headerlink\" title=\"class 类的方式\"></a>class 类的方式</h3><ul>\n<li>通过class定义类/实现类的继承</li>\n<li>在类中通过constructor定义构造方法</li>\n<li>通过new来创建类的实例</li>\n<li>通过extends来实现类的继承</li>\n<li>通过super调用父类的构造方法</li>\n<li>重写从父类中继承的一般方法</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 用class定义一个Person类</span><br><span class=\"line\">class Person&#123;</span><br><span class=\"line\">    constructor (name, age)&#123;   // 类的构造方法</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">        this.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    showName ()&#123;   // 类的一般方法</span><br><span class=\"line\">        console.log(this.name, this.age);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let p1 = new Person(&quot;TOM&quot;, 18);</span><br><span class=\"line\">console.log(p1.name);</span><br><span class=\"line\">p1.showName();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">// 定义一个Student 继承Person</span><br><span class=\"line\">class Student extends Person &#123;  // 定义的Student类继承自Person类</span><br><span class=\"line\">    constructor (name, age, salary)&#123;</span><br><span class=\"line\">        super(name,age);  // 通过super调用父类的构造方法</span><br><span class=\"line\">        this.salary = salary;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    showName (name, age, salary)&#123;</span><br><span class=\"line\">        console.log(this.name, this.age, this.salary);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let s1 = new Student(&quot;MARLON&quot;, 26, 17000);</span><br><span class=\"line\">console.log(s1.name);</span><br><span class=\"line\">s1.showName();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Object-create-方法\"><a href=\"#Object-create-方法\" class=\"headerlink\" title=\"Object.create()方法\"></a>Object.create()方法</h3><ul>\n<li><code>Object.create(prototype, [descriptors])</code><ul>\n<li>作用: 以指定对象为原型创建新的对象</li>\n<li>为新的对象指定新的属性, 并对属性进行描述<br>value : 指定值<br>writable : 标识当前属性值是否是可修改的, 默认为 false</li>\n</ul>\n</li>\n<li>用法演示<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//  Object.create(prototype, [descriptors])</span><br><span class=\"line\">var obj = &#123;n:11&#125;;</span><br><span class=\"line\">var obj2 = Object.create(obj);</span><br><span class=\"line\">console.log(obj2, obj2.n);   // &#123;&#125; 11</span><br><span class=\"line\">var obj3 = Object.create(obj,&#123;</span><br><span class=\"line\">    m: &#123;</span><br><span class=\"line\">        value: &quot;asd&quot;,</span><br><span class=\"line\">        writable: false</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">obj3.m = 456;</span><br><span class=\"line\">console.log(obj3.m);  // asd</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"原型链-借用构造函数的组合继承\"><a href=\"#原型链-借用构造函数的组合继承\" class=\"headerlink\" title=\"原型链 + 借用构造函数的组合继承\"></a>原型链 + 借用构造函数的组合继承</h3><ul>\n<li>利用原型链实现对父类型对象的方法继承</li>\n<li>利用call()借用父类型构建函数初始化相同属性</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(name, age) &#123;</span><br><span class=\"line\">    this.name = name</span><br><span class=\"line\">    this.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person.prototype.setName = function (name) &#123;</span><br><span class=\"line\">    this.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Student(name, age, price) &#123; // 身价</span><br><span class=\"line\">    Person.call(this, name, age)  // 相当于: this.Person(name, age)</span><br><span class=\"line\">    this.price = price</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Student.prototype = new Person()</span><br><span class=\"line\">Student.prototype.constructor = Student</span><br><span class=\"line\"></span><br><span class=\"line\">Student.prototype.setPrice = function (price) &#123;</span><br><span class=\"line\">    this.price = price</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var s = new Student(&#x27;Jack&#x27;, 21, 13000)</span><br><span class=\"line\">s.setName(&#x27;Bob&#x27;)</span><br><span class=\"line\">s.setPrice(14000)</span><br><span class=\"line\">console.log(s.name, s.age, s.price)</span><br></pre></td></tr></table></figure>\n\n<hr>\n"},{"title":"JavaScript中的异步编程解决方案","date":"2021-03-18T09:05:05.000Z","type":"技术","note":"ES6 诞生以前，异步编程的方法有四种：回调函数、事件监听、发布/订阅、Promise 对象。","_content":"\n## Generator 函数\n学习指导：[阮一峰ES6 -- Generator函数](http://es6.ruanyifeng.com/#docs/generator)\n\n### 基本概念\n* 语法上：Generator 函数是一个状态机，封装了多个内部状态；执行 Generator 函数会返回一个遍历器对象。也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\n* 形式上：Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号`*`；二是，函数体内部使用`yield`表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。\n\n```javascript\nfunction* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\nvar hw = helloWorldGenerator();\n\n// 定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world）\n// 即该函数有三个状态：hello，world 和 return 语句（结束执行）。\n```\n\n* 调用Generator函数，返回一个遍历器对象，代表Generator函数的内部指针。以后，每次调用遍历器对象的`next`方法，就会返回一个有着`value和done`两个属性的对象。`value`属性表示当前的内部状态的值，是`yield`表达式后面那个表达式的值；`done`属性是一个布尔值，表示是否遍历结束。\n\n```javascript\n// 上述函数下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。\n// 即每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，\n// 直到遇到下一个yield表达式（或return语句）为止。\n// 换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。\n\nhw.next()\n// { value: 'hello', done: false }\nhw.next()\n// { value: 'world', done: false }\nhw.next()\n// { value: 'ending', done: true }\nhw.next()\n// { value: undefined, done: true }\n\n/*\n解释说明：\n上面代码一共调用了四次next方法。\n第一次调用，Generator 函数开始执行，直到遇到第一个yield表达式为止。\nnext方法返回一个对象，它的value属性就是当前yield表达式的值hello，\ndone属性的值false，表示遍历还没有结束。\n\n第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。\nnext方法返回的对象的value属性就是当前yield表达式的值world，\ndone属性的值false，表示遍历还没有结束。\n\n第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句\n（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，\n就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），\ndone属性的值true，表示遍历已经结束。\n\n第四次调用，此时 Generator 函数已经运行完毕，\nnext方法返回对象的value属性为undefined，done属性为true。\n以后再调用next方法，返回的都是这个值。\n*/\n```\n\n### yield 表达式说明\n* Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。\n* 遍历器对象的next方法的运行逻辑如下。\n   * 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。\n   * 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。\n   * 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。\n   * 如果该函数没有return语句，则返回的对象的 value 属性值为 undefined。\n* 需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。\n\n```javascript\nfunction* gen(){\n  yield 123 + 456;\n}\n\n// yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值.\n```\n\n### yield 表达式语法\n* yield表达式只能用在 Generator 函数里面，用在其他地方都会报错\n\n```javascript\n(function (){\n  yield 1;\n})()\n// SyntaxError: Unexpected number\n```\n\n* yield表达式如果用在另一个表达式之中，必须放在圆括号里面\n\n```javascript\nfunction* demo() {\n  console.log('Hello' + yield); // SyntaxError\n  console.log('Hello' + yield 123); // SyntaxError\n\n  console.log('Hello' + (yield)); // OK\n  console.log('Hello' + (yield 123)); // OK\n}\n```\n\n* yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号\n\n```javascript\nfunction* demo() {\n  foo(yield 'a', yield 'b'); // OK\n  let input = yield; // OK\n}\n```\n\n### 用法实例讲解\n\n```javascript\nvar arr = [1, [[2, 3], 4], [5, 6]];\n\nvar flat = function* (a) {\n  a.forEach(function (item) {\n    if (typeof item !== 'number') {\n      yield* flat(item);\n    } else {\n      yield item;\n    }\n  });\n};  // 错误用法\n// forEach方法的参数是一个普通函数，但是在里面使用了yield表达式\n\n// 一种修改方法是改用for循环。\nvar flat = function* (a) {\n  var length = a.length;\n  for (var i = 0; i < length; i++) {\n    var item = a[i];\n    if (typeof item !== 'number') {\n      yield* flat(item);\n    } else {\n      yield item;\n    }\n  }\n};\n\nfor (var f of flat(arr)) {\n  console.log(f);\n}\n// 1, 2, 3, 4, 5, 6\n```\n\n### yield表达式与return语句\n* yield 表达式与return 语句既有相似之处，也有区别。  \n* 相似之处在于，都能返回紧跟在语句后面的那个表达式的值。  \n* 区别在于每次遇到`yield`，函数暂停执行，下一次再从该位置继续向后执行，而`return`语句不具备位置记忆的功能。 \n* 一个函数里面，**只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式**。  \n* 正常函数只能返回一个值，因为只能执行一次return；  \n* Generator 函数可以返回一系列的值，因为可以有任意多个`yield`。  \n* 从另一个角度看，也可以说 Generator 生成了一系列的值。  \n\n### next 方法的参数\n* `yield`表达式本身没有返回值，或者说总是返回`undefined`。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。\n\n```javascript\nfunction* f() {\n  for(var i = 0; true; i++) {\n    var reset = yield i;\n    if(reset) { i = -1; }\n  }\n}\nvar g = f();\n\ng.next() // { value: 0, done: false }\ng.next() // { value: 1, done: false }\ng.next(true) // { value: 0, done: false }\n\n/*\n上面代码先定义了一个可以无限运行的 Generator 函数f，\n如果next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined。\n\n当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，\n下一轮循环就会从-1开始递增。\n */\n```\n\n* 这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。\n* 通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。  \n\n```js\nfunction* foo(x) {\n  var y = 2 * (yield (x + 1));\n  var z = yield (y / 3);\n  return (x + y + z);\n}\n\nvar a = foo(5);\na.next() // Object{value:6, done:false}\na.next() // Object{value:NaN, done:false}\na.next() // Object{value:NaN, done:true}\n\nvar b = foo(5);\nb.next() // { value:6, done:false }\nb.next(12) // { value:8, done:false }\nb.next(13) // { value:42, done:true }\n\n/*\n上面代码中，第二次运行next方法的时候不带参数，导致 y 的值等于2 * undefined（即NaN），\n除以 3 以后还是NaN，因此返回对象的value属性也等于NaN。\n第三次运行Next方法的时候不带参数，所以z等于undefined，\n返回对象的value属性等于5 + NaN + undefined，即NaN。\n\n如果向next方法提供参数，返回结果就完全不一样了。\n上面代码第一次调用b的next方法时，返回x+1的值6；\n第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；\n第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，\n这时x等于5，y等于24，所以return语句的值等于42。\n*/\n```\n\n\n* 注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。  \n\n### for...of 循环\n* 1) for...of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。  \n\n```javascript\n\nfunction* foo() {\n  yield 1;\n  yield 2;\n  yield 3;\n  yield 4;\n  yield 5;\n  return 6;\n}\nfor (let v of foo()) {\n  console.log(v);\n}\n// 1 2 3 4 5\n\n// 上面代码使用for...of循环，依次显示 5 个yield表达式的值。\n// 这里需要注意，一旦next方法的返回对象的done属性为true，\n// for...of循环就会中止，且不包含该返回对象，\n// 所以上面代码的return语句返回的6，不包括在for...of循环之中。\n```  \n\n* 2)利用`for...of`循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用for...of循环，通过 Generator 函数为它加上这个接口，就可以用了。\n\n```javascript\nfunction* objectEntries(obj) {\n  let propKeys = Reflect.ownKeys(obj);\n\n  for (let propKey of propKeys) {\n    yield [propKey, obj[propKey]];\n  }\n}\n\nlet jane = { first: 'Jane', last: 'Doe' };\n\nfor (let [key, value] of objectEntries(jane)) {\n  console.log(`${key}: ${value}`);\n}\n// first: Jane\n// last: Doe\n```\n\n* 3)加上遍历器接口的另一种写法是，将 Generator 函数加到对象的`Symbol.iterator`属性上面\n\n```javascript\nfunction* objectEntries() {\n  let propKeys = Object.keys(this);\n\n  for (let propKey of propKeys) {\n    yield [propKey, this[propKey]];\n  }\n}\n\nlet jane = { first: 'Jane', last: 'Doe' };\n\njane[Symbol.iterator] = objectEntries;\n\nfor (let [key, value] of jane) {\n  console.log(`${key}: ${value}`);\n}\n// first: Jane\n// last: Doe\n```\n\n* 4)除了for...of循环以外，`扩展运算符（...）`、`解构赋值`和`Array.from`方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。  \n\n```js\nfunction* numbers () {\n  yield 1\n  yield 2\n  return 3\n  yield 4\n}\n\n// 扩展运算符\n[...numbers()] // [1, 2]\n\n// Array.from 方法\nArray.from(numbers()) // [1, 2]\n\n// 解构赋值\nlet [x, y] = numbers();\nx // 1\ny // 2\n\n// for...of 循环\nfor (let n of numbers()) {\n  console.log(n)\n}\n// 1\n// 2\n```\n\n### Generator函数的异步操作\n```js\nfunction* asyncJob() {\n  // ...其他代码\n  var f = yield readFile(fileA);\n  // ...其他代码\n}\n```\n函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。\n也就是说，yield命令是异步两个阶段的分界线。\n协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。\n\nGenerator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。  \n整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。\n\n### 异步任务的封装\n```js\nvar fetch = require('node-fetch');\n\nfunction* gen(){\n  var url = 'https://api.github.com/users/github';\n  var result = yield fetch(url);\n  console.log(result.bio);\n}\n\n// Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。\n// 就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。\n\n// 执行上述代码\nvar g = gen();\nvar result = g.next();\n\nresult.value.then(function(data){\n  return data.json();\n}).then(function(data){\n  g.next(data);\n});\n\n// 首先执行 Generator 函数，获取遍历器对象，然后使用next方法（第二行），执行异步任务的第一阶段。\n// 由于Fetch模块返回的是一个 Promise 对象，因此要用then方法调用下一个next方法。\n```\n虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。\n\n\n## async 函数\n学习指导：[阮一峰ES6 -- async函数](http://es6.ruanyifeng.com/#docs/async)\n\n### 含义\n* async 函数是什么？一句话，它就是 Generator 函数的语法糖\n\n```javascript\n// generator 函数依次读取两个文件\nconst fs = require('fs');\nconst readFile = function (fileName) {\n  return new Promise(function (resolve, reject) {\n    fs.readFile(fileName, function(error, data) {\n      if (error) return reject(error);\n      resolve(data);\n    });\n  });\n};\nconst gen = function* () {\n  const f1 = yield readFile('/etc/fstab');\n  const f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n\n// async函数，就是下面这样\nconst asyncReadFile = async function () {\n  const f1 = await readFile('/etc/fstab');\n  const f2 = await readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n\n// async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。\n```\n\n* async函数对 Generator 函数的改进，体现在以下四点：\n   * **内置执行器** —— Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。\n   * **更好的语义** —— async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。\n   * **更广的适用性** —— co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\n   * **返回值是 Promise** —— async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。**进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。**  \n\n### 基本用法\nasync函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\n\n* 引入demo\n\n```javascript\n/* async 表示异步调用 返回一个Promise对象 */\nasync function timeout(ms) {\n    await new Promise((resolve) => {\n      setTimeout(resolve, ms);\n    });\n}  /* 与下边等价*/\n\n// function timeout(ms) {\n//     return new Promise((resolve) => {\n//       setTimeout(resolve, ms);\n//     });\n// }\n\nasync function asyncPrint(value, ms) {\n    await timeout(ms);\n    console.log(value);\n}\n\nasyncPrint('hello world', 3000)  // 3000毫秒以后，输出hello world\n```\n\n* async的表达方式\n\n```javascript\n\n// 函数声明\nasync function foo() {}\n\n// 函数表达式\nconst foo = async function () {};\n\n// 对象的方法\nlet obj = { async foo() {} };\nobj.foo().then(...)\n\n// Class 的方法\nclass Storage {\n  constructor() {\n    this.cachePromise = caches.open('avatars');\n  }\n\n  async getAvatar(name) {\n    const cache = await this.cachePromise;\n    return cache.match(`/avatars/${name}.jpg`);\n  }\n}\n\nconst storage = new Storage();\nstorage.getAvatar('jake').then(…);\n\n// 箭头函数\nconst foo = async () => {};\n```\n\n### async 的语法\n* 返回Promise 对象\n   * async函数返回一个 Promise 对象。\n   * async函数内部return语句返回的值，会成为then方法回调函数的参数。\n\n    ```javascript\n    async function f() {\n      return 'hello world';\n    }\n\n    f().then(v => console.log(v))\n    // \"hello world\"\n    // 函数 f 内部return命令返回的值，会被then方法回调函数接收到。\n    ```\n\n* async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。\n\n```javascript\nasync function f() {\n  throw new Error('出错了');\n}\n\nf().then(\n  v => console.log(v),\n  e => console.log(e)\n)\n// Error: 出错了\n```\n\n* Promise 对象的状态变化\n   * async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。\n   * 也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。\n\n    ```javascript\n    async function getTitle(url) {\n      let response = await fetch(url);\n      let html = await response.text();\n      return html.match(/<title>([\\s\\S]+)<\\/title>/i)[1];\n    }\n    getTitle('https://tc39.github.io/ecma262/').then(console.log)\n    // \"ECMAScript 2017 Language Specification\"\n\n    // 函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。\n    // 只有这三个操作全部完成，才会执行then方法里面的 console.log。\n    ```\n\n* await 命令\n   * 正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。\n\n    ```javascript\n    async function f() {\n      return await 123;\n    }\n\n    f().then(v => console.log(v))\n    // 123\n\n    // await命令的参数是数值123，它被转成 Promise 对象，并立即resolve\n    ```\n\n   * await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。\n\n    ```javascript\n    async function f() {\n      await Promise.reject('出错了');\n    }\n\n    f()\n    .then(v => console.log(v))\n    .catch(e => console.log(e))\n    // 出错了\n\n    // await 语句前面没有 return，但是 reject 方法的参数依然传入了 catch 方法的回调函数。\n    // 这里如果在await前面加上return，效果是一样的。\n    ```\n\n   * 只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行\n\n    ```javascript\n    async function f() {\n      await Promise.reject('出错了');\n      await Promise.resolve('hello world'); // 不会执行\n    }\n    ```\n\n   * 可以将第一个await放在`try...catch`结构里面，这样不管这个异步操作是否成功，第二个await都会执行。\n    \n    ```javascript\n    async function f() {\n      try {\n        await Promise.reject('出错了');\n      } catch(e) {\n      }\n      return await Promise.resolve('hello world');\n    }\n\n    f()\n    .then(v => console.log(v))\n    // hello world\n    ```\n\n   * 另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误\n\n    ```javascript\n    async function f() {\n      await Promise.reject('出错了')\n        .catch(e => console.log(e));\n      return await Promise.resolve('hello world');\n    }\n\n    f()\n    .then(v => console.log(v))\n    // 出错了\n    // hello world\n    ```\n\n### 使用注意点\n* 第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在`try...catch`代码块中。\n* 第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。\n\n```javascript\nlet foo = await getFoo();\nlet bar = await getBar();\n// 上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。\n// 这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。\n\n\n// 写法一\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n// 写法二\nlet fooPromise = getFoo();\nlet barPromise = getBar();\nlet foo = await fooPromise;\nlet bar = await barPromise;\n// getFoo和getBar都是同时触发，这样就会缩短程序的执行时间\n```\n* 第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。\n\n```javascript\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  // 报错\n  docs.forEach(function (doc) {\n    await db.post(doc);\n  });\n}\n// 上面代码会报错，因为await用在普通函数之中了\n\n// 采用for循环\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  for (let doc of docs) {\n    await db.post(doc);\n  }\n}\n\n// 如果确实希望多个请求并发执行，可以使用Promise.all方法。\n// 当三个请求都会resolved时，下面两种写法效果相同。\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = await Promise.all(promises);\n  console.log(results);\n}\n\n// 或者使用下面的写法\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = [];\n  for (let promise of promises) {\n    results.push(await promise);\n  }\n  console.log(results);\n}\n```\n\n### async函数实现原理\n* async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里\n\n```javascript\nasync function fn(args) {\n  // ...\n}\n\n// 等同于\nfunction fn(args) {\n  return spawn(function* () {\n    // ...\n  });\n}\n\n// 所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。\n```\n\n### 场景再现\n* 假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。\n\n```javascript\nasync function chainAnimationsAsync(elem, animations) {\n  let ret = null;  // 变量ret用来保存上一个动画的返回值\n  try {\n    for(let anim of animations) {\n      ret = await anim(elem);\n    }\n  } catch(e) {\n    /* 忽略错误，继续执行 */\n  }\n  return ret;\n}\n```\n\n* 依次远程读取一组 URL，然后按照读取的顺序输出结果。\n\n```javascript\n// 远程操作继发.只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间\nasync function logInOrder(urls) {\n  for (const url of urls) {\n    const response = await fetch(url);\n    console.log(await response.text());\n  }\n}\n\n// 并发发出远程请求\nasync function logInOrder(urls) {\n  // 并发读取远程URL\n  const textPromises = urls.map(async url => {\n    const response = await fetch(url);\n    return response.text();\n  });\n\n  // 按次序输出\n  for (const textPromise of textPromises) {\n    console.log(await textPromise);\n  }\n}\n```","source":"_posts/异步编程.md","raw":"---\ntitle: JavaScript中的异步编程解决方案\ndate: 2021-03-18 17:05:05\ntype: 技术\ntags: JavaScript | ES6\nnote: ES6 诞生以前，异步编程的方法有四种：回调函数、事件监听、发布/订阅、Promise 对象。\n---\n\n## Generator 函数\n学习指导：[阮一峰ES6 -- Generator函数](http://es6.ruanyifeng.com/#docs/generator)\n\n### 基本概念\n* 语法上：Generator 函数是一个状态机，封装了多个内部状态；执行 Generator 函数会返回一个遍历器对象。也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\n* 形式上：Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号`*`；二是，函数体内部使用`yield`表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。\n\n```javascript\nfunction* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n}\nvar hw = helloWorldGenerator();\n\n// 定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world）\n// 即该函数有三个状态：hello，world 和 return 语句（结束执行）。\n```\n\n* 调用Generator函数，返回一个遍历器对象，代表Generator函数的内部指针。以后，每次调用遍历器对象的`next`方法，就会返回一个有着`value和done`两个属性的对象。`value`属性表示当前的内部状态的值，是`yield`表达式后面那个表达式的值；`done`属性是一个布尔值，表示是否遍历结束。\n\n```javascript\n// 上述函数下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。\n// 即每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，\n// 直到遇到下一个yield表达式（或return语句）为止。\n// 换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。\n\nhw.next()\n// { value: 'hello', done: false }\nhw.next()\n// { value: 'world', done: false }\nhw.next()\n// { value: 'ending', done: true }\nhw.next()\n// { value: undefined, done: true }\n\n/*\n解释说明：\n上面代码一共调用了四次next方法。\n第一次调用，Generator 函数开始执行，直到遇到第一个yield表达式为止。\nnext方法返回一个对象，它的value属性就是当前yield表达式的值hello，\ndone属性的值false，表示遍历还没有结束。\n\n第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。\nnext方法返回的对象的value属性就是当前yield表达式的值world，\ndone属性的值false，表示遍历还没有结束。\n\n第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句\n（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，\n就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），\ndone属性的值true，表示遍历已经结束。\n\n第四次调用，此时 Generator 函数已经运行完毕，\nnext方法返回对象的value属性为undefined，done属性为true。\n以后再调用next方法，返回的都是这个值。\n*/\n```\n\n### yield 表达式说明\n* Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。\n* 遍历器对象的next方法的运行逻辑如下。\n   * 遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。\n   * 下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。\n   * 如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。\n   * 如果该函数没有return语句，则返回的对象的 value 属性值为 undefined。\n* 需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。\n\n```javascript\nfunction* gen(){\n  yield 123 + 456;\n}\n\n// yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值.\n```\n\n### yield 表达式语法\n* yield表达式只能用在 Generator 函数里面，用在其他地方都会报错\n\n```javascript\n(function (){\n  yield 1;\n})()\n// SyntaxError: Unexpected number\n```\n\n* yield表达式如果用在另一个表达式之中，必须放在圆括号里面\n\n```javascript\nfunction* demo() {\n  console.log('Hello' + yield); // SyntaxError\n  console.log('Hello' + yield 123); // SyntaxError\n\n  console.log('Hello' + (yield)); // OK\n  console.log('Hello' + (yield 123)); // OK\n}\n```\n\n* yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号\n\n```javascript\nfunction* demo() {\n  foo(yield 'a', yield 'b'); // OK\n  let input = yield; // OK\n}\n```\n\n### 用法实例讲解\n\n```javascript\nvar arr = [1, [[2, 3], 4], [5, 6]];\n\nvar flat = function* (a) {\n  a.forEach(function (item) {\n    if (typeof item !== 'number') {\n      yield* flat(item);\n    } else {\n      yield item;\n    }\n  });\n};  // 错误用法\n// forEach方法的参数是一个普通函数，但是在里面使用了yield表达式\n\n// 一种修改方法是改用for循环。\nvar flat = function* (a) {\n  var length = a.length;\n  for (var i = 0; i < length; i++) {\n    var item = a[i];\n    if (typeof item !== 'number') {\n      yield* flat(item);\n    } else {\n      yield item;\n    }\n  }\n};\n\nfor (var f of flat(arr)) {\n  console.log(f);\n}\n// 1, 2, 3, 4, 5, 6\n```\n\n### yield表达式与return语句\n* yield 表达式与return 语句既有相似之处，也有区别。  \n* 相似之处在于，都能返回紧跟在语句后面的那个表达式的值。  \n* 区别在于每次遇到`yield`，函数暂停执行，下一次再从该位置继续向后执行，而`return`语句不具备位置记忆的功能。 \n* 一个函数里面，**只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式**。  \n* 正常函数只能返回一个值，因为只能执行一次return；  \n* Generator 函数可以返回一系列的值，因为可以有任意多个`yield`。  \n* 从另一个角度看，也可以说 Generator 生成了一系列的值。  \n\n### next 方法的参数\n* `yield`表达式本身没有返回值，或者说总是返回`undefined`。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。\n\n```javascript\nfunction* f() {\n  for(var i = 0; true; i++) {\n    var reset = yield i;\n    if(reset) { i = -1; }\n  }\n}\nvar g = f();\n\ng.next() // { value: 0, done: false }\ng.next() // { value: 1, done: false }\ng.next(true) // { value: 0, done: false }\n\n/*\n上面代码先定义了一个可以无限运行的 Generator 函数f，\n如果next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined。\n\n当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，\n下一轮循环就会从-1开始递增。\n */\n```\n\n* 这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。\n* 通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。  \n\n```js\nfunction* foo(x) {\n  var y = 2 * (yield (x + 1));\n  var z = yield (y / 3);\n  return (x + y + z);\n}\n\nvar a = foo(5);\na.next() // Object{value:6, done:false}\na.next() // Object{value:NaN, done:false}\na.next() // Object{value:NaN, done:true}\n\nvar b = foo(5);\nb.next() // { value:6, done:false }\nb.next(12) // { value:8, done:false }\nb.next(13) // { value:42, done:true }\n\n/*\n上面代码中，第二次运行next方法的时候不带参数，导致 y 的值等于2 * undefined（即NaN），\n除以 3 以后还是NaN，因此返回对象的value属性也等于NaN。\n第三次运行Next方法的时候不带参数，所以z等于undefined，\n返回对象的value属性等于5 + NaN + undefined，即NaN。\n\n如果向next方法提供参数，返回结果就完全不一样了。\n上面代码第一次调用b的next方法时，返回x+1的值6；\n第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；\n第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，\n这时x等于5，y等于24，所以return语句的值等于42。\n*/\n```\n\n\n* 注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。  \n\n### for...of 循环\n* 1) for...of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。  \n\n```javascript\n\nfunction* foo() {\n  yield 1;\n  yield 2;\n  yield 3;\n  yield 4;\n  yield 5;\n  return 6;\n}\nfor (let v of foo()) {\n  console.log(v);\n}\n// 1 2 3 4 5\n\n// 上面代码使用for...of循环，依次显示 5 个yield表达式的值。\n// 这里需要注意，一旦next方法的返回对象的done属性为true，\n// for...of循环就会中止，且不包含该返回对象，\n// 所以上面代码的return语句返回的6，不包括在for...of循环之中。\n```  \n\n* 2)利用`for...of`循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用for...of循环，通过 Generator 函数为它加上这个接口，就可以用了。\n\n```javascript\nfunction* objectEntries(obj) {\n  let propKeys = Reflect.ownKeys(obj);\n\n  for (let propKey of propKeys) {\n    yield [propKey, obj[propKey]];\n  }\n}\n\nlet jane = { first: 'Jane', last: 'Doe' };\n\nfor (let [key, value] of objectEntries(jane)) {\n  console.log(`${key}: ${value}`);\n}\n// first: Jane\n// last: Doe\n```\n\n* 3)加上遍历器接口的另一种写法是，将 Generator 函数加到对象的`Symbol.iterator`属性上面\n\n```javascript\nfunction* objectEntries() {\n  let propKeys = Object.keys(this);\n\n  for (let propKey of propKeys) {\n    yield [propKey, this[propKey]];\n  }\n}\n\nlet jane = { first: 'Jane', last: 'Doe' };\n\njane[Symbol.iterator] = objectEntries;\n\nfor (let [key, value] of jane) {\n  console.log(`${key}: ${value}`);\n}\n// first: Jane\n// last: Doe\n```\n\n* 4)除了for...of循环以外，`扩展运算符（...）`、`解构赋值`和`Array.from`方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。  \n\n```js\nfunction* numbers () {\n  yield 1\n  yield 2\n  return 3\n  yield 4\n}\n\n// 扩展运算符\n[...numbers()] // [1, 2]\n\n// Array.from 方法\nArray.from(numbers()) // [1, 2]\n\n// 解构赋值\nlet [x, y] = numbers();\nx // 1\ny // 2\n\n// for...of 循环\nfor (let n of numbers()) {\n  console.log(n)\n}\n// 1\n// 2\n```\n\n### Generator函数的异步操作\n```js\nfunction* asyncJob() {\n  // ...其他代码\n  var f = yield readFile(fileA);\n  // ...其他代码\n}\n```\n函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。\n也就是说，yield命令是异步两个阶段的分界线。\n协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。\n\nGenerator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。  \n整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。\n\n### 异步任务的封装\n```js\nvar fetch = require('node-fetch');\n\nfunction* gen(){\n  var url = 'https://api.github.com/users/github';\n  var result = yield fetch(url);\n  console.log(result.bio);\n}\n\n// Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。\n// 就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。\n\n// 执行上述代码\nvar g = gen();\nvar result = g.next();\n\nresult.value.then(function(data){\n  return data.json();\n}).then(function(data){\n  g.next(data);\n});\n\n// 首先执行 Generator 函数，获取遍历器对象，然后使用next方法（第二行），执行异步任务的第一阶段。\n// 由于Fetch模块返回的是一个 Promise 对象，因此要用then方法调用下一个next方法。\n```\n虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。\n\n\n## async 函数\n学习指导：[阮一峰ES6 -- async函数](http://es6.ruanyifeng.com/#docs/async)\n\n### 含义\n* async 函数是什么？一句话，它就是 Generator 函数的语法糖\n\n```javascript\n// generator 函数依次读取两个文件\nconst fs = require('fs');\nconst readFile = function (fileName) {\n  return new Promise(function (resolve, reject) {\n    fs.readFile(fileName, function(error, data) {\n      if (error) return reject(error);\n      resolve(data);\n    });\n  });\n};\nconst gen = function* () {\n  const f1 = yield readFile('/etc/fstab');\n  const f2 = yield readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n\n// async函数，就是下面这样\nconst asyncReadFile = async function () {\n  const f1 = await readFile('/etc/fstab');\n  const f2 = await readFile('/etc/shells');\n  console.log(f1.toString());\n  console.log(f2.toString());\n};\n\n// async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。\n```\n\n* async函数对 Generator 函数的改进，体现在以下四点：\n   * **内置执行器** —— Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。\n   * **更好的语义** —— async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。\n   * **更广的适用性** —— co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。\n   * **返回值是 Promise** —— async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。**进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。**  \n\n### 基本用法\nasync函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\n\n* 引入demo\n\n```javascript\n/* async 表示异步调用 返回一个Promise对象 */\nasync function timeout(ms) {\n    await new Promise((resolve) => {\n      setTimeout(resolve, ms);\n    });\n}  /* 与下边等价*/\n\n// function timeout(ms) {\n//     return new Promise((resolve) => {\n//       setTimeout(resolve, ms);\n//     });\n// }\n\nasync function asyncPrint(value, ms) {\n    await timeout(ms);\n    console.log(value);\n}\n\nasyncPrint('hello world', 3000)  // 3000毫秒以后，输出hello world\n```\n\n* async的表达方式\n\n```javascript\n\n// 函数声明\nasync function foo() {}\n\n// 函数表达式\nconst foo = async function () {};\n\n// 对象的方法\nlet obj = { async foo() {} };\nobj.foo().then(...)\n\n// Class 的方法\nclass Storage {\n  constructor() {\n    this.cachePromise = caches.open('avatars');\n  }\n\n  async getAvatar(name) {\n    const cache = await this.cachePromise;\n    return cache.match(`/avatars/${name}.jpg`);\n  }\n}\n\nconst storage = new Storage();\nstorage.getAvatar('jake').then(…);\n\n// 箭头函数\nconst foo = async () => {};\n```\n\n### async 的语法\n* 返回Promise 对象\n   * async函数返回一个 Promise 对象。\n   * async函数内部return语句返回的值，会成为then方法回调函数的参数。\n\n    ```javascript\n    async function f() {\n      return 'hello world';\n    }\n\n    f().then(v => console.log(v))\n    // \"hello world\"\n    // 函数 f 内部return命令返回的值，会被then方法回调函数接收到。\n    ```\n\n* async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。\n\n```javascript\nasync function f() {\n  throw new Error('出错了');\n}\n\nf().then(\n  v => console.log(v),\n  e => console.log(e)\n)\n// Error: 出错了\n```\n\n* Promise 对象的状态变化\n   * async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。\n   * 也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。\n\n    ```javascript\n    async function getTitle(url) {\n      let response = await fetch(url);\n      let html = await response.text();\n      return html.match(/<title>([\\s\\S]+)<\\/title>/i)[1];\n    }\n    getTitle('https://tc39.github.io/ecma262/').then(console.log)\n    // \"ECMAScript 2017 Language Specification\"\n\n    // 函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。\n    // 只有这三个操作全部完成，才会执行then方法里面的 console.log。\n    ```\n\n* await 命令\n   * 正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。\n\n    ```javascript\n    async function f() {\n      return await 123;\n    }\n\n    f().then(v => console.log(v))\n    // 123\n\n    // await命令的参数是数值123，它被转成 Promise 对象，并立即resolve\n    ```\n\n   * await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。\n\n    ```javascript\n    async function f() {\n      await Promise.reject('出错了');\n    }\n\n    f()\n    .then(v => console.log(v))\n    .catch(e => console.log(e))\n    // 出错了\n\n    // await 语句前面没有 return，但是 reject 方法的参数依然传入了 catch 方法的回调函数。\n    // 这里如果在await前面加上return，效果是一样的。\n    ```\n\n   * 只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行\n\n    ```javascript\n    async function f() {\n      await Promise.reject('出错了');\n      await Promise.resolve('hello world'); // 不会执行\n    }\n    ```\n\n   * 可以将第一个await放在`try...catch`结构里面，这样不管这个异步操作是否成功，第二个await都会执行。\n    \n    ```javascript\n    async function f() {\n      try {\n        await Promise.reject('出错了');\n      } catch(e) {\n      }\n      return await Promise.resolve('hello world');\n    }\n\n    f()\n    .then(v => console.log(v))\n    // hello world\n    ```\n\n   * 另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误\n\n    ```javascript\n    async function f() {\n      await Promise.reject('出错了')\n        .catch(e => console.log(e));\n      return await Promise.resolve('hello world');\n    }\n\n    f()\n    .then(v => console.log(v))\n    // 出错了\n    // hello world\n    ```\n\n### 使用注意点\n* 第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在`try...catch`代码块中。\n* 第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。\n\n```javascript\nlet foo = await getFoo();\nlet bar = await getBar();\n// 上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。\n// 这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。\n\n\n// 写法一\nlet [foo, bar] = await Promise.all([getFoo(), getBar()]);\n// 写法二\nlet fooPromise = getFoo();\nlet barPromise = getBar();\nlet foo = await fooPromise;\nlet bar = await barPromise;\n// getFoo和getBar都是同时触发，这样就会缩短程序的执行时间\n```\n* 第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。\n\n```javascript\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  // 报错\n  docs.forEach(function (doc) {\n    await db.post(doc);\n  });\n}\n// 上面代码会报错，因为await用在普通函数之中了\n\n// 采用for循环\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n\n  for (let doc of docs) {\n    await db.post(doc);\n  }\n}\n\n// 如果确实希望多个请求并发执行，可以使用Promise.all方法。\n// 当三个请求都会resolved时，下面两种写法效果相同。\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = await Promise.all(promises);\n  console.log(results);\n}\n\n// 或者使用下面的写法\nasync function dbFuc(db) {\n  let docs = [{}, {}, {}];\n  let promises = docs.map((doc) => db.post(doc));\n\n  let results = [];\n  for (let promise of promises) {\n    results.push(await promise);\n  }\n  console.log(results);\n}\n```\n\n### async函数实现原理\n* async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里\n\n```javascript\nasync function fn(args) {\n  // ...\n}\n\n// 等同于\nfunction fn(args) {\n  return spawn(function* () {\n    // ...\n  });\n}\n\n// 所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。\n```\n\n### 场景再现\n* 假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。\n\n```javascript\nasync function chainAnimationsAsync(elem, animations) {\n  let ret = null;  // 变量ret用来保存上一个动画的返回值\n  try {\n    for(let anim of animations) {\n      ret = await anim(elem);\n    }\n  } catch(e) {\n    /* 忽略错误，继续执行 */\n  }\n  return ret;\n}\n```\n\n* 依次远程读取一组 URL，然后按照读取的顺序输出结果。\n\n```javascript\n// 远程操作继发.只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间\nasync function logInOrder(urls) {\n  for (const url of urls) {\n    const response = await fetch(url);\n    console.log(await response.text());\n  }\n}\n\n// 并发发出远程请求\nasync function logInOrder(urls) {\n  // 并发读取远程URL\n  const textPromises = urls.map(async url => {\n    const response = await fetch(url);\n    return response.text();\n  });\n\n  // 按次序输出\n  for (const textPromise of textPromises) {\n    console.log(await textPromise);\n  }\n}\n```","slug":"异步编程","published":1,"updated":"2021-07-19T05:53:56.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckrd8jv1h000okwzt4zmq1mlu","content":"<h2 id=\"Generator-函数\"><a href=\"#Generator-函数\" class=\"headerlink\" title=\"Generator 函数\"></a>Generator 函数</h2><p>学习指导：<a href=\"http://es6.ruanyifeng.com/#docs/generator\">阮一峰ES6 – Generator函数</a></p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li>语法上：Generator 函数是一个状态机，封装了多个内部状态；执行 Generator 函数会返回一个遍历器对象。也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</li>\n<li>形式上：Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号<code>*</code>；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">helloWorldGenerator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">&#x27;world&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;ending&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> hw = helloWorldGenerator();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world）</span></span><br><span class=\"line\"><span class=\"comment\">// 即该函数有三个状态：hello，world 和 return 语句（结束执行）。</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>调用Generator函数，返回一个遍历器对象，代表Generator函数的内部指针。以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value和done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 上述函数下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。</span></span><br><span class=\"line\"><span class=\"comment\">// 即每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，</span></span><br><span class=\"line\"><span class=\"comment\">// 直到遇到下一个yield表达式（或return语句）为止。</span></span><br><span class=\"line\"><span class=\"comment\">// 换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。</span></span><br><span class=\"line\"></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">解释说明：</span></span><br><span class=\"line\"><span class=\"comment\">上面代码一共调用了四次next方法。</span></span><br><span class=\"line\"><span class=\"comment\">第一次调用，Generator 函数开始执行，直到遇到第一个yield表达式为止。</span></span><br><span class=\"line\"><span class=\"comment\">next方法返回一个对象，它的value属性就是当前yield表达式的值hello，</span></span><br><span class=\"line\"><span class=\"comment\">done属性的值false，表示遍历还没有结束。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。</span></span><br><span class=\"line\"><span class=\"comment\">next方法返回的对象的value属性就是当前yield表达式的值world，</span></span><br><span class=\"line\"><span class=\"comment\">done属性的值false，表示遍历还没有结束。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句</span></span><br><span class=\"line\"><span class=\"comment\">（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，</span></span><br><span class=\"line\"><span class=\"comment\">就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），</span></span><br><span class=\"line\"><span class=\"comment\">done属性的值true，表示遍历已经结束。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">第四次调用，此时 Generator 函数已经运行完毕，</span></span><br><span class=\"line\"><span class=\"comment\">next方法返回对象的value属性为undefined，done属性为true。</span></span><br><span class=\"line\"><span class=\"comment\">以后再调用next方法，返回的都是这个值。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"yield-表达式说明\"><a href=\"#yield-表达式说明\" class=\"headerlink\" title=\"yield 表达式说明\"></a>yield 表达式说明</h3><ul>\n<li>Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。</li>\n<li>遍历器对象的next方法的运行逻辑如下。<ul>\n<li>遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</li>\n<li>下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。</li>\n<li>如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</li>\n<li>如果该函数没有return语句，则返回的对象的 value 属性值为 undefined。</li>\n</ul>\n</li>\n<li>需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">123</span> + <span class=\"number\">456</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值.</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"yield-表达式语法\"><a href=\"#yield-表达式语法\" class=\"headerlink\" title=\"yield 表达式语法\"></a>yield 表达式语法</h3><ul>\n<li>yield表达式只能用在 Generator 函数里面，用在其他地方都会报错</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"><span class=\"comment\">// SyntaxError: Unexpected number</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>yield表达式如果用在另一个表达式之中，必须放在圆括号里面</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">demo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Hello&#x27;</span> + <span class=\"keyword\">yield</span>); <span class=\"comment\">// SyntaxError</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Hello&#x27;</span> + <span class=\"keyword\">yield</span> <span class=\"number\">123</span>); <span class=\"comment\">// SyntaxError</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Hello&#x27;</span> + (<span class=\"keyword\">yield</span>)); <span class=\"comment\">// OK</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Hello&#x27;</span> + (<span class=\"keyword\">yield</span> <span class=\"number\">123</span>)); <span class=\"comment\">// OK</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">demo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  foo(<span class=\"keyword\">yield</span> <span class=\"string\">&#x27;a&#x27;</span>, <span class=\"keyword\">yield</span> <span class=\"string\">&#x27;b&#x27;</span>); <span class=\"comment\">// OK</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> input = <span class=\"keyword\">yield</span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"用法实例讲解\"><a href=\"#用法实例讲解\" class=\"headerlink\" title=\"用法实例讲解\"></a>用法实例讲解</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, [[<span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"number\">4</span>], [<span class=\"number\">5</span>, <span class=\"number\">6</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> flat = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">  a.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> item !== <span class=\"string\">&#x27;number&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">yield</span>* flat(item);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">yield</span> item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;  <span class=\"comment\">// 错误用法</span></span><br><span class=\"line\"><span class=\"comment\">// forEach方法的参数是一个普通函数，但是在里面使用了yield表达式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一种修改方法是改用for循环。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> flat = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> length = a.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> item = a[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> item !== <span class=\"string\">&#x27;number&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">yield</span>* flat(item);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">yield</span> item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> f <span class=\"keyword\">of</span> flat(arr)) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1, 2, 3, 4, 5, 6</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"yield表达式与return语句\"><a href=\"#yield表达式与return语句\" class=\"headerlink\" title=\"yield表达式与return语句\"></a>yield表达式与return语句</h3><ul>\n<li>yield 表达式与return 语句既有相似之处，也有区别。  </li>\n<li>相似之处在于，都能返回紧跟在语句后面的那个表达式的值。  </li>\n<li>区别在于每次遇到<code>yield</code>，函数暂停执行，下一次再从该位置继续向后执行，而<code>return</code>语句不具备位置记忆的功能。 </li>\n<li>一个函数里面，<strong>只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式</strong>。  </li>\n<li>正常函数只能返回一个值，因为只能执行一次return；  </li>\n<li>Generator 函数可以返回一系列的值，因为可以有任意多个<code>yield</code>。  </li>\n<li>从另一个角度看，也可以说 Generator 生成了一系列的值。  </li>\n</ul>\n<h3 id=\"next-方法的参数\"><a href=\"#next-方法的参数\" class=\"headerlink\" title=\"next 方法的参数\"></a>next 方法的参数</h3><ul>\n<li><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; <span class=\"literal\">true</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> reset = <span class=\"keyword\">yield</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(reset) &#123; i = -<span class=\"number\">1</span>; &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> g = f();</span><br><span class=\"line\"></span><br><span class=\"line\">g.next() <span class=\"comment\">// &#123; value: 0, done: false &#125;</span></span><br><span class=\"line\">g.next() <span class=\"comment\">// &#123; value: 1, done: false &#125;</span></span><br><span class=\"line\">g.next(<span class=\"literal\">true</span>) <span class=\"comment\">// &#123; value: 0, done: false &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">上面代码先定义了一个可以无限运行的 Generator 函数f，</span></span><br><span class=\"line\"><span class=\"comment\">如果next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，</span></span><br><span class=\"line\"><span class=\"comment\">下一轮循环就会从-1开始递增。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。</li>\n<li>通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。  </li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">foo</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> y = <span class=\"number\">2</span> * (<span class=\"keyword\">yield</span> (x + <span class=\"number\">1</span>));</span><br><span class=\"line\">  <span class=\"keyword\">var</span> z = <span class=\"keyword\">yield</span> (y / <span class=\"number\">3</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (x + y + z);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = foo(<span class=\"number\">5</span>);</span><br><span class=\"line\">a.next() <span class=\"comment\">// Object&#123;value:6, done:false&#125;</span></span><br><span class=\"line\">a.next() <span class=\"comment\">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class=\"line\">a.next() <span class=\"comment\">// Object&#123;value:NaN, done:true&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = foo(<span class=\"number\">5</span>);</span><br><span class=\"line\">b.next() <span class=\"comment\">// &#123; value:6, done:false &#125;</span></span><br><span class=\"line\">b.next(<span class=\"number\">12</span>) <span class=\"comment\">// &#123; value:8, done:false &#125;</span></span><br><span class=\"line\">b.next(<span class=\"number\">13</span>) <span class=\"comment\">// &#123; value:42, done:true &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">上面代码中，第二次运行next方法的时候不带参数，导致 y 的值等于2 * undefined（即NaN），</span></span><br><span class=\"line\"><span class=\"comment\">除以 3 以后还是NaN，因此返回对象的value属性也等于NaN。</span></span><br><span class=\"line\"><span class=\"comment\">第三次运行Next方法的时候不带参数，所以z等于undefined，</span></span><br><span class=\"line\"><span class=\"comment\">返回对象的value属性等于5 + NaN + undefined，即NaN。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">如果向next方法提供参数，返回结果就完全不一样了。</span></span><br><span class=\"line\"><span class=\"comment\">上面代码第一次调用b的next方法时，返回x+1的值6；</span></span><br><span class=\"line\"><span class=\"comment\">第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；</span></span><br><span class=\"line\"><span class=\"comment\">第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，</span></span><br><span class=\"line\"><span class=\"comment\">这时x等于5，y等于24，所以return语句的值等于42。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。  </li>\n</ul>\n<h3 id=\"for…of-循环\"><a href=\"#for…of-循环\" class=\"headerlink\" title=\"for…of 循环\"></a>for…of 循环</h3><ul>\n<li><ol>\n<li>for…of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。  </li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">6</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v <span class=\"keyword\">of</span> foo()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1 2 3 4 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上面代码使用for...of循环，依次显示 5 个yield表达式的值。</span></span><br><span class=\"line\"><span class=\"comment\">// 这里需要注意，一旦next方法的返回对象的done属性为true，</span></span><br><span class=\"line\"><span class=\"comment\">// for...of循环就会中止，且不包含该返回对象，</span></span><br><span class=\"line\"><span class=\"comment\">// 所以上面代码的return语句返回的6，不包括在for...of循环之中。</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* 2)利用`</span><span class=\"keyword\">for</span>...of<span class=\"string\">`循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用for...of循环，通过 Generator 函数为它加上这个接口，就可以用了。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">objectEntries</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> propKeys = <span class=\"built_in\">Reflect</span>.ownKeys(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> propKey <span class=\"keyword\">of</span> propKeys) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> [propKey, obj[propKey]];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> jane = &#123; <span class=\"attr\">first</span>: <span class=\"string\">&#x27;Jane&#x27;</span>, <span class=\"attr\">last</span>: <span class=\"string\">&#x27;Doe&#x27;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> objectEntries(jane)) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>: <span class=\"subst\">$&#123;value&#125;</span>`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// first: Jane</span></span><br><span class=\"line\"><span class=\"comment\">// last: Doe</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>3)加上遍历器接口的另一种写法是，将 Generator 函数加到对象的<code>Symbol.iterator</code>属性上面</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">objectEntries</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> propKeys = <span class=\"built_in\">Object</span>.keys(<span class=\"built_in\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> propKey <span class=\"keyword\">of</span> propKeys) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> [propKey, <span class=\"built_in\">this</span>[propKey]];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> jane = &#123; <span class=\"attr\">first</span>: <span class=\"string\">&#x27;Jane&#x27;</span>, <span class=\"attr\">last</span>: <span class=\"string\">&#x27;Doe&#x27;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">jane[<span class=\"built_in\">Symbol</span>.iterator] = objectEntries;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> jane) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>: <span class=\"subst\">$&#123;value&#125;</span>`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// first: Jane</span></span><br><span class=\"line\"><span class=\"comment\">// last: Doe</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>4)除了for…of循环以外，<code>扩展运算符（...）</code>、<code>解构赋值</code>和<code>Array.from</code>方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。  </li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">numbers</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">3</span></span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">4</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 扩展运算符</span></span><br><span class=\"line\">[...numbers()] <span class=\"comment\">// [1, 2]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Array.from 方法</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(numbers()) <span class=\"comment\">// [1, 2]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解构赋值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, y] = numbers();</span><br><span class=\"line\">x <span class=\"comment\">// 1</span></span><br><span class=\"line\">y <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// for...of 循环</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> n <span class=\"keyword\">of</span> numbers()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(n)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Generator函数的异步操作\"><a href=\"#Generator函数的异步操作\" class=\"headerlink\" title=\"Generator函数的异步操作\"></a>Generator函数的异步操作</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">asyncJob</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...其他代码</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> f = <span class=\"keyword\">yield</span> readFile(fileA);</span><br><span class=\"line\">  <span class=\"comment\">// ...其他代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。<br>也就是说，yield命令是异步两个阶段的分界线。<br>协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p>\n<p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。<br>整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。</p>\n<h3 id=\"异步任务的封装\"><a href=\"#异步任务的封装\" class=\"headerlink\" title=\"异步任务的封装\"></a>异步任务的封装</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fetch = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;node-fetch&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> url = <span class=\"string\">&#x27;https://api.github.com/users/github&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">yield</span> fetch(url);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result.bio);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。</span></span><br><span class=\"line\"><span class=\"comment\">// 就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行上述代码</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = gen();</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = g.next();</span><br><span class=\"line\"></span><br><span class=\"line\">result.value.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> data.json();</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">  g.next(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 首先执行 Generator 函数，获取遍历器对象，然后使用next方法（第二行），执行异步任务的第一阶段。</span></span><br><span class=\"line\"><span class=\"comment\">// 由于Fetch模块返回的是一个 Promise 对象，因此要用then方法调用下一个next方法。</span></span><br></pre></td></tr></table></figure>\n<p>虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p>\n<h2 id=\"async-函数\"><a href=\"#async-函数\" class=\"headerlink\" title=\"async 函数\"></a>async 函数</h2><p>学习指导：<a href=\"http://es6.ruanyifeng.com/#docs/async\">阮一峰ES6 – async函数</a></p>\n<h3 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h3><ul>\n<li>async 函数是什么？一句话，它就是 Generator 函数的语法糖</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// generator 函数依次读取两个文件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> readFile = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fileName</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    fs.readFile(fileName, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, data</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (error) <span class=\"keyword\">return</span> reject(error);</span><br><span class=\"line\">      resolve(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f1 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">&#x27;/etc/fstab&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f2 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">&#x27;/etc/shells&#x27;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// async函数，就是下面这样</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> asyncReadFile = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f1 = <span class=\"keyword\">await</span> readFile(<span class=\"string\">&#x27;/etc/fstab&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f2 = <span class=\"keyword\">await</span> readFile(<span class=\"string\">&#x27;/etc/shells&#x27;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>async函数对 Generator 函数的改进，体现在以下四点：<ul>\n<li><strong>内置执行器</strong> —— Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</li>\n<li><strong>更好的语义</strong> —— async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</li>\n<li><strong>更广的适用性</strong> —— co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</li>\n<li><strong>返回值是 Promise</strong> —— async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。<strong>进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</strong>  </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>\n<ul>\n<li>引入demo</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* async 表示异步调用 返回一个Promise对象 */</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(resolve, ms);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;  <span class=\"comment\">/* 与下边等价*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// function timeout(ms) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     return new Promise((resolve) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//       setTimeout(resolve, ms);</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;);</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncPrint</span>(<span class=\"params\">value, ms</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> timeout(ms);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncPrint(<span class=\"string\">&#x27;hello world&#x27;</span>, <span class=\"number\">3000</span>)  <span class=\"comment\">// 3000毫秒以后，输出hello world</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>async的表达方式</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象的方法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">foo</span>(<span class=\"params\"></span>)</span> &#123;&#125; &#125;;</span><br><span class=\"line\">obj.foo().then(...)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Class 的方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Storage</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.cachePromise = caches.open(<span class=\"string\">&#x27;avatars&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">getAvatar</span>(<span class=\"params\">name</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cache = <span class=\"keyword\">await</span> <span class=\"built_in\">this</span>.cachePromise;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cache.match(<span class=\"string\">`/avatars/<span class=\"subst\">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> storage = <span class=\"keyword\">new</span> Storage();</span><br><span class=\"line\">storage.getAvatar(<span class=\"string\">&#x27;jake&#x27;</span>).then(…);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 箭头函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"keyword\">async</span> () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"async-的语法\"><a href=\"#async-的语法\" class=\"headerlink\" title=\"async 的语法\"></a>async 的语法</h3><ul>\n<li><p>返回Promise 对象</p>\n<ul>\n<li>async函数返回一个 Promise 对象。</li>\n<li>async函数内部return语句返回的值，会成为then方法回调函数的参数。</li>\n</ul>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello world&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// &quot;hello world&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 函数 f 内部return命令返回的值，会被then方法回调函数接收到。</span></span><br></pre></td></tr></table></figure></li>\n<li><p>async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;出错了&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(</span><br><span class=\"line\">  <span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v),</span><br><span class=\"line\">  <span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// Error: 出错了</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>Promise 对象的状态变化</p>\n<ul>\n<li>async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。</li>\n<li>也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</li>\n</ul>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTitle</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> response = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> html = <span class=\"keyword\">await</span> response.text();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> html.match(<span class=\"regexp\">/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i</span>)[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getTitle(<span class=\"string\">&#x27;https://tc39.github.io/ecma262/&#x27;</span>).then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\"><span class=\"comment\">// &quot;ECMAScript 2017 Language Specification&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。</span></span><br><span class=\"line\"><span class=\"comment\">// 只有这三个操作全部完成，才会执行then方法里面的 console.log。</span></span><br></pre></td></tr></table></figure></li>\n<li><p>await 命令</p>\n<ul>\n<li>正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。</li>\n</ul>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// 123</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// await命令的参数是数值123，它被转成 Promise 对象，并立即resolve</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。</li>\n</ul>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">&#x27;出错了&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(e))</span><br><span class=\"line\"><span class=\"comment\">// 出错了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// await 语句前面没有 return，但是 reject 方法的参数依然传入了 catch 方法的回调函数。</span></span><br><span class=\"line\"><span class=\"comment\">// 这里如果在await前面加上return，效果是一样的。</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行</li>\n</ul>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">&#x27;出错了&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">&#x27;hello world&#x27;</span>); <span class=\"comment\">// 不会执行</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以将第一个await放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个await都会执行。</li>\n</ul>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">&#x27;出错了&#x27;</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">&#x27;hello world&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// hello world</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误</li>\n</ul>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">&#x27;出错了&#x27;</span>)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(e));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">&#x27;hello world&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// 出错了</span></span><br><span class=\"line\"><span class=\"comment\">// hello world</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"使用注意点\"><a href=\"#使用注意点\" class=\"headerlink\" title=\"使用注意点\"></a>使用注意点</h3><ul>\n<li>第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在<code>try...catch</code>代码块中。</li>\n<li>第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"keyword\">await</span> getFoo();</span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"keyword\">await</span> getBar();</span><br><span class=\"line\"><span class=\"comment\">// 上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。</span></span><br><span class=\"line\"><span class=\"comment\">// 这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法一</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [foo, bar] = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all([getFoo(), getBar()]);</span><br><span class=\"line\"><span class=\"comment\">// 写法二</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fooPromise = getFoo();</span><br><span class=\"line\"><span class=\"keyword\">let</span> barPromise = getBar();</span><br><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"keyword\">await</span> fooPromise;</span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"keyword\">await</span> barPromise;</span><br><span class=\"line\"><span class=\"comment\">// getFoo和getBar都是同时触发，这样就会缩短程序的执行时间</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 报错</span></span><br><span class=\"line\">  docs.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">doc</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.post(doc);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 上面代码会报错，因为await用在普通函数之中了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 采用for循环</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> doc <span class=\"keyword\">of</span> docs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.post(doc);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果确实希望多个请求并发执行，可以使用Promise.all方法。</span></span><br><span class=\"line\"><span class=\"comment\">// 当三个请求都会resolved时，下面两种写法效果相同。</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promises = docs.map(<span class=\"function\">(<span class=\"params\">doc</span>) =&gt;</span> db.post(doc));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> results = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all(promises);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(results);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者使用下面的写法</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promises = docs.map(<span class=\"function\">(<span class=\"params\">doc</span>) =&gt;</span> db.post(doc));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> results = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> promise <span class=\"keyword\">of</span> promises) &#123;</span><br><span class=\"line\">    results.push(<span class=\"keyword\">await</span> promise);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(results);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"async函数实现原理\"><a href=\"#async函数实现原理\" class=\"headerlink\" title=\"async函数实现原理\"></a>async函数实现原理</h3><ul>\n<li>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> spawn(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"场景再现\"><a href=\"#场景再现\" class=\"headerlink\" title=\"场景再现\"></a>场景再现</h3><ul>\n<li>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">chainAnimationsAsync</span>(<span class=\"params\">elem, animations</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ret = <span class=\"literal\">null</span>;  <span class=\"comment\">// 变量ret用来保存上一个动画的返回值</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> anim <span class=\"keyword\">of</span> animations) &#123;</span><br><span class=\"line\">      ret = <span class=\"keyword\">await</span> anim(elem);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 忽略错误，继续执行 */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>依次远程读取一组 URL，然后按照读取的顺序输出结果。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 远程操作继发.只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logInOrder</span>(<span class=\"params\">urls</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> url <span class=\"keyword\">of</span> urls) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> response.text());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 并发发出远程请求</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logInOrder</span>(<span class=\"params\">urls</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 并发读取远程URL</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> textPromises = urls.map(<span class=\"keyword\">async</span> url =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.text();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 按次序输出</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> textPromise <span class=\"keyword\">of</span> textPromises) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> textPromise);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"Generator-函数\"><a href=\"#Generator-函数\" class=\"headerlink\" title=\"Generator 函数\"></a>Generator 函数</h2><p>学习指导：<a href=\"http://es6.ruanyifeng.com/#docs/generator\">阮一峰ES6 – Generator函数</a></p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><ul>\n<li>语法上：Generator 函数是一个状态机，封装了多个内部状态；执行 Generator 函数会返回一个遍历器对象。也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</li>\n<li>形式上：Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号<code>*</code>；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">helloWorldGenerator</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">&#x27;hello&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"string\">&#x27;world&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;ending&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> hw = helloWorldGenerator();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义了一个 Generator 函数helloWorldGenerator，它内部有两个yield表达式（hello和world）</span></span><br><span class=\"line\"><span class=\"comment\">// 即该函数有三个状态：hello，world 和 return 语句（结束执行）。</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>调用Generator函数，返回一个遍历器对象，代表Generator函数的内部指针。以后，每次调用遍历器对象的<code>next</code>方法，就会返回一个有着<code>value和done</code>两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是<code>yield</code>表达式后面那个表达式的值；<code>done</code>属性是一个布尔值，表示是否遍历结束。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 上述函数下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。</span></span><br><span class=\"line\"><span class=\"comment\">// 即每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，</span></span><br><span class=\"line\"><span class=\"comment\">// 直到遇到下一个yield表达式（或return语句）为止。</span></span><br><span class=\"line\"><span class=\"comment\">// 换言之，Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行。</span></span><br><span class=\"line\"></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: &#x27;hello&#x27;, done: false &#125;</span></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: &#x27;world&#x27;, done: false &#125;</span></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: &#x27;ending&#x27;, done: true &#125;</span></span><br><span class=\"line\">hw.next()</span><br><span class=\"line\"><span class=\"comment\">// &#123; value: undefined, done: true &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">解释说明：</span></span><br><span class=\"line\"><span class=\"comment\">上面代码一共调用了四次next方法。</span></span><br><span class=\"line\"><span class=\"comment\">第一次调用，Generator 函数开始执行，直到遇到第一个yield表达式为止。</span></span><br><span class=\"line\"><span class=\"comment\">next方法返回一个对象，它的value属性就是当前yield表达式的值hello，</span></span><br><span class=\"line\"><span class=\"comment\">done属性的值false，表示遍历还没有结束。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">第二次调用，Generator 函数从上次yield表达式停下的地方，一直执行到下一个yield表达式。</span></span><br><span class=\"line\"><span class=\"comment\">next方法返回的对象的value属性就是当前yield表达式的值world，</span></span><br><span class=\"line\"><span class=\"comment\">done属性的值false，表示遍历还没有结束。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">第三次调用，Generator 函数从上次yield表达式停下的地方，一直执行到return语句</span></span><br><span class=\"line\"><span class=\"comment\">（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，</span></span><br><span class=\"line\"><span class=\"comment\">就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），</span></span><br><span class=\"line\"><span class=\"comment\">done属性的值true，表示遍历已经结束。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">第四次调用，此时 Generator 函数已经运行完毕，</span></span><br><span class=\"line\"><span class=\"comment\">next方法返回对象的value属性为undefined，done属性为true。</span></span><br><span class=\"line\"><span class=\"comment\">以后再调用next方法，返回的都是这个值。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"yield-表达式说明\"><a href=\"#yield-表达式说明\" class=\"headerlink\" title=\"yield 表达式说明\"></a>yield 表达式说明</h3><ul>\n<li>Generator 函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield表达式就是暂停标志。</li>\n<li>遍历器对象的next方法的运行逻辑如下。<ul>\n<li>遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</li>\n<li>下一次调用next方法时，再继续往下执行，直到遇到下一个yield表达式。</li>\n<li>如果没有再遇到新的yield表达式，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</li>\n<li>如果该函数没有return语句，则返回的对象的 value 属性值为 undefined。</li>\n</ul>\n</li>\n<li>需要注意的是，yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">123</span> + <span class=\"number\">456</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值.</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"yield-表达式语法\"><a href=\"#yield-表达式语法\" class=\"headerlink\" title=\"yield 表达式语法\"></a>yield 表达式语法</h3><ul>\n<li>yield表达式只能用在 Generator 函数里面，用在其他地方都会报错</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"><span class=\"comment\">// SyntaxError: Unexpected number</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>yield表达式如果用在另一个表达式之中，必须放在圆括号里面</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">demo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Hello&#x27;</span> + <span class=\"keyword\">yield</span>); <span class=\"comment\">// SyntaxError</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Hello&#x27;</span> + <span class=\"keyword\">yield</span> <span class=\"number\">123</span>); <span class=\"comment\">// SyntaxError</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Hello&#x27;</span> + (<span class=\"keyword\">yield</span>)); <span class=\"comment\">// OK</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Hello&#x27;</span> + (<span class=\"keyword\">yield</span> <span class=\"number\">123</span>)); <span class=\"comment\">// OK</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>yield表达式用作函数参数或放在赋值表达式的右边，可以不加括号</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">demo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  foo(<span class=\"keyword\">yield</span> <span class=\"string\">&#x27;a&#x27;</span>, <span class=\"keyword\">yield</span> <span class=\"string\">&#x27;b&#x27;</span>); <span class=\"comment\">// OK</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> input = <span class=\"keyword\">yield</span>; <span class=\"comment\">// OK</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"用法实例讲解\"><a href=\"#用法实例讲解\" class=\"headerlink\" title=\"用法实例讲解\"></a>用法实例讲解</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, [[<span class=\"number\">2</span>, <span class=\"number\">3</span>], <span class=\"number\">4</span>], [<span class=\"number\">5</span>, <span class=\"number\">6</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> flat = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">  a.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> item !== <span class=\"string\">&#x27;number&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">yield</span>* flat(item);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">yield</span> item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;  <span class=\"comment\">// 错误用法</span></span><br><span class=\"line\"><span class=\"comment\">// forEach方法的参数是一个普通函数，但是在里面使用了yield表达式</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一种修改方法是改用for循环。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> flat = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> length = a.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> item = a[i];</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> item !== <span class=\"string\">&#x27;number&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">yield</span>* flat(item);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">yield</span> item;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> f <span class=\"keyword\">of</span> flat(arr)) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1, 2, 3, 4, 5, 6</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"yield表达式与return语句\"><a href=\"#yield表达式与return语句\" class=\"headerlink\" title=\"yield表达式与return语句\"></a>yield表达式与return语句</h3><ul>\n<li>yield 表达式与return 语句既有相似之处，也有区别。  </li>\n<li>相似之处在于，都能返回紧跟在语句后面的那个表达式的值。  </li>\n<li>区别在于每次遇到<code>yield</code>，函数暂停执行，下一次再从该位置继续向后执行，而<code>return</code>语句不具备位置记忆的功能。 </li>\n<li>一个函数里面，<strong>只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield表达式</strong>。  </li>\n<li>正常函数只能返回一个值，因为只能执行一次return；  </li>\n<li>Generator 函数可以返回一系列的值，因为可以有任意多个<code>yield</code>。  </li>\n<li>从另一个角度看，也可以说 Generator 生成了一系列的值。  </li>\n</ul>\n<h3 id=\"next-方法的参数\"><a href=\"#next-方法的参数\" class=\"headerlink\" title=\"next 方法的参数\"></a>next 方法的参数</h3><ul>\n<li><code>yield</code>表达式本身没有返回值，或者说总是返回<code>undefined</code>。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; <span class=\"literal\">true</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> reset = <span class=\"keyword\">yield</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(reset) &#123; i = -<span class=\"number\">1</span>; &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> g = f();</span><br><span class=\"line\"></span><br><span class=\"line\">g.next() <span class=\"comment\">// &#123; value: 0, done: false &#125;</span></span><br><span class=\"line\">g.next() <span class=\"comment\">// &#123; value: 1, done: false &#125;</span></span><br><span class=\"line\">g.next(<span class=\"literal\">true</span>) <span class=\"comment\">// &#123; value: 0, done: false &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">上面代码先定义了一个可以无限运行的 Generator 函数f，</span></span><br><span class=\"line\"><span class=\"comment\">如果next方法没有参数，每次运行到yield表达式，变量reset的值总是undefined。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，</span></span><br><span class=\"line\"><span class=\"comment\">下一轮循环就会从-1开始递增。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。</li>\n<li>通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。  </li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">foo</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> y = <span class=\"number\">2</span> * (<span class=\"keyword\">yield</span> (x + <span class=\"number\">1</span>));</span><br><span class=\"line\">  <span class=\"keyword\">var</span> z = <span class=\"keyword\">yield</span> (y / <span class=\"number\">3</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (x + y + z);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = foo(<span class=\"number\">5</span>);</span><br><span class=\"line\">a.next() <span class=\"comment\">// Object&#123;value:6, done:false&#125;</span></span><br><span class=\"line\">a.next() <span class=\"comment\">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class=\"line\">a.next() <span class=\"comment\">// Object&#123;value:NaN, done:true&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = foo(<span class=\"number\">5</span>);</span><br><span class=\"line\">b.next() <span class=\"comment\">// &#123; value:6, done:false &#125;</span></span><br><span class=\"line\">b.next(<span class=\"number\">12</span>) <span class=\"comment\">// &#123; value:8, done:false &#125;</span></span><br><span class=\"line\">b.next(<span class=\"number\">13</span>) <span class=\"comment\">// &#123; value:42, done:true &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">上面代码中，第二次运行next方法的时候不带参数，导致 y 的值等于2 * undefined（即NaN），</span></span><br><span class=\"line\"><span class=\"comment\">除以 3 以后还是NaN，因此返回对象的value属性也等于NaN。</span></span><br><span class=\"line\"><span class=\"comment\">第三次运行Next方法的时候不带参数，所以z等于undefined，</span></span><br><span class=\"line\"><span class=\"comment\">返回对象的value属性等于5 + NaN + undefined，即NaN。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">如果向next方法提供参数，返回结果就完全不一样了。</span></span><br><span class=\"line\"><span class=\"comment\">上面代码第一次调用b的next方法时，返回x+1的值6；</span></span><br><span class=\"line\"><span class=\"comment\">第二次调用next方法，将上一次yield表达式的值设为12，因此y等于24，返回y / 3的值8；</span></span><br><span class=\"line\"><span class=\"comment\">第三次调用next方法，将上一次yield表达式的值设为13，因此z等于13，</span></span><br><span class=\"line\"><span class=\"comment\">这时x等于5，y等于24，所以return语句的值等于42。</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>注意，由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。  </li>\n</ul>\n<h3 id=\"for…of-循环\"><a href=\"#for…of-循环\" class=\"headerlink\" title=\"for…of 循环\"></a>for…of 循环</h3><ul>\n<li><ol>\n<li>for…of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。  </li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">4</span>;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">6</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> v <span class=\"keyword\">of</span> foo()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(v);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1 2 3 4 5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 上面代码使用for...of循环，依次显示 5 个yield表达式的值。</span></span><br><span class=\"line\"><span class=\"comment\">// 这里需要注意，一旦next方法的返回对象的done属性为true，</span></span><br><span class=\"line\"><span class=\"comment\">// for...of循环就会中止，且不包含该返回对象，</span></span><br><span class=\"line\"><span class=\"comment\">// 所以上面代码的return语句返回的6，不包括在for...of循环之中。</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">* 2)利用`</span><span class=\"keyword\">for</span>...of<span class=\"string\">`循环，可以写出遍历任意对象（object）的方法。原生的 JavaScript 对象没有遍历接口，无法使用for...of循环，通过 Generator 函数为它加上这个接口，就可以用了。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">objectEntries</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> propKeys = <span class=\"built_in\">Reflect</span>.ownKeys(obj);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> propKey <span class=\"keyword\">of</span> propKeys) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> [propKey, obj[propKey]];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> jane = &#123; <span class=\"attr\">first</span>: <span class=\"string\">&#x27;Jane&#x27;</span>, <span class=\"attr\">last</span>: <span class=\"string\">&#x27;Doe&#x27;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> objectEntries(jane)) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>: <span class=\"subst\">$&#123;value&#125;</span>`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// first: Jane</span></span><br><span class=\"line\"><span class=\"comment\">// last: Doe</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>3)加上遍历器接口的另一种写法是，将 Generator 函数加到对象的<code>Symbol.iterator</code>属性上面</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">objectEntries</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> propKeys = <span class=\"built_in\">Object</span>.keys(<span class=\"built_in\">this</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> propKey <span class=\"keyword\">of</span> propKeys) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">yield</span> [propKey, <span class=\"built_in\">this</span>[propKey]];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> jane = &#123; <span class=\"attr\">first</span>: <span class=\"string\">&#x27;Jane&#x27;</span>, <span class=\"attr\">last</span>: <span class=\"string\">&#x27;Doe&#x27;</span> &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">jane[<span class=\"built_in\">Symbol</span>.iterator] = objectEntries;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [key, value] <span class=\"keyword\">of</span> jane) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;key&#125;</span>: <span class=\"subst\">$&#123;value&#125;</span>`</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// first: Jane</span></span><br><span class=\"line\"><span class=\"comment\">// last: Doe</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>4)除了for…of循环以外，<code>扩展运算符（...）</code>、<code>解构赋值</code>和<code>Array.from</code>方法内部调用的，都是遍历器接口。这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。  </li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">numbers</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">3</span></span><br><span class=\"line\">  <span class=\"keyword\">yield</span> <span class=\"number\">4</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 扩展运算符</span></span><br><span class=\"line\">[...numbers()] <span class=\"comment\">// [1, 2]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Array.from 方法</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.from(numbers()) <span class=\"comment\">// [1, 2]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解构赋值</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [x, y] = numbers();</span><br><span class=\"line\">x <span class=\"comment\">// 1</span></span><br><span class=\"line\">y <span class=\"comment\">// 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// for...of 循环</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> n <span class=\"keyword\">of</span> numbers()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(n)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Generator函数的异步操作\"><a href=\"#Generator函数的异步操作\" class=\"headerlink\" title=\"Generator函数的异步操作\"></a>Generator函数的异步操作</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">asyncJob</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...其他代码</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> f = <span class=\"keyword\">yield</span> readFile(fileA);</span><br><span class=\"line\">  <span class=\"comment\">// ...其他代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。<br>也就是说，yield命令是异步两个阶段的分界线。<br>协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p>\n<p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。<br>整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。</p>\n<h3 id=\"异步任务的封装\"><a href=\"#异步任务的封装\" class=\"headerlink\" title=\"异步任务的封装\"></a>异步任务的封装</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fetch = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;node-fetch&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>* <span class=\"title\">gen</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> url = <span class=\"string\">&#x27;https://api.github.com/users/github&#x27;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"keyword\">yield</span> fetch(url);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(result.bio);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。</span></span><br><span class=\"line\"><span class=\"comment\">// 就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 执行上述代码</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> g = gen();</span><br><span class=\"line\"><span class=\"keyword\">var</span> result = g.next();</span><br><span class=\"line\"></span><br><span class=\"line\">result.value.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> data.json();</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">  g.next(data);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 首先执行 Generator 函数，获取遍历器对象，然后使用next方法（第二行），执行异步任务的第一阶段。</span></span><br><span class=\"line\"><span class=\"comment\">// 由于Fetch模块返回的是一个 Promise 对象，因此要用then方法调用下一个next方法。</span></span><br></pre></td></tr></table></figure>\n<p>虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p>\n<h2 id=\"async-函数\"><a href=\"#async-函数\" class=\"headerlink\" title=\"async 函数\"></a>async 函数</h2><p>学习指导：<a href=\"http://es6.ruanyifeng.com/#docs/async\">阮一峰ES6 – async函数</a></p>\n<h3 id=\"含义\"><a href=\"#含义\" class=\"headerlink\" title=\"含义\"></a>含义</h3><ul>\n<li>async 函数是什么？一句话，它就是 Generator 函数的语法糖</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// generator 函数依次读取两个文件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> readFile = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">fileName</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">    fs.readFile(fileName, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error, data</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (error) <span class=\"keyword\">return</span> reject(error);</span><br><span class=\"line\">      resolve(data);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> gen = <span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f1 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">&#x27;/etc/fstab&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f2 = <span class=\"keyword\">yield</span> readFile(<span class=\"string\">&#x27;/etc/shells&#x27;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// async函数，就是下面这样</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> asyncReadFile = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f1 = <span class=\"keyword\">await</span> readFile(<span class=\"string\">&#x27;/etc/fstab&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f2 = <span class=\"keyword\">await</span> readFile(<span class=\"string\">&#x27;/etc/shells&#x27;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f1.toString());</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(f2.toString());</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>async函数对 Generator 函数的改进，体现在以下四点：<ul>\n<li><strong>内置执行器</strong> —— Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。</li>\n<li><strong>更好的语义</strong> —— async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</li>\n<li><strong>更广的适用性</strong> —— co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</li>\n<li><strong>返回值是 Promise</strong> —— async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。<strong>进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。</strong>  </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"基本用法\"><a href=\"#基本用法\" class=\"headerlink\" title=\"基本用法\"></a>基本用法</h3><p>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>\n<ul>\n<li>引入demo</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* async 表示异步调用 返回一个Promise对象 */</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">timeout</span>(<span class=\"params\">ms</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">setTimeout</span>(resolve, ms);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;  <span class=\"comment\">/* 与下边等价*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// function timeout(ms) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     return new Promise((resolve) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//       setTimeout(resolve, ms);</span></span><br><span class=\"line\"><span class=\"comment\">//     &#125;);</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">asyncPrint</span>(<span class=\"params\">value, ms</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> timeout(ms);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">asyncPrint(<span class=\"string\">&#x27;hello world&#x27;</span>, <span class=\"number\">3000</span>)  <span class=\"comment\">// 3000毫秒以后，输出hello world</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>async的表达方式</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数表达式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 对象的方法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">foo</span>(<span class=\"params\"></span>)</span> &#123;&#125; &#125;;</span><br><span class=\"line\">obj.foo().then(...)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Class 的方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Storage</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.cachePromise = caches.open(<span class=\"string\">&#x27;avatars&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">getAvatar</span>(<span class=\"params\">name</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cache = <span class=\"keyword\">await</span> <span class=\"built_in\">this</span>.cachePromise;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cache.match(<span class=\"string\">`/avatars/<span class=\"subst\">$&#123;name&#125;</span>.jpg`</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> storage = <span class=\"keyword\">new</span> Storage();</span><br><span class=\"line\">storage.getAvatar(<span class=\"string\">&#x27;jake&#x27;</span>).then(…);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 箭头函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"keyword\">async</span> () =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"async-的语法\"><a href=\"#async-的语法\" class=\"headerlink\" title=\"async 的语法\"></a>async 的语法</h3><ul>\n<li><p>返回Promise 对象</p>\n<ul>\n<li>async函数返回一个 Promise 对象。</li>\n<li>async函数内部return语句返回的值，会成为then方法回调函数的参数。</li>\n</ul>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&#x27;hello world&#x27;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// &quot;hello world&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 函数 f 内部return命令返回的值，会被then方法回调函数接收到。</span></span><br></pre></td></tr></table></figure></li>\n<li><p>async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;出错了&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(</span><br><span class=\"line\">  <span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v),</span><br><span class=\"line\">  <span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\">// Error: 出错了</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>Promise 对象的状态变化</p>\n<ul>\n<li>async函数返回的 Promise 对象，必须等到内部所有await命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。</li>\n<li>也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</li>\n</ul>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getTitle</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> response = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> html = <span class=\"keyword\">await</span> response.text();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> html.match(<span class=\"regexp\">/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i</span>)[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getTitle(<span class=\"string\">&#x27;https://tc39.github.io/ecma262/&#x27;</span>).then(<span class=\"built_in\">console</span>.log)</span><br><span class=\"line\"><span class=\"comment\">// &quot;ECMAScript 2017 Language Specification&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。</span></span><br><span class=\"line\"><span class=\"comment\">// 只有这三个操作全部完成，才会执行then方法里面的 console.log。</span></span><br></pre></td></tr></table></figure></li>\n<li><p>await 命令</p>\n<ul>\n<li>正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。</li>\n</ul>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f().then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// 123</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// await命令的参数是数值123，它被转成 Promise 对象，并立即resolve</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>await命令后面的 Promise 对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。</li>\n</ul>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">&#x27;出错了&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\">.catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(e))</span><br><span class=\"line\"><span class=\"comment\">// 出错了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// await 语句前面没有 return，但是 reject 方法的参数依然传入了 catch 方法的回调函数。</span></span><br><span class=\"line\"><span class=\"comment\">// 这里如果在await前面加上return，效果是一样的。</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>只要一个await语句后面的 Promise 变为reject，那么整个async函数都会中断执行</li>\n</ul>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">&#x27;出错了&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">&#x27;hello world&#x27;</span>); <span class=\"comment\">// 不会执行</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以将第一个await放在<code>try...catch</code>结构里面，这样不管这个异步操作是否成功，第二个await都会执行。</li>\n</ul>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">&#x27;出错了&#x27;</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">&#x27;hello world&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// hello world</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>另一种方法是await后面的 Promise 对象再跟一个catch方法，处理前面可能出现的错误</li>\n</ul>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"string\">&#x27;出错了&#x27;</span>)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> <span class=\"built_in\">console</span>.log(e));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.resolve(<span class=\"string\">&#x27;hello world&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\">.then(<span class=\"function\"><span class=\"params\">v</span> =&gt;</span> <span class=\"built_in\">console</span>.log(v))</span><br><span class=\"line\"><span class=\"comment\">// 出错了</span></span><br><span class=\"line\"><span class=\"comment\">// hello world</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"使用注意点\"><a href=\"#使用注意点\" class=\"headerlink\" title=\"使用注意点\"></a>使用注意点</h3><ul>\n<li>第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在<code>try...catch</code>代码块中。</li>\n<li>第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"keyword\">await</span> getFoo();</span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"keyword\">await</span> getBar();</span><br><span class=\"line\"><span class=\"comment\">// 上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。</span></span><br><span class=\"line\"><span class=\"comment\">// 这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法一</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [foo, bar] = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all([getFoo(), getBar()]);</span><br><span class=\"line\"><span class=\"comment\">// 写法二</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fooPromise = getFoo();</span><br><span class=\"line\"><span class=\"keyword\">let</span> barPromise = getBar();</span><br><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"keyword\">await</span> fooPromise;</span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"keyword\">await</span> barPromise;</span><br><span class=\"line\"><span class=\"comment\">// getFoo和getBar都是同时触发，这样就会缩短程序的执行时间</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 报错</span></span><br><span class=\"line\">  docs.forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">doc</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.post(doc);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 上面代码会报错，因为await用在普通函数之中了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 采用for循环</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> doc <span class=\"keyword\">of</span> docs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.post(doc);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果确实希望多个请求并发执行，可以使用Promise.all方法。</span></span><br><span class=\"line\"><span class=\"comment\">// 当三个请求都会resolved时，下面两种写法效果相同。</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promises = docs.map(<span class=\"function\">(<span class=\"params\">doc</span>) =&gt;</span> db.post(doc));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> results = <span class=\"keyword\">await</span> <span class=\"built_in\">Promise</span>.all(promises);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(results);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者使用下面的写法</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dbFuc</span>(<span class=\"params\">db</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promises = docs.map(<span class=\"function\">(<span class=\"params\">doc</span>) =&gt;</span> db.post(doc));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> results = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> promise <span class=\"keyword\">of</span> promises) &#123;</span><br><span class=\"line\">    results.push(<span class=\"keyword\">await</span> promise);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(results);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"async函数实现原理\"><a href=\"#async函数实现原理\" class=\"headerlink\" title=\"async函数实现原理\"></a>async函数实现原理</h3><ul>\n<li>async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> spawn(<span class=\"function\"><span class=\"keyword\">function</span>* (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 所有的async函数都可以写成上面的第二种形式，其中的spawn函数就是自动执行器。</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"场景再现\"><a href=\"#场景再现\" class=\"headerlink\" title=\"场景再现\"></a>场景再现</h3><ul>\n<li>假定某个 DOM 元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">chainAnimationsAsync</span>(<span class=\"params\">elem, animations</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> ret = <span class=\"literal\">null</span>;  <span class=\"comment\">// 变量ret用来保存上一个动画的返回值</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> anim <span class=\"keyword\">of</span> animations) &#123;</span><br><span class=\"line\">      ret = <span class=\"keyword\">await</span> anim(elem);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">/* 忽略错误，继续执行 */</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>依次远程读取一组 URL，然后按照读取的顺序输出结果。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 远程操作继发.只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logInOrder</span>(<span class=\"params\">urls</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> url <span class=\"keyword\">of</span> urls) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> response.text());</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 并发发出远程请求</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">logInOrder</span>(<span class=\"params\">urls</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 并发读取远程URL</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> textPromises = urls.map(<span class=\"keyword\">async</span> url =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> fetch(url);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.text();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 按次序输出</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> textPromise <span class=\"keyword\">of</span> textPromises) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">await</span> textPromise);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckra1uprq00002nzt7hssfto4","tag_id":"ckra1uprs00012nztfdcc0hl2","_id":"ckra1uprs00022nzt9kx3cc4z"},{"post_id":"ckrd8jv150000kwzt3zuu0ly8","tag_id":"ckrd8jv170002kwzt64eygg18","_id":"ckrd8jv1a0007kwzt188k7qg1"},{"post_id":"ckrd8jv160001kwzt797a4gyu","tag_id":"ckrd8jv190006kwzt3gsdfahr","_id":"ckrd8jv1c000ckwzth735bnrm"},{"post_id":"ckrd8jv180003kwzt3m5n5zy7","tag_id":"ckrd8jv190006kwzt3gsdfahr","_id":"ckrd8jv1c000ekwzt869c4cir"},{"post_id":"ckrd8jv180004kwzt0tdm78ix","tag_id":"ckrd8jv1c000dkwztgkuyev0j","_id":"ckrd8jv1c000gkwzt4n0kdfzf"},{"post_id":"ckrd8jv190005kwzt2ds09w2y","tag_id":"ckrd8jv1c000fkwztawxn4g9r","_id":"ckrd8jv1d000ikwztbc1pec1c"},{"post_id":"ckrd8jv1a0008kwztay80ezdm","tag_id":"ckrd8jv1c000dkwztgkuyev0j","_id":"ckrd8jv1d000kkwzt7e784fl9"},{"post_id":"ckrd8jv1b0009kwztcs59fday","tag_id":"ckrd8jv1d000jkwztc8hi2bd9","_id":"ckrd8jv1d000mkwzta0ro8090"},{"post_id":"ckrd8jv1c000bkwzt7sog16bg","tag_id":"ckrd8jv1d000jkwztc8hi2bd9","_id":"ckrd8jv1d000nkwzt0pctet60"},{"post_id":"ckrd8jv1h000okwzt4zmq1mlu","tag_id":"ckrd8jv1h000pkwztfnz55i4i","_id":"ckrd8jv1h000qkwztb3rk5d18"}],"Tag":[{"name":"人生","_id":"ckra1uprs00012nztfdcc0hl2"},{"name":"Mongodb | Mongodb","_id":"ckrd8jv170002kwzt64eygg18"},{"name":"Hexo","_id":"ckrd8jv190006kwzt3gsdfahr"},{"name":"VSCode","_id":"ckrd8jv1c000dkwztgkuyev0j"},{"name":"Koa2","_id":"ckrd8jv1c000fkwztawxn4g9r"},{"name":"面试","_id":"ckrd8jv1d000jkwztc8hi2bd9"},{"name":"JavaScript | ES6","_id":"ckrd8jv1h000pkwztfnz55i4i"}]}}